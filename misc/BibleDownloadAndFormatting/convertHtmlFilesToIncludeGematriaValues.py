#!/usr/bin/env python3
##############################################################################
# Description:
#
#   This script modifies HTML files of the Bible that have already
#   been downloaded from http://www.blueletterbible.org/.  The
#   modifications that are done are to remove Strong's Concordance
#   numbers from the HTML (optional removal), and replace them with
#   "[=X]" where X is the gematria value for that word.
#
# Usage:
#
#   1) Update the global variables and make sure they are correct
#   according to desired operation.
#
#   2) Run the script:
#
#       python3 convertHtmlFilesToIncludeGematriaValues.py
#
##############################################################################

# For obtaining current directory path information, and creating directories
import os
import sys 
import errno
import glob

# For logging.
import logging

##############################################################################
# Global variables

# Filename of the CSV file containing key-value pairs of:
# Strong's Concordance Numbers to gematria values.
#
# The input file below is an output product generated by script
# 'getAllStrongsConcordanceGematriaValues.py'.
#
inputGematriaValuesCSVFilename = "/home/rluu/programming/pricechartingtool/misc/BibleDownloadAndFormatting/BibleGematriaValues.csv"

# First line is a header line and is skipped.
linesToSkip = 1

# List of directories that contain HTML files to be modified.
directoriesWithHtmlFilesForModification = \
    ["/home/rluu/programming/pricechartingtool/misc/BibleDownloadAndFormatting/Daniel",
     "/home/rluu/programming/pricechartingtool/misc/BibleDownloadAndFormatting/Ezekiel"]

# Flag to also remove the Strong's Concordance numbers that are in the HTML.
removeStrongsConcordanceNumbersFromHTML = True

# For logging.
logging.basicConfig(level=logging.INFO,
                    format='%(levelname)s: %(message)s')
moduleName = globals()['__name__']
log = logging.getLogger(moduleName)


##############################################################################

def shutdown(rc):
    """Exits the script, but first flushes all logging handles, etc."""
    logging.shutdown()
    sys.exit(rc)

##############################################################################

def getDictOfGematriaValues():
    """Returns a dictionary containing key-value pairs of: Strong's
    Concordance Numbers to gematria values.  This function assumes
    that global variable 'inputGematriaValuesCSVFilename' is set
    appropriately, because this is the CSV file that this function
    gets its information from.

    Returns:
    dict with key-value pairs of: Strong's Concordance Numbers to
    gematria values.
    """

    # Return value.
    rv = {}
    
    with open(inputGematriaValuesCSVFilename, 'r') as f:
        lineNumber = 0
        for line in f:
            line = line.strip()
            
            if lineNumber >= linesToSkip and line != "":
                splitLines = line.split(",")

                if len(splitLines) != 2:
                    log.error("Invalid line in CSV file.  " + \
                              "Expected two fields.  lines[{}] was: {}".\
                              format(lineNumber, line))
                    shutdown(1)
                    
                key = splitLines[0]
                value = splitLines[1]

                if value.isdigit() != True:
                    log.error("Invalid line in CSV file.  " + \
                              "Expected second field to be an integer.  " + \
                              "lines[{}] was: {}".\
                              format(lineNumber, line))
                    shutdown(1)

                rv[key] = value
                
            lineNumber += 1

    return rv

def isValidStrongsConcordanceNumber(strongsNumberStr):
    """Returns True if the given string is a valid Strong's
    Concordance Number, false otherwise.
    """

    rv = True
    
    # Error checking of the input.
    if len(strongsNumberStr) != 5:
        log.warn("Invalid Strong's Concordance Number: {}".\
                    format(strongsNumberStr))
        rv = False
        
    elif strongsNumberStr[0].upper() != "H" and \
        strongsNumberStr[0].upper() != "G":
        
        log.warn("First character of the Strong's Concordance Number " + \
                  "must be a G or H.  " + \
                 "str given was: {}".format(strongsNumberStr))
        rv = False
    
    elif not strongsNumberStr[1:].isdigit():
        
        log.warn("Characters in the str are not numerical digits " + \
                  "as expected.  " + \
                  "str given was: {}".format(strongsNumberStr))
        rv = False


    # Check the number range and warn if it is out of the expected
    # range.  I won't say this means it's an invalid Strong's
    # Concordance Number though.
    
    if strongsNumberStr[0].upper() == "G":
        numberStr = strongsNumberStr[1:]
        numberInt = int(strongsNumberStr[1:])
        
        # The first Strong's Concordance number for the Greek is: G0001
        # The last  Strong's Concordance number for the Greek is: G5624
        minLimit = 1
        maxLimit = 5624
        if not (minLimit <= numberInt <= maxLimit):
            log.warn("Strong's Concordance Number was out of " + \
                     "expected range.  Value seen was: '{}'".\
                     format(numberInt))
            
    elif strongsNumberStr[0].upper() == "H":
        numberStr = strongsNumberStr[1:]
        numberInt = int(strongsNumberStr[1:])
        
        # The first Strong's Concordance number for the Hebrew is: H0001
        # The last  Strong's Concordance number for the Hebrew is: H8674
        minLimit = 1
        maxLimit = 8674
        if not (minLimit <= numberInt <= maxLimit):
            log.warn("Strong's Concordance Number was out of " + \
                     "expected range.  Value seen was: '{}'".\
                     format(numberInt))
        
    return rv
    

def modifyHtmlFile(htmlFilename, dictOfGematriaValues):
    """Modifies the given HTML by removing Strong's Concordance
    numbers from the HTML (if the flag is set to do this), and replace
    them with "[=X]" where X is the gematria value for that word.
    
    Arguments:
    htmlFilename - str value holding the path to the HTML file to modify.
    
    dictOfGematriaValues - dict holding key-value pairs of Strong's
                           Concordance Numbers to gematria values.
    """

    # Text of the input HTML file.
    text = ""

    # Count of gematria value strings added.
    count = 0
    
    # Read all the lines of the file into 'text'.
    with open(htmlFilename, "r") as f:
        text = f.read()


    # Output text that will go into the file (with modifications)
    # after we're all done looking at it.
    outputText = ""

    # Go through and find each Strong's Concordance Number, and
    # replace the text for each one until there are no more instances
    # of it to replace.
    searchStr = "strongs="
    currPos = 0

    strongsPos = text.find(searchStr, currPos)
    while strongsPos != -1:
        # Find the ending double-quote, which should be at the end of
        # the Strong's Concordance Number.
        endQuotePos = text.find("\"", strongsPos)

        # Extract the Strong's Concordance Number.
        startPos = strongsPos + len(searchStr)
        endPos = endQuotePos
        
        strongsNumberStr = text[startPos:endPos]

        # Sometimes the website gives us Strong's number without
        # leading zeros for the number part.  We'll check for this
        # here and insert a zero if necessary, so that our dictionary
        # look-up will work.
        strongsNumberStr = strongsNumberStr.upper()
        while 1 < len(strongsNumberStr) < 5:
            strongsNumberStr = \
                strongsNumberStr[0:1] + "0" + strongsNumberStr[1:]

        # Check to make sure it is a valid Strong's Concordance Number.
        if not isValidStrongsConcordanceNumber(strongsNumberStr):
            # Invalid Strong's Concordance Number.
            log.error("Unknown str found which we thought was a " + \
                      "Strong's Concordance Number.  " + \
                      "strongsPos == {}, ".format(strongsPos) + \
                      "candidateStrongsNumberStr == '{}', ".\
                      format(strongsNumberStr) + \
                      "text is: ***{}***".format(text))
            shutdown(1)

        # Valid Strong's Concordance Number.
            
        # Get the gematria value for this word.
        try:
            gematriaValue = dictOfGematriaValues[strongsNumberStr]
        except KeyError as e:
            log.warn("Using a gematria value of -1 for " + \
                     "the failed lookup of " + \
                     "Strong's Concordance Number '{}' in file '{}'".\
                     format(strongsNumberStr, htmlFilename))
            gematriaValue = -1

        if gematriaValue == None:
            log.error("Couldn't find the gematria value for " + \
                      "Strong's Concordance Number '{}'".\
                      format(strongsNumberStr))
            shutdown(1)
        
        # Find the positions of the next <sup> tag.
        supOpenTagPos  = text.find("<sup", strongsPos)
        supCloseTagPos = text.find("</sup>", supOpenTagPos)
        supOpenTagEndPos = text.rfind(">", supOpenTagPos, supCloseTagPos)

        # The text in superscript starts at position: supOpenTagEndPos + 1.
        # The text in superscript ends   at position: supCloseTagPos.
        startSupTextPos = supOpenTagEndPos + 1
        endSupTextPos = supCloseTagPos

        # Current superscript text.
        currSupText = text[startSupTextPos:endSupTextPos]

        # Append the text before this, from currPos to
        # startSupTextPos, to the variable 'outputText'.
        outputText += text[currPos:startSupTextPos]

        # Check to flag to see if we should be removing the Strong's
        # Concordance numbers that are in the HTML.
        if removeStrongsConcordanceNumbersFromHTML == False:
            # Append Strong's Concordance Number.
            outputText += currSupText

        # Append the gematria value.
        outputText += "[={}]".format(gematriaValue)

        # Increment counter for how many words we added gematria
        # values for.
        count += 1
        
        # Update currPos.
        currPos = supCloseTagPos

        # Get the next strongsPos for the next loop iteration.
        strongsPos = text.find(searchStr, currPos)
        
    # There are no more Strong's Concordance Numbers found in the text.
    # Append the rest of the file.
    outputText += text[currPos:]

    log.info("Added gematria values for {} ".format(count) + \
             "Strong's Concordance words in file '{}'.".\
             format(htmlFilename))
    log.info("Writing modified text back out to file '{}' ...".\
             format(htmlFilename))
    
    # Write outputText back to the file, overwriting what was there before.
    with open(htmlFilename, "w", encoding="utf-8") as f:
        f.write(outputText)
    
    return

        
##############################################################################

if __name__ == "__main__":

    log.info("Obtaining gematria values from input CSV file '{}' ...".\
              format(inputGematriaValuesCSVFilename))

    dictOfGematriaValues = getDictOfGematriaValues()

    log.info("Obtaining list of HTML files to modify ...")

    for directory in directoriesWithHtmlFilesForModification:
        log.debug("Looking in directory '{}' ...".format(directory))
        
        for htmlFilename in glob.glob(directory + os.sep + "*[hH][tT][mM][lL]"):
            log.debug("Found file '{}'".format(htmlFilename))

            modifyHtmlFile(htmlFilename, dictOfGematriaValues)
            
    log.info("Done.")
    shutdown(0)
    
##############################################################################
    
