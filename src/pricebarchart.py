
# For line separator.
import os

# For determining what system platform we are on.
# Some possibilities are:
#   Darwin
#   Linux
#   Windows
#   Java
import platform

# For logging.
import logging

# For copy.deepcopy().
import copy

# For dynamically adding methods to instances.
import types

# For calculating square roots and other calculations.
import math

# For timing how long LookbackMultiple calculations take.
import time

# For timestamps and timezone information.
import datetime
import pytz

# For multiprocessing features with LookbackMultiple calculations.
from multiprocessing.managers import BaseManager
from multiprocessing import JoinableQueue
from multiprocessing.context import AuthenticationError

# For PyQt UI classes.
from PyQt4 import QtCore
from PyQt4.QtCore import *
from PyQt4.QtGui import *

# Import image resources.
import resources

# For QSettings keys.
from settings import SettingsKeys

# For constants used.
from astrologychart import AstrologyUtils

# For calendar conversions, and display methods.
from hebrew_calendar_utils import HebrewCalendarUtils

# For conversions from julian day to datetime.datetime and vice versa.
from ephemeris import Ephemeris

# For getting datetimes forward and backward in time, 
# to support LookbackMultiple.
from lookbackmultiple_parallel import LookbackMultipleParallel
from lookbackmultiple_calc import LookbackMultipleUtils

# For making planet longitude movement measurements.
from planetlongitudemovementmeasurement_calc import PLMMUtils
from planetlongitudemovementmeasurement_parallel import PlanetLongitudeMovementMeasurementParallel


# For generic utility helper methods.
from util import Util


# For PriceBars and artifacts in the chart.
from data_objects import BirthInfo
from data_objects import PriceBar
from data_objects import MusicalRatio
from data_objects import LookbackMultiple
from data_objects import LookbackMultiplePriceBar
from data_objects import LookbackMultipleCalcModel
from data_objects import PriceBarChartBarCountArtifact
from data_objects import PriceBarChartTimeMeasurementArtifact
from data_objects import PriceBarChartTimeModalScaleArtifact
from data_objects import PriceBarChartPriceModalScaleArtifact
from data_objects import PriceBarChartPlanetLongitudeMovementMeasurementArtifact
from data_objects import PriceBarChartTextArtifact
from data_objects import PriceBarChartPriceTimeInfoArtifact
from data_objects import PriceBarChartPriceMeasurementArtifact
from data_objects import PriceBarChartTimeRetracementArtifact
from data_objects import PriceBarChartPriceRetracementArtifact
from data_objects import PriceBarChartPriceTimeVectorArtifact
from data_objects import PriceBarChartLineSegmentArtifact
from data_objects import PriceBarChartVerticalLineSegmentArtifact
from data_objects import PriceBarChartHorizontalLineSegmentArtifact
from data_objects import PriceBarChartOctaveFanArtifact
from data_objects import PriceBarChartFibFanArtifact
from data_objects import PriceBarChartGannFanArtifact
from data_objects import PriceBarChartVimsottariDasaArtifact
from data_objects import PriceBarChartAshtottariDasaArtifact
from data_objects import PriceBarChartYoginiDasaArtifact
from data_objects import PriceBarChartDwisaptatiSamaDasaArtifact
from data_objects import PriceBarChartShattrimsaSamaDasaArtifact
from data_objects import PriceBarChartDwadasottariDasaArtifact
from data_objects import PriceBarChartChaturaseetiSamaDasaArtifact
from data_objects import PriceBarChartSataabdikaDasaArtifact
from data_objects import PriceBarChartShodasottariDasaArtifact
from data_objects import PriceBarChartPanchottariDasaArtifact
from data_objects import PriceBarChartShashtihayaniDasaArtifact
from data_objects import PriceBarChartScaling
from data_objects import PriceBarChartSettings

# Edit dialogs.
from dialogs import LookbackMultiplePriceBarEditDialog

# For edit dialogs for modifying the PriceBarChartArtifact objects of
# various PriceBarChartArtifactGraphicsItems.
from pricebarchart_dialogs import PriceBarChartBarCountArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartTimeMeasurementArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartTimeModalScaleArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartPriceModalScaleArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartPlanetLongitudeMovementMeasurementArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartTextArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartPriceTimeInfoArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartPriceMeasurementArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartTimeRetracementArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartPriceRetracementArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartPriceTimeVectorArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartLineSegmentArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartVerticalLineSegmentArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartHorizontalLineSegmentArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartOctaveFanArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartFibFanArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartGannFanArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartVimsottariDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartAshtottariDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartYoginiDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartDwisaptatiSamaDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartShattrimsaSamaDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartDwadasottariDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartChaturaseetiSamaDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartSataabdikaDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartShodasottariDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartPanchottariDasaArtifactEditDialog
from pricebarchart_dialogs import PriceBarChartShashtihayaniDasaArtifactEditDialog


# For edit dialogs.
from dialogs import PriceBarEditDialog

class PriceBarGraphicsItem(QGraphicsItem):
    """QGraphicsItem that visualizes a PriceBar object.

    There exists two kinds of standard PriceBar drawings:
        - Candle
        - Bar with open and close

    This draws the second one.  It is displayed as a bar with open
    and close ticks on the left and right side.  The bar is drawn with a
    green pen if the high is higher than or equal the low, and drawn as
    red otherwise.
    """
    
    def __init__(self, parent=None, scene=None):

        # Logger
        self.log = logging.getLogger("pricebarchart.PriceBarGraphicsItem")
        self.log.debug("Entered __init__().")

        super().__init__(parent, scene)

        # Pen width for PriceBars.
        self.penWidth = \
            PriceBarChartSettings.defaultPriceBarGraphicsItemPenWidth

        # Width of the left extension drawn that represents the open price.
        self.leftExtensionWidth = \
            PriceBarChartSettings.\
                defaultPriceBarGraphicsItemLeftExtensionWidth 

        # Width of the right extension drawn that represents the close price.
        self.rightExtensionWidth = \
            PriceBarChartSettings.\
                defaultPriceBarGraphicsItemRightExtensionWidth 


        # Internally stored PriceBar.
        self.priceBar = None

        # Pen which is used to do the painting.
        self.pen = QPen()
        self.pen.setColor(QColor(Qt.black))
        self.pen.setWidthF(self.penWidth)

        # Color setting for a PriceBar that has a higher close than open.
        self.higherPriceBarColor = \
            SettingsKeys.higherPriceBarColorSettingsDefValue

        # Color setting for a PriceBar that has a lower close than open.
        self.lowerPriceBarColor = \
            SettingsKeys.lowerPriceBarColorSettingsDefValue

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()


    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        # priceBarGraphicsItemPenWidth (float).
        self.penWidth = priceBarChartSettings.priceBarGraphicsItemPenWidth

        # priceBarGraphicsItemLeftExtensionWidth (float).
        self.leftExtensionWidth = \
            priceBarChartSettings.priceBarGraphicsItemLeftExtensionWidth

        # priceBarGraphicsItemRightExtensionWidth (float).
        self.rightExtensionWidth = \
            priceBarChartSettings.priceBarGraphicsItemRightExtensionWidth


        # Update the pen.
        self.pen.setWidthF(self.penWidth)

        # Schedule an update.
        self.prepareGeometryChange()


    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        settings = QSettings()

        # higherPriceBarColor
        key = SettingsKeys.higherPriceBarColorSettingsKey
        defaultValue = \
            SettingsKeys.higherPriceBarColorSettingsDefValue
        self.higherPriceBarColor = \
            settings.value(key, defaultValue, type=QColor)

        # lowerPriceBarColor
        key = SettingsKeys.lowerPriceBarColorSettingsKey
        defaultValue = \
            SettingsKeys.lowerPriceBarColorSettingsDefValue
        self.lowerPriceBarColor = \
            settings.value(key, defaultValue, type=QColor)


    def setPriceBar(self, priceBar):
        """Sets the internally used priceBar.  
        This has an effect on the color of the pricebar.
        """

        self.log.debug("Entered setPriceBar().  priceBar={}".\
                       format(priceBar.toString()))

        self.priceBar = priceBar

        # Set if it is a green or red pricebar.
        if self.priceBar != None:
            if self.priceBar.open <= self.priceBar.close:
                self.setPriceBarColor(self.higherPriceBarColor)
            else:
                self.setPriceBarColor(self.lowerPriceBarColor)
        else:
            # PriceBar is None.  Just use a black bar.
            self.setPriceBarColor(Qt.black)

        # Schedule an update to redraw the QGraphicsItem.
        self.prepareGeometryChange()

        self.log.debug("Leaving setPriceBar().")

    def getPriceBar(self):
        """Returns the internally stored PriceBar.
        If no PriceBar was previously stored in
        this PriceBarGraphicsItem, then None is returned.
        """

        return self.priceBar
    
    def setPriceBarColor(self, color):
        """Sets the color of the price bar."""

        self.log.debug("Entered setPriceBarColor().")

        if self.pen.color() != color:
            self.log.debug("Updating pen color.")
            self.pen.setColor(color)
            self.update()

        self.log.debug("Leaving setPriceBarColor().")

    def getPriceBarOpenScenePoint(self):
        """Returns the scene coordinates of the open point of this
        PriceBar.

        Returns: QPointF in scene coordinates of where the open of this
        pricebar is.
        """

        openPrice = 0.0
        high = 0.0
        low = 0.0

        if self.priceBar != None:
            openPrice = self.priceBar.open
            high = self.priceBar.high
            low = self.priceBar.low

        priceMidpoint = (high + low) * 0.5

        x = 0.0
        yOpen = -1.0 * (openPrice - priceMidpoint)
        yHigh = -1.0 * (high - priceMidpoint)
        yLow = -1.0 * (low - priceMidpoint)

        # Return value.
        rv = self.mapToScene(QPointF(x, yOpen))

        return rv


    def getPriceBarHighScenePoint(self):
        """Returns the scene coordinates of the high point of this
        PriceBar.

        Returns: QPointF in scene coordinates of where the high of this
        pricebar is.
        """

        high = 0.0
        low = 0.0

        if self.priceBar != None:
            high = self.priceBar.high
            low = self.priceBar.low

        priceMidpoint = (high + low) * 0.5

        x = 0.0
        yHigh = -1.0 * (high - priceMidpoint)
        yLow = -1.0 * (low - priceMidpoint)

        # Return value.
        rv = self.mapToScene(QPointF(x, yHigh))

        return rv


    def getPriceBarLowScenePoint(self):
        """Returns the scene coordinates of the low point of this
        PriceBar.

        Returns: QPointF in scene coordinates of where the high of this
        pricebar is.
        """

        high = 0.0
        low = 0.0

        if self.priceBar != None:
            high = self.priceBar.high
            low = self.priceBar.low

        priceMidpoint = (high + low) * 0.5

        x = 0.0
        yHigh = -1.0 * (high - priceMidpoint)
        yLow = -1.0 * (low - priceMidpoint)

        # Return value.
        rv = self.mapToScene(QPointF(x, yLow))

        return rv

    def getPriceBarCloseScenePoint(self):
        """Returns the scene coordinates of the close point of this
        PriceBar.

        Returns: QPointF in scene coordinates of where the close of this
        pricebar is.
        """

        close = 0.0
        high = 0.0
        low = 0.0

        if self.priceBar != None:
            close = self.priceBar.close
            high = self.priceBar.high
            low = self.priceBar.low

        priceMidpoint = (high + low) * 0.5

        x = 0.0
        yClose = -1.0 * (close - priceMidpoint)
        yHigh = -1.0 * (high - priceMidpoint)
        yLow = -1.0 * (low - priceMidpoint)

        # Return value.
        rv = self.mapToScene(QPointF(x, yClose))

        return rv


    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinates (0, 0) is the center of the widget.  
        # The QRectF returned should be related to this point as the
        # center.

        halfPenWidth = self.penWidth * 0.5

        openPrice = 0.0
        highPrice = 0.0
        lowPrice = 0.0
        closePrice = 0.0

        if self.priceBar != None:
            openPrice = self.priceBar.open
            highPrice = self.priceBar.high
            lowPrice = self.priceBar.low
            closePrice = self.priceBar.close

        # For X we have:
        #     leftExtensionWidth units for the left extension (open price)
        #     rightExtensionWidth units for the right extension (close price)
        #     halfPenWidth on the left side
        #     halfPenWidth on the right side

        # For Y we have:
        #     halfPenWidth for the bottom side.
        #     priceRange units
        #     halfPenWidth for the top side

        priceRange = abs(highPrice - lowPrice)

        x = -1.0 * (self.leftExtensionWidth + halfPenWidth)
        y = -1.0 * ((priceRange * 0.5) + halfPenWidth)

        height = halfPenWidth + priceRange + halfPenWidth

        width = \
                halfPenWidth + \
                self.leftExtensionWidth + \
                self.rightExtensionWidth + \
                halfPenWidth

        return QRectF(x, y, width, height)

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.pen is set
        to what we want for the drawing style.
        """

        if painter.pen() != self.pen:
            painter.setPen(self.pen)

        openPrice = 0.0
        highPrice = 0.0
        lowPrice = 0.0
        closePrice = 0.0

        if self.priceBar != None:
            openPrice = self.priceBar.open
            highPrice = self.priceBar.high
            lowPrice = self.priceBar.low
            closePrice = self.priceBar.close

        priceRange = abs(highPrice - lowPrice)
        priceMidpoint = (highPrice + lowPrice) * 0.5

        halfPriceRange = priceRange * 0.5

        # Draw the stem.
        x1 = 0.0
        y1 = 1.0 * halfPriceRange
        x2 = 0.0
        y2 = -1.0 * halfPriceRange
        painter.drawLine(QLineF(x1, y1, x2, y2))

        # Draw the left extension (open price).
        x1 = 0.0
        y1 = -1.0 * (openPrice - priceMidpoint)
        x2 = -1.0 * self.leftExtensionWidth
        y2 = y1
        painter.drawLine(QLineF(x1, y1, x2, y2))

        # Draw the right extension (close price).
        x1 = 0.0
        y1 = -1.0 * (closePrice - priceMidpoint)
        x2 = 1.0 * self.rightExtensionWidth
        y2 = y1
        painter.drawLine(QLineF(x1, y1, x2, y2))

        # Draw the bounding rect if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.pen.widthF() * 0.5;
            
            penWidth = 0.0

            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)

            boundingRect = self.boundingRect()
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(boundingRect)
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(boundingRect)

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PriceBarGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        PriceBarGraphicsItem to handle the desired functionality.

        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        # Set the menu title.
        if self.priceBar != None:
            datetimeObj = self.priceBar.timestamp
            timestampStr = Ephemeris.datetimeToDayStr(datetimeObj)
            menu.setTitle("PriceBar_" + timestampStr)
        else:
            menu.setTitle("PriceBar_" + "Unknown")
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        setAstro1Action = QAction("Set timestamp on Astro Chart &1", parent)
        setAstro2Action = QAction("Set timestamp on Astro Chart &2", parent)
        setAstro3Action = QAction("Set timestamp on Astro Chart &3", parent)
        openJHoraAction = QAction("Open JHor&a with timestamp", parent)
        openAstrologAction = QAction("Open As&trolog with timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setAstro1Action.triggered.\
            connect(self._handleSetAstro1Action)
        setAstro2Action.triggered.\
            connect(self._handleSetAstro2Action)
        setAstro3Action.triggered.\
            connect(self._handleSetAstro3Action)
        openJHoraAction.triggered.\
            connect(self._handleOpenJHoraAction)
        openAstrologAction.triggered.\
            connect(self._handleOpenAstrologAction)
                    
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(False)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setAstro1Action.setEnabled(True)
        setAstro2Action.setEnabled(True)
        setAstro3Action.setEnabled(True)
        openJHoraAction.setEnabled(True)
        openAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setAstro1Action)
        menu.addAction(setAstro2Action)
        menu.addAction(setAstro3Action)
        menu.addAction(openJHoraAction)
        menu.addAction(openAstrologAction)
        
        return menu

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""

        scene = self.scene()
        if scene != None:
            scene.removeItem(self)
            scene.priceBarChartChanged.emit()

    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem pricebar.
        """

        pb = self.getPriceBar()
        
        dialog = PriceBarEditDialog(priceBar=pb, readOnly=True)

        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem pricebar.
        """

        pb = self.getPriceBar()
        
        dialog = PriceBarEditDialog(priceBar=pb, readOnly=False)

        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # Set the item with the new values.

            self.setPriceBar(dialog.getPriceBar())

            # X location based on the timestamp.
            x = self.scene().datetimeToSceneXPos(self.priceBar.timestamp)

            # Y location based on the mid price (average of high and low).
            y = self.scene().priceToSceneYPos(self.priceBar.midPrice())

            # Set the position, in parent coordinates.
            self.setPos(QPointF(x, y))

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of this PriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart1(self.scenePos().x())
        
    def _handleSetAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of this PriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart2(self.scenePos().x())
        
    def _handleSetAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of this PriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart3(self.scenePos().x())

    def _handleOpenJHoraAction(self):
        """Causes the timestamp of this PriceBarGraphicsItem to be
        opened in JHora.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().openJHora(self.scenePos().x())
        
    def _handleOpenAstrologAction(self):
        """Causes the timestamp of this PriceBarGraphicsItem to be
        opened in Astrolog.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().openAstrolog(self.scenePos().x())
        

class LookbackMultiplePriceBarGraphicsItem(QGraphicsItem):
    """QGraphicsItem that visualizes a LookbackMultiplePriceBar object.

    There exists two kinds of standard LookbackMultiplePriceBar drawings:
      - Candle
      - Bar with open and close

    This draws the second one.  It is displayed as a bar with open and
    close ticks on the left and right side.  The bar is drawn in the
    color that is specified in the underlying LookbackMultiplePriceBar's
    LookbackMultiple color.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger("pricebarchart.LookbackMultiplePriceBarGraphicsItem")
        self.log.debug("Entered __init__().")

        # Pen width for LookbackMultiplePriceBars.
        self.penWidth = \
            PriceBarChartSettings.\
            defaultLookbackMultiplePriceBarGraphicsItemPenWidth

        # Width of the left extension drawn that represents the open price.
        self.leftExtensionWidth = \
            PriceBarChartSettings.\
            defaultLookbackMultiplePriceBarGraphicsItemLeftExtensionWidth 

        # Width of the right extension drawn that represents the close price.
        self.rightExtensionWidth = \
            PriceBarChartSettings.\
            defaultLookbackMultiplePriceBarGraphicsItemRightExtensionWidth 


        # Internally stored LookbackMultiplePriceBar.
        self.lookbackMultiplePriceBar = None

        # Pen which is used to do the painting.
        self.pen = QPen()
        self.pen.setColor(QColor(Qt.black))
        self.pen.setWidthF(self.penWidth)

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()

    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        LookbackMultiplePriceBarGraphicsItem from the given 
        PriceBarChartSettings object.
        """

        # lookbackMultiplePriceBarGraphicsItemPenWidth (float).
        self.penWidth = \
            priceBarChartSettings.\
            lookbackMultiplePriceBarGraphicsItemPenWidth

        # lookbackMultiplePriceBarGraphicsItemLeftExtensionWidth (float).
        self.leftExtensionWidth = \
            priceBarChartSettings.\
            lookbackMultiplePriceBarGraphicsItemLeftExtensionWidth

        # lookbackMultiplePriceBarGraphicsItemRightExtensionWidth (float).
        self.rightExtensionWidth = \
            priceBarChartSettings.\
            lookbackMultiplePriceBarGraphicsItemRightExtensionWidth


        # Update the pen.
        self.pen.setWidthF(self.penWidth)

        # Schedule an update.
        self.prepareGeometryChange()


    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        pass
    
    def setLookbackMultiplePriceBar(self, lookbackMultiplePriceBar):
        """Sets the internally used LookbackMultiplePriceBar.  
        """

        self.log.debug("Entered setLookbackMultiplePriceBar().  " + \
                       "lookbackMultiplePriceBar={}".\
                       format(lookbackMultiplePriceBar.toString()))

        self.lookbackMultiplePriceBar = lookbackMultiplePriceBar

        # Set the color of the LookbackMultiplePriceBarGraphicsItem.
        color = self.lookbackMultiplePriceBar.lookbackMultiple.getColor()
        self.setLookbackMultiplePriceBarColor(color)

        # Schedule an update to redraw the QGraphicsItem.
        self.prepareGeometryChange()

        self.log.debug("Leaving setLookbackMultiplePriceBar().")

    def getLookbackMultiplePriceBar(self):
        """Returns the internally stored LookbackMultiplePriceBar.
        If no LookbackMultiplePriceBar was previously stored in
        this LookbackMultiplePriceBarGraphicsItem, then None is returned.
        """

        return self.lookbackMultiplePriceBar
    
    def setLookbackMultiplePriceBarColor(self, color):
        """Sets the color of the price bar."""

        self.log.debug("Entered setLookbackMultiplePriceBarColor().")

        if self.pen.color() != color:
            self.log.debug("Updating pen color.")
            self.pen.setColor(color)
            self.update()

        self.log.debug("Leaving setLookbackMultiplePriceBarColor().")

    def getLookbackMultiplePriceBarOpenScenePoint(self):
        """Returns the scene coordinates of the open point of this
        LookbackMultiplePriceBar.

        Returns: QPointF in scene coordinates of where the open of this
        pricebar is.
        """

        openPrice = 0.0
        high = 0.0
        low = 0.0

        if self.lookbackMultiplePriceBar != None:
            openPrice = self.lookbackMultiplePriceBar.open
            high = self.lookbackMultiplePriceBar.high
            low = self.lookbackMultiplePriceBar.low

        priceMidpoint = (high + low) * 0.5

        x = 0.0
        yOpen = -1.0 * (openPrice - priceMidpoint)
        yHigh = -1.0 * (high - priceMidpoint)
        yLow = -1.0 * (low - priceMidpoint)

        # Return value.
        rv = self.mapToScene(QPointF(x, yOpen))

        return rv


    def getLookbackMultiplePriceBarHighScenePoint(self):
        """Returns the scene coordinates of the high point of this
        LookbackMultiplePriceBar.

        Returns: QPointF in scene coordinates of where the high of this
        pricebar is.
        """

        high = 0.0
        low = 0.0

        if self.lookbackMultiplePriceBar != None:
            high = self.lookbackMultiplePriceBar.high
            low = self.lookbackMultiplePriceBar.low

        priceMidpoint = (high + low) * 0.5

        x = 0.0
        yHigh = -1.0 * (high - priceMidpoint)
        yLow = -1.0 * (low - priceMidpoint)

        # Return value.
        rv = self.mapToScene(QPointF(x, yHigh))

        return rv


    def getLookbackMultiplePriceBarLowScenePoint(self):
        """Returns the scene coordinates of the low point of this
        LookbackMultiplePriceBar.

        Returns: QPointF in scene coordinates of where the high of this
        pricebar is.
        """

        high = 0.0
        low = 0.0

        if self.lookbackMultiplePriceBar != None:
            high = self.lookbackMultiplePriceBar.high
            low = self.lookbackMultiplePriceBar.low

        priceMidpoint = (high + low) * 0.5

        x = 0.0
        yHigh = -1.0 * (high - priceMidpoint)
        yLow = -1.0 * (low - priceMidpoint)

        # Return value.
        rv = self.mapToScene(QPointF(x, yLow))

        return rv

    def getLookbackMultiplePriceBarCloseScenePoint(self):
        """Returns the scene coordinates of the close point of this
        LookbackMultiplePriceBar.

        Returns: QPointF in scene coordinates of where the close of this
        pricebar is.
        """

        close = 0.0
        high = 0.0
        low = 0.0

        if self.lookbackMultiplePriceBar != None:
            close = self.lookbackMultiplePriceBar.close
            high = self.lookbackMultiplePriceBar.high
            low = self.lookbackMultiplePriceBar.low

        priceMidpoint = (high + low) * 0.5

        x = 0.0
        yClose = -1.0 * (close - priceMidpoint)
        yHigh = -1.0 * (high - priceMidpoint)
        yLow = -1.0 * (low - priceMidpoint)

        # Return value.
        rv = self.mapToScene(QPointF(x, yClose))

        return rv


    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinates (0, 0) is the center of the widget.  
        # The QRectF returned should be related to this point as the
        # center.

        halfPenWidth = self.penWidth * 0.5

        openPrice = 0.0
        highPrice = 0.0
        lowPrice = 0.0
        closePrice = 0.0

        if self.lookbackMultiplePriceBar != None:
            openPrice = self.lookbackMultiplePriceBar.open
            highPrice = self.lookbackMultiplePriceBar.high
            lowPrice = self.lookbackMultiplePriceBar.low
            closePrice = self.lookbackMultiplePriceBar.close

        # For X we have:
        #     leftExtensionWidth units for the left extension (open price)
        #     rightExtensionWidth units for the right extension (close price)
        #     halfPenWidth on the left side
        #     halfPenWidth on the right side

        # For Y we have:
        #     halfPenWidth for the bottom side.
        #     priceRange units
        #     halfPenWidth for the top side

        priceRange = abs(highPrice - lowPrice)

        x = -1.0 * (self.leftExtensionWidth + halfPenWidth)
        y = -1.0 * ((priceRange * 0.5) + halfPenWidth)

        height = halfPenWidth + priceRange + halfPenWidth

        width = \
                halfPenWidth + \
                self.leftExtensionWidth + \
                self.rightExtensionWidth + \
                halfPenWidth

        return QRectF(x, y, width, height)

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.pen is set
        to what we want for the drawing style.
        """

        if painter.pen() != self.pen:
            painter.setPen(self.pen)

        openPrice = 0.0
        highPrice = 0.0
        lowPrice = 0.0
        closePrice = 0.0

        if self.lookbackMultiplePriceBar != None:
            openPrice = self.lookbackMultiplePriceBar.open
            highPrice = self.lookbackMultiplePriceBar.high
            lowPrice = self.lookbackMultiplePriceBar.low
            closePrice = self.lookbackMultiplePriceBar.close

        priceRange = abs(highPrice - lowPrice)
        priceMidpoint = (highPrice + lowPrice) * 0.5

        halfPriceRange = priceRange * 0.5

        # Draw the stem.
        x1 = 0.0
        y1 = 1.0 * halfPriceRange
        x2 = 0.0
        y2 = -1.0 * halfPriceRange
        painter.drawLine(QLineF(x1, y1, x2, y2))

        # Draw the left extension (open price).
        x1 = 0.0
        y1 = -1.0 * (openPrice - priceMidpoint)
        x2 = -1.0 * self.leftExtensionWidth
        y2 = y1
        painter.drawLine(QLineF(x1, y1, x2, y2))

        # Draw the right extension (close price).
        x1 = 0.0
        y1 = -1.0 * (closePrice - priceMidpoint)
        x2 = 1.0 * self.rightExtensionWidth
        y2 = y1
        painter.drawLine(QLineF(x1, y1, x2, y2))

        # Draw the bounding rect if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.pen.widthF() * 0.5;
            
            penWidth = 0.0

            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)

            boundingRect = self.boundingRect()
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(boundingRect)
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(boundingRect)

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this LookbackMultiplePriceBarGraphicsItem.
        Actions that are triggered from this menu run various methods in
        the LookbackMultiplePriceBarGraphicsItem to handle the desired
        functionality.

        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
        readonly actions.
        """

        # Set the menu title.
        if self.lookbackMultiplePriceBar != None:
            datetimeObj = self.lookbackMultiplePriceBar.timestamp
            timestampStr = Ephemeris.datetimeToDayStr(datetimeObj)
            menu.setTitle("LookbackMultiplePriceBar_" + timestampStr)
        else:
            menu.setTitle("LookbackMultiplePriceBar_" + "Unknown")
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        setAstro1Action = QAction("Set timestamp on Astro Chart &1", parent)
        setAstro2Action = QAction("Set timestamp on Astro Chart &2", parent)
        setAstro3Action = QAction("Set timestamp on Astro Chart &3", parent)
        openJHoraAction = QAction("Open JHor&a with timestamp", parent)
        openAstrologAction = QAction("Open As&trolog with timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setAstro1Action.triggered.\
            connect(self._handleSetAstro1Action)
        setAstro2Action.triggered.\
            connect(self._handleSetAstro2Action)
        setAstro3Action.triggered.\
            connect(self._handleSetAstro3Action)
        openJHoraAction.triggered.\
            connect(self._handleOpenJHoraAction)
        openAstrologAction.triggered.\
            connect(self._handleOpenAstrologAction)
                    
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(False)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setAstro1Action.setEnabled(True)
        setAstro2Action.setEnabled(True)
        setAstro3Action.setEnabled(True)
        openJHoraAction.setEnabled(True)
        openAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setAstro1Action)
        menu.addAction(setAstro2Action)
        menu.addAction(setAstro3Action)
        menu.addAction(openJHoraAction)
        menu.addAction(openAstrologAction)
        
        return menu

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""

        scene = self.scene()
        if scene != None:
            scene.removeItem(self)
            scene.priceBarChartChanged.emit()

    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        lmpb = self.getLookbackMultiplePriceBar()
        
        dialog = LookbackMultiplePriceBarEditDialog(\
            lookbackMultiplePriceBar=lmpb, 
            readOnly=True)

        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        lmpb = self.getLookbackMultiplePriceBar()
        
        dialog = LookbackMultiplePriceBarEditDialog(\
            lookbackMultiplePriceBar=lmpb, 
            readOnly=False)

        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # Set the item with the new values.

            self.setLookbackMultiplePriceBar(\
                dialog.getLookbackMultiplePriceBar())

            # X location based on the timestamp.
            x = self.scene().datetimeToSceneXPos(\
                self.lookbackMultiplePriceBar.timestamp)

            # Y location based on the mid price (average of high and low).
            y = self.scene().priceToSceneYPos(\
                self.lookbackMultiplePriceBar.midPrice())

            # Set the position, in parent coordinates.
            self.setPos(QPointF(x, y))

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()
            
            # Emit that the LookbackMultiplePriceBarChart has changed so that
            # the dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of this LookbackMultiplePriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart1(self.scenePos().x())
        
    def _handleSetAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of this LookbackMultiplePriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart2(self.scenePos().x())
        
    def _handleSetAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of this LookbackMultiplePriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart3(self.scenePos().x())

    def _handleOpenJHoraAction(self):
        """Causes the timestamp of this
        LookbackMultiplePriceBarGraphicsItem to be opened in JHora.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().openJHora(self.scenePos().x())
        
    def _handleOpenAstrologAction(self):
        """Causes the timestamp of this
        LookbackMultiplePriceBarGraphicsItem to be opened in
        Astrolog.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().openAstrolog(self.scenePos().x())
        


class PriceBarChartArtifactGraphicsItem(QGraphicsItem):
    """QGraphicsItem that has members to indicate and set the
    readOnly mode.
    """

    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)
        
        # Logger
        self.log = \
            logging.getLogger("pricebarchart.PriceBarChartArtifactGraphicsItem")
        
        self.readOnlyFlag = True
        self.artifact = None

    def setReadOnlyFlag(self, flag):
        self.readOnlyFlag = flag

    def getReadOnlyFlag(self):
        return self.readOnlyFlag

    def setArtifact(self, artifact):
        """Virtual function that is meant to be overwritten by a child class to
        implement the custom functionality of loading the internals of the
        PriceBarChart GraphicsItem, so that it may be displayed in the chart.

        Arguments:
        artifact - PriceBarChartArtifact object to store.
        """

        self.log.debug("Entered " + \
                       "PriceBarChartArtifactGraphicsItem.setArtifact()")

        self.artifact = artifact
        
        self.log.debug("Exiting " + \
                       "PriceBarChartArtifactGraphicsItem.setArtifact()")

    def getArtifact(self):
        """Returns the PriceBarChartArtifact associated with this
        PriceBarChartArtifactGraphicsItem.
        """

        self.log.debug("Entered " + \
                       "PriceBarChartArtifactGraphicsItem.getArtifact()")
        
        if self.artifact == None:
            raise TypeError("Expected artifact to be not None.")

        self.log.debug("Exiting " + \
                       "PriceBarChartArtifactGraphicsItem.getArtifact()")
        
        return self.artifact

    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        If the item is on the scene and the internal artifact has
        tags, then this function causes that info to be outputted on
        the status bar.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug(\
            "Entered PriceBarChartArtifactGraphicsItem.mousePressEvent()")
        
        # Pass on the mousePressEvent call.
        super().mousePressEvent(event)

        self.maybePrintTagsToStatusBar()
        
        self.log.debug(\
            "Exiting PriceBarChartArtifactGraphicsItem.mousePressEvent()")

    def maybePrintTagsToStatusBar(self):
        """If the item is on the scene and the internal artifact has
        tags, then this function causes that info to be outputted on
        the status bar.
        """
        
        scene = self.scene()

        if scene != None and self.artifact != None:
            
            # Only act if there are tags for this item artifact.
            tags = self.artifact.getTags()
            
            if len(tags) > 0:
                
                statusStr = "Tags: ["
                
                for tag in tags:
                    statusStr += tag + ", "
                    
                if statusStr.endswith(", "):
                    statusStr = statusStr[:-2]
                    
                statusStr += "]"
                
                scene.statusMessageUpdate.emit(statusStr)

        
class TextGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a PriceBarChartTextArtifact."""
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)
        
        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartTextArtifact()

        # Internal QGraphicsItem that holds the text of the bar count.
        # Initialize to blank and set at the end point.
        self.textItem = QGraphicsSimpleTextItem("", self)
        self.textItem.setPos(0.0, 0.0)

        # Set the font of the text.
        self.textItemFont = self.artifact.getFont()
        self.textItem.setFont(self.textItemFont)

        # Set the color of the text.
        self.color = self.artifact.getColor()
        
        # Set the pen color of the text.
        self.textItemPen = self.textItem.pen()
        self.textItemPen.setColor(self.artifact.getColor())
        self.textItem.setPen(self.textItemPen)

        # Set the brush color of the text.
        self.textItemBrush = self.textItem.brush()
        self.textItemBrush.setColor(self.artifact.getColor())
        self.textItem.setBrush(self.textItemBrush)

        # Apply some size scaling to the text.
        textTransform = QTransform()
        textTransform.scale(self.artifact.getTextXScaling(), \
                            self.artifact.getTextYScaling())

        # Apply the transform.
        self.textItem.setTransform(textTransform)

        # Apply the rotation angle to the text.
        self.textItem.setRotation(self.artifact.getTextRotationAngle())

    def setText(self, text):
        """Sets the text in this graphics item.

        Arguments:
        text - str value for the new text.
        """

        self.textItem.setText(text)
        
    def getText(self):
        """Returns the text in this graphics item as a str."""

        return self.textItem.text()
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartTextArtifact object's data
        into this QGraphicsTextItem.

        Arguments:
        artifact - PriceBarChartTextArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entered setArtifact()")

        if isinstance(artifact, PriceBarChartTextArtifact):
            self.artifact = artifact

            self.log.debug("Setting TextGraphicsItem with the " +
                           "following artifact: " + self.artifact.toString())
            self.log.debug("Font in artifact is: " +
                           self.artifact.getFont().toString())
                           
            # Extract and set the internals according to the info 
            # in self.artifact.
            self.setPos(self.artifact.getPos())
            
            # Internal QGraphicsItem that holds the text of the bar count.
            # Initialize to blank and set at the end point.
            self.textItem.setText(self.artifact.getText())

            # Set the font of the text.
            self.textItemFont = self.artifact.getFont()
            self.textItem.setFont(self.textItemFont)

            # Set the color of the text.
            self.color = self.artifact.getColor()
            
            # Set the pen color of the text.
            self.textItemPen = self.textItem.pen()
            self.textItemPen.setColor(self.color)
            self.textItem.setPen(self.textItemPen)

            # Set the brush color of the text.
            self.textItemBrush = self.textItem.brush()
            self.textItemBrush.setColor(self.color)
            self.textItem.setBrush(self.textItemBrush)

            # Apply some size scaling to the text.
            self.textTransform = QTransform()
            self.textTransform.scale(self.artifact.getTextXScaling(), \
                                     self.artifact.getTextYScaling())

            # Apply the transform.
            self.textItem.setTransform(self.textTransform)

            # Apply the rotation angle to the text.
            self.textItem.setRotation(self.artifact.getTextRotationAngle())
        
        else:
            raise TypeError("Expected artifact type: PriceBarChartTextArtifact")
    
        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartTextArtifact for this QGraphicsItem 
        so that it may be pickled.
        """

        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartTextArtifact to be 
        # current, then return it.
        self.artifact.setPos(self.pos())
        self.artifact.setText(self.textItem.text())
        self.artifact.setFont(self.textItemFont)
        self.artifact.setColor(self.color)
        self.artifact.setTextXScaling(self.textTransform.m11())
        self.artifact.setTextYScaling(self.textTransform.m22())
        self.artifact.setTextRotationAngle(self.textItem.rotation())
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        # Set values from the priceBarChartSettings into the internal
        # member variables.
        
        self.textItemFont = QFont()
        self.textItemFont.fromString(priceBarChartSettings.\
                                     textGraphicsItemDefaultFontDescription) 
        self.color = \
            priceBarChartSettings.textGraphicsItemDefaultColor
        
        self.textTransform = QTransform()
        self.textTransform.scale(priceBarChartSettings.\
                                 textGraphicsItemDefaultXScaling,
                                 priceBarChartSettings.\
                                 textGraphicsItemDefaultYScaling)

        # Update the internal text item.
        self.textItem.setFont(self.textItemFont)

        self.textItemPen = self.textItem.pen()
        self.textItemPen.setColor(self.color)
        self.textItem.setPen(self.textItemPen)

        self.textItemBrush = self.textItem.brush()
        self.textItemBrush.setColor(self.color)
        self.textItem.setBrush(self.textItemBrush)

        self.textItem.setTransform(self.textTransform)

        self.textItem.setRotation(priceBarChartSettings.\
                                  textGraphicsItemDefaultRotationAngle)
        
        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        pass
    
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Arguments:
        pos - QPointF holding the new position.
        """
        
        super().setPos(pos)
        
    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) is the location of the internal text item
        # in local coordinates.  The QRectF returned is relative to
        # this (0, 0) point.

        return self.shape().boundingRect()

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        return self.textItem.mapToParent(self.textItem.shape())

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.textItemPen is set
        to what we want for the drawing style.
        """

        if painter.pen() != self.textItemPen:
            painter.setPen(QPen(self.textItemPen))

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.textItemPen.widthF() * 0.5;
            
            penWidth = 0.0

            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            boundingRect = self.boundingRect()
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PriceBarChartArtifactGraphicsItem.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()
        
    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()

        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()

        self.log.debug("Inside _handleInfoAction(): artifact is: " +
                       artifact.toString())
        
        dialog = PriceBarChartTextArtifactEditDialog(artifact,
                                                     self.scene(),
                                                     readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartTextArtifactEditDialog(artifact,
                                                     self.scene(),
                                                     readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
        
class BarCountGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a PriceBar counter in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new BarCountGraphicsItem the position
    and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger("pricebarchart.BarCountGraphicsItem")
        self.log.debug("Entered __init__().")


        ############################################################
        # Set default values for preferences/settings.
        
        # Color of the bar count graphicsitems.
        self.barCountGraphicsItemColor = \
            SettingsKeys.barCountGraphicsItemColorSettingsDefValue

        # Color of the text that is associated with the bar count
        # graphicsitem.
        self.barCountGraphicsItemTextColor = \
            SettingsKeys.barCountGraphicsItemTextColorSettingsDefValue

        # Height of the vertical bar drawn.
        self.barCountGraphicsItemBarHeight = \
            PriceBarChartSettings.\
                defaultBarCountGraphicsItemBarHeight 
 
        # Font size of the text of the bar count.
        self.barCountFontSize = \
            PriceBarChartSettings.\
                defaultBarCountGraphicsItemFontSize 

        # X scaling of the text.
        self.barCountTextXScaling = \
            PriceBarChartSettings.\
                defaultBarCountGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.barCountTextYScaling = \
            PriceBarChartSettings.\
                defaultBarCountGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartBarCountArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.barCountPenWidth = 0.0
        self.barCountPen = QPen()
        self.barCountPen.setColor(self.barCountGraphicsItemColor)
        self.barCountPen.setWidthF(self.barCountPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Number of PriceBars between self.startPointF and self.endPointF.
        self.barCount = 0

        # Internal QGraphicsItem that holds the text of the bar count.
        # Initialize to blank and set at the end point.
        self.barCountText = QGraphicsSimpleTextItem("", self)
        self.barCountText.setPos(self.endPointF)

        # Set the font of the text.
        self.barCountTextFont = QFont()
        self.barCountTextFont.setPointSizeF(self.barCountFontSize)
        self.barCountText.setFont(self.barCountTextFont)

        # Set the pen color of the text.
        self.barCountTextPen = self.barCountText.pen()
        self.barCountTextPen.setColor(self.barCountGraphicsItemTextColor)
        self.barCountText.setPen(self.barCountTextPen)

        # Set the brush color of the text.
        self.barCountTextBrush = self.barCountText.brush()
        self.barCountTextBrush.setColor(self.barCountGraphicsItemTextColor)
        self.barCountText.setBrush(self.barCountTextBrush)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0

        # Apply some size scaling to the text.
        textTransform = QTransform()
        textTransform.scale(self.barCountTextXScaling, \
                            self.barCountTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        self.barCountText.setTransform(textTransform)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None
        
    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag

        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Height of the vertical bar drawn.
        self.barCountGraphicsItemBarHeight = \
            priceBarChartSettings.\
                barCountGraphicsItemBarHeight 
 
        # Font size of the text of the bar count.
        self.barCountFontSize = \
            priceBarChartSettings.\
                barCountGraphicsItemFontSize 

        # X scaling of the text.
        self.barCountTextXScaling = \
            priceBarChartSettings.\
                barCountGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.barCountTextYScaling = \
            priceBarChartSettings.\
                barCountGraphicsItemTextYScaling 

        # Set the font size of the text.
        self.log.debug("Setting font size to: {}".format(self.barCountFontSize))
        self.barCountTextFont = QFont()
        self.barCountTextFont.setPointSizeF(self.barCountFontSize)
        self.barCountText.setFont(self.barCountTextFont)

        # Apply some size scaling to the text.
        self.log.debug("Setting transform: (dx={}, dy={})".\
                       format(self.barCountTextXScaling,
                              self.barCountTextYScaling))
        textTransform = QTransform()
        textTransform.scale(self.barCountTextXScaling, \
                            self.barCountTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        self.barCountText.setTransform(textTransform)

        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        settings = QSettings()

        # barCountGraphicsItemColor
        key = SettingsKeys.barCountGraphicsItemColorSettingsKey
        defaultValue = \
            SettingsKeys.barCountGraphicsItemColorSettingsDefValue
        self.barCountGraphicsItemColor = \
            settings.value(key, defaultValue, type=QColor)

        # barCountGraphicsItemTextColor
        key = SettingsKeys.barCountGraphicsItemTextColorSettingsKey
        defaultValue = \
            SettingsKeys.barCountGraphicsItemTextColorSettingsDefValue
        self.barCountGraphicsItemTextColor = \
            settings.value(key, defaultValue, type=QColor)
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.startPointF.setX(self.startPointF.x())
        self.endPointF = self.endPointF + posDelta
        self.endPointF.setX(self.endPointF.x())

        if self.scene() != None:
            self.recalculateBarCount()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            self.log.debug("DEBUG: " + \
                           "getReadOnlyFlag() == True, so passing to super()")
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))

            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.  Do the move, but also set emit that the
                    # PriceBarChart has changed.
                    super().mouseMoveEvent(event)
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            self.refreshPosition()

            self.prepareGeometryChange()

            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            self.refreshPosition()

            self.prepareGeometryChange()

            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def setStartPointF(self, pointF):
        """Sets the starting point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        x = pointF.x()

        newValue = QPointF(x, self.endPointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)
            
            # Update the barCount label position.
            deltaX = self.endPointF.x() - self.startPointF.x()
            y = 0
            self.barCountText.setPos(QPointF(deltaX, y))

            if self.scene() != None:
                # Re-calculate the bar count.
                self.recalculateBarCount()
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        x = pointF.x()

        newValue = QPointF(x, self.startPointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            # Update the barCount label position.
            deltaX = self.endPointF.x() - self.startPointF.x()
            y = 0
            self.barCountText.setPos(QPointF(deltaX, y))

            if self.scene() != None:
                # Re-calculate the bar count.
                self.recalculateBarCount()
                self.prepareGeometryChange()

    def refreshPosition(self):
        # Update the barCount label position.  
        deltaX = self.endPointF.x() - self.startPointF.x()
        y = 0
        self.barCountText.setPos(QPointF(deltaX, y))
        
        self.recalculateBarCount()
        
        super().setPos(self.startPointF)


    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        if self.startPointF.x() > self.endPointF.x():
            self.log.debug("Normalization of BarCountGraphicsItem " +
                           "required.")
            
            # Swap the points.
            temp = self.startPointF
            self.startPointF = self.endPointF
            self.endPointF = temp

        self.refreshPosition()

    def recalculateBarCount(self):
        """Sets the internal variable holding the number of bars in the
        X space between:

        (self.startPointF, self.endPointF]

        In the event self.startPointF or self.endPointF conjoin the X
        value of a PriceBar, the count excludes the bar conjoining
        self.startPointF and includes the bar conjoining self.endPointF.
        If the X values for both points are the same, then the bar count
        is zero.

        Returns:
        int value for the number of bars between the two points.
        """

        scene = self.scene()

        if scene == None:
            self.barCount = 0
        else:
            # Get all the QGraphicsItems.
            graphicsItems = scene.items()

            # Reset the bar count.
            self.barCount = 0

            # Test for special case.
            if self.startPointF.x() == self.endPointF.x():
                self.barCount = 0
            else:
                # Go through the PriceBarGraphicsItems and count the ones in
                # between self.startPointF and self.endPointF.
                for item in graphicsItems:
                    if isinstance(item, PriceBarGraphicsItem):

                        x = item.getPriceBarHighScenePoint().x()

                        # Here we check for the bar being in between
                        # the self.startPointF and the self.endPointF.
                        # This handles the case when the start and end
                        # points are reversed also.
                        if ((self.startPointF.x() < self.endPointF.x()) and \
                            (self.startPointF.x() < x <= self.endPointF.x())):

                            self.barCount += 1

                        elif ((self.endPointF.x() < self.startPointF.x()) and \
                            (self.endPointF.x() < x <= self.startPointF.x())):
                            
                            self.barCount -= 1
                            

        # Update the text of the self.barCountText.
        self.barCountText.setText("{}".format(self.barCount))
        
        return self.barCount

    def setArtifact(self, artifact):
        """Loads a given PriceBarChartBarCountArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartBarCountArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartBarCountArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartBarCountArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        # Need to recalculate the bar count, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the bar count will be zero, since it
        # can't look up PriceBarGraphicsItems in the scene.
        self.recalculateBarCount()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartBarCountArtifact for this QGraphicsItem 
        so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartBarCountArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.

        # The QRectF returned is relative to this (0, 0) point.

        # Get the QRectF with just the lines.
        xDelta = self.endPointF.x() - self.startPointF.x()
        
        topLeft = \
            QPointF(0.0, -1.0 * (self.barCountGraphicsItemBarHeight * 0.5))
        
        bottomRight = \
            QPointF(xDelta, 1.0 * (self.barCountGraphicsItemBarHeight * 0.5))
        
        # Initalize to the above boundaries.  We will set them below.
        localHighY = topLeft.y()
        localLowY = bottomRight.y()
        if self.drawVerticalDottedLinesFlag or self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighestPriceBarY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()

                # Overwrite the high if it is larger.
                if localHighestPriceBarY > localHighY:
                    localHighY = localHighestPriceBarY

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowestPriceBarY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
            
                # Overwrite the low if it is smaller.
                if localLowestPriceBarY < localLowY:
                    localLowY = localLowestPriceBarY
                
        xValues = []
        xValues.append(topLeft.x())
        xValues.append(bottomRight.x())

        yValues = []
        yValues.append(topLeft.y())
        yValues.append(bottomRight.y())
        yValues.append(localHighY)
        yValues.append(localLowY)

        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.barCountPen is set
        to what we want for the drawing style.
        """

        if painter.pen() != self.barCountPen:
            painter.setPen(self.barCountPen)
        
        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (self.barCountGraphicsItemBarHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (self.barCountGraphicsItemBarHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        x1 = 0.0 + xDelta
        y1 = 1.0 * (self.barCountGraphicsItemBarHeight * 0.5)
        x2 = 0.0 + xDelta
        y2 = -1.0 * (self.barCountGraphicsItemBarHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle horizontal line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = 0.0
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled tick area if the
        # flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.barCountPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                # Vertical line at the beginning.
                localPosX = 0.0
                startPoint = QPointF(localPosX, largestY)
                endPoint = QPointF(localPosX, smallestY)
                        
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
            
                # Vertical line at the end.
                localPosX = 0.0 + xDelta
                startPoint = QPointF(localPosX, largestY)
                endPoint = QPointF(localPosX, smallestY)
                        
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
        # Draw the bounding rect if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.barCountPen.widthF() * 0.5;
            
            penWidth = 0.0

            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            boundingRect = self.boundingRect()
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(boundingRect)
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(boundingRect)

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this BarCountGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        BarCountGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartBarCountArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartBarCountArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the BarCountGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the BarCountGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the BarCountGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        BarCountGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        BarCountGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the BarCountGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the BarCountGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the BarCountGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        BarCountGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        BarCountGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
        
class TimeMeasurementGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a time measurement in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new TimeMeasurementGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger("pricebarchart.TimeMeasurementGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.
        
        # Height of the vertical bar drawn.
        self.timeMeasurementGraphicsItemBarHeight = \
            PriceBarChartSettings.\
                defaultTimeMeasurementGraphicsItemBarHeight 
 
        # X scaling of the text.
        self.timeMeasurementTextXScaling = \
            PriceBarChartSettings.\
                defaultTimeMeasurementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.timeMeasurementTextYScaling = \
            PriceBarChartSettings.\
                defaultTimeMeasurementGraphicsItemTextYScaling 

        # Font.
        self.timeMeasurementTextFont = QFont()
        self.timeMeasurementTextFont.fromString(\
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.timeMeasurementGraphicsItemTextColor = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemDefaultTextColor

        # Color of the item.
        self.timeMeasurementGraphicsItemColor = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemDefaultColor

        # TimeMeasurementGraphicsItem showBarsTextFlag (bool).
        self.showBarsTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowBarsTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtBarsTextFlag (bool).
        self.showSqrtBarsTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtBarsTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdBarsTextFlag (bool).
        self.showSqrdBarsTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdBarsTextFlag
    
        # TimeMeasurementGraphicsItem showHoursTextFlag (bool).
        self.showHoursTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowHoursTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtHoursTextFlag (bool).
        self.showSqrtHoursTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtHoursTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdHoursTextFlag (bool).
        self.showSqrdHoursTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdHoursTextFlag
    
        # TimeMeasurementGraphicsItem showDaysTextFlag (bool).
        self.showDaysTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowDaysTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtDaysTextFlag (bool).
        self.showSqrtDaysTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtDaysTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdDaysTextFlag (bool).
        self.showSqrdDaysTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdDaysTextFlag
    
        # TimeMeasurementGraphicsItem showWeeksTextFlag (bool).
        self.showWeeksTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowWeeksTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtWeeksTextFlag (bool).
        self.showSqrtWeeksTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtWeeksTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdWeeksTextFlag (bool).
        self.showSqrdWeeksTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdWeeksTextFlag
    
        # TimeMeasurementGraphicsItem showMonthsTextFlag (bool).
        self.showMonthsTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowMonthsTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtMonthsTextFlag (bool).
        self.showSqrtMonthsTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtMonthsTextFlag

        # TimeMeasurementGraphicsItem showSqrdMonthsTextFlag (bool).
        self.showSqrdMonthsTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdMonthsTextFlag

        # TimeMeasurementGraphicsItem showTimeRangeTextFlag (bool).
        self.showTimeRangeTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowTimeRangeTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtTimeRangeTextFlag (bool).
        self.showSqrtTimeRangeTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtTimeRangeTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdTimeRangeTextFlag (bool).
        self.showSqrdTimeRangeTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdTimeRangeTextFlag
    
        # TimeMeasurementGraphicsItem showScaledValueRangeTextFlag (bool).
        self.showScaledValueRangeTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowScaledValueRangeTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtScaledValueRangeTextFlag (bool).
        self.showSqrtScaledValueRangeTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtScaledValueRangeTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdScaledValueRangeTextFlag (bool).
        self.showSqrdScaledValueRangeTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdScaledValueRangeTextFlag

        # TimeMeasurementGraphicsItem showAyanaTextFlag (bool).
        self.showAyanaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowAyanaTextFlag

        # TimeMeasurementGraphicsItem showSqrtAyanaTextFlag (bool).
        self.showSqrtAyanaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtAyanaTextFlag

        # TimeMeasurementGraphicsItem showSqrdAyanaTextFlag (bool).
        self.showSqrdAyanaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdAyanaTextFlag

        # TimeMeasurementGraphicsItem showMuhurtaTextFlag (bool).
        self.showMuhurtaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowMuhurtaTextFlag

        # TimeMeasurementGraphicsItem showSqrtMuhurtaTextFlag (bool).
        self.showSqrtMuhurtaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtMuhurtaTextFlag

        # TimeMeasurementGraphicsItem showSqrdMuhurtaTextFlag (bool).
        self.showSqrdMuhurtaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdMuhurtaTextFlag

        # TimeMeasurementGraphicsItem showVaraTextFlag (bool).
        self.showVaraTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowVaraTextFlag

        # TimeMeasurementGraphicsItem showSqrtVaraTextFlag (bool).
        self.showSqrtVaraTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtVaraTextFlag

        # TimeMeasurementGraphicsItem showSqrdVaraTextFlag (bool).
        self.showSqrdVaraTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdVaraTextFlag

        # TimeMeasurementGraphicsItem showRtuTextFlag (bool).
        self.showRtuTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowRtuTextFlag

        # TimeMeasurementGraphicsItem showSqrtRtuTextFlag (bool).
        self.showSqrtRtuTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtRtuTextFlag

        # TimeMeasurementGraphicsItem showSqrdRtuTextFlag (bool).
        self.showSqrdRtuTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdRtuTextFlag

        # TimeMeasurementGraphicsItem showMasaTextFlag (bool).
        self.showMasaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowMasaTextFlag

        # TimeMeasurementGraphicsItem showSqrtMasaTextFlag (bool).
        self.showSqrtMasaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtMasaTextFlag

        # TimeMeasurementGraphicsItem showSqrdMasaTextFlag (bool).
        self.showSqrdMasaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdMasaTextFlag

        # TimeMeasurementGraphicsItem showPaksaTextFlag (bool).
        self.showPaksaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowPaksaTextFlag

        # TimeMeasurementGraphicsItem showSqrtPaksaTextFlag (bool).
        self.showSqrtPaksaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtPaksaTextFlag

        # TimeMeasurementGraphicsItem showSqrdPaksaTextFlag (bool).
        self.showSqrdPaksaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdPaksaTextFlag

        # TimeMeasurementGraphicsItem showSamaTextFlag (bool).
        self.showSamaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSamaTextFlag

        # TimeMeasurementGraphicsItem showSqrtSamaTextFlag (bool).
        self.showSqrtSamaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrtSamaTextFlag

        # TimeMeasurementGraphicsItem showSqrdSamaTextFlag (bool).
        self.showSqrdSamaTextFlag = \
            PriceBarChartSettings.\
            defaultTimeMeasurementGraphicsItemShowSqrdSamaTextFlag
        
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartTimeMeasurementArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.timeMeasurementPenWidth = 0.0
        self.timeMeasurementPen = QPen()
        self.timeMeasurementPen.setColor(self.timeMeasurementGraphicsItemColor)
        self.timeMeasurementPen.setWidthF(self.timeMeasurementPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Variables holding the time measurement values.
        self.numPriceBars = 0.0
        self.numSqrtPriceBars = 0.0
        self.numSqrdPriceBars = 0.0
        self.numHours = 0.0
        self.numSqrtHours = 0.0
        self.numSqrdHours = 0.0
        self.numDays = 0.0
        self.numSqrtDays = 0.0
        self.numSqrdDays = 0.0
        self.numWeeks = 0.0
        self.numSqrtWeeks = 0.0
        self.numSqrdWeeks = 0.0
        self.numMonths = 0.0
        self.numSqrtMonths = 0.0
        self.numSqrdMonths = 0.0
        self.numTimeRange = 0.0
        self.numSqrtTimeRange = 0.0
        self.numSqrdTimeRange = 0.0
        self.numScaledValueRange = 0.0
        self.numSqrtScaledValueRange = 0.0
        self.numSqrdScaledValueRange = 0.0
        self.numAyana = 0.0
        self.numSqrtAyana = 0.0
        self.numSqrdAyana = 0.0
        self.numMuhurta = 0.0
        self.numSqrtMuhurta = 0.0
        self.numSqrdMuhurta = 0.0
        self.numVara = 0.0
        self.numSqrtVara = 0.0
        self.numSqrdVara = 0.0
        self.numRtu = 0.0
        self.numSqrtRtu = 0.0
        self.numSqrdRtu = 0.0
        self.numMasa = 0.0
        self.numSqrtMasa = 0.0
        self.numSqrdMasa = 0.0
        self.numPaksa = 0.0
        self.numSqrtPaksa = 0.0
        self.numSqrdPaksa = 0.0
        self.numSama = 0.0
        self.numSqrtSama = 0.0
        self.numSqrdSama = 0.0
        
        # Internal QGraphicsItem that holds the text of the bar count.
        # Initialize to blank and set at the end point.
        self.textItem = QGraphicsSimpleTextItem("", self)
        self.textItem.setPos(self.endPointF)

        # Transform object applied to the text item.
        self.textTransform = QTransform()
        
        # Set the text item with the properties we want it to have.
        self.reApplyTextItemAttributes(self.textItem)
        
        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def reApplyTextItemAttributes(self, textItem):
        """Takes the given text item and reapplies the pen, brush,
        transform, etc. that should be set for the text item.
        """

        # Set properties of the text item.
        
        # Set the font of the text.
        textItem.setFont(self.timeMeasurementTextFont)
        
        # Set the pen color of the text.
        self.timeMeasurementTextPen = textItem.pen()
        self.timeMeasurementTextPen.\
            setColor(self.timeMeasurementGraphicsItemTextColor)
            
        textItem.setPen(self.timeMeasurementTextPen)

        # Set the brush color of the text.
        self.timeMeasurementTextBrush = textItem.brush()
        self.timeMeasurementTextBrush.\
            setColor(self.timeMeasurementGraphicsItemTextColor)
            
        textItem.setBrush(self.timeMeasurementTextBrush)

        # Apply some size scaling to the text.
        self.textTransform = QTransform()
        self.textTransform.scale(self.timeMeasurementTextXScaling, \
                            self.timeMeasurementTextYScaling)
        textItem.setTransform(self.textTransform)

        
    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag

        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Height of the vertical bar drawn.
        self.timeMeasurementGraphicsItemBarHeight = \
            priceBarChartSettings.\
                timeMeasurementGraphicsItemBarHeight 
 
        # X scaling of the text.
        self.timeMeasurementTextXScaling = \
            priceBarChartSettings.\
                timeMeasurementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.timeMeasurementTextYScaling = \
            priceBarChartSettings.\
                timeMeasurementGraphicsItemTextYScaling 

        # Font.
        self.timeMeasurementTextFont = QFont()
        self.timeMeasurementTextFont.fromString(\
            priceBarChartSettings.\
            timeMeasurementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.timeMeasurementGraphicsItemTextColor = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemDefaultTextColor

        # Color of the item.
        self.timeMeasurementGraphicsItemColor = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemDefaultColor

        # TimeMeasurementGraphicsItem showBarsTextFlag (bool).
        self.showBarsTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowBarsTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtBarsTextFlag (bool).
        self.showSqrtBarsTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtBarsTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdBarsTextFlag (bool).
        self.showSqrdBarsTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdBarsTextFlag
    
        # TimeMeasurementGraphicsItem showHoursTextFlag (bool).
        self.showHoursTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowHoursTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtHoursTextFlag (bool).
        self.showSqrtHoursTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtHoursTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdHoursTextFlag (bool).
        self.showSqrdHoursTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdHoursTextFlag
    
        # TimeMeasurementGraphicsItem showDaysTextFlag (bool).
        self.showDaysTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowDaysTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtDaysTextFlag (bool).
        self.showSqrtDaysTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtDaysTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdDaysTextFlag (bool).
        self.showSqrdDaysTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdDaysTextFlag
    
        # TimeMeasurementGraphicsItem showWeeksTextFlag (bool).
        self.showWeeksTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowWeeksTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtWeeksTextFlag (bool).
        self.showSqrtWeeksTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtWeeksTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdWeeksTextFlag (bool).
        self.showSqrdWeeksTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdWeeksTextFlag
    
        # TimeMeasurementGraphicsItem showMonthsTextFlag (bool).
        self.showMonthsTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowMonthsTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtMonthsTextFlag (bool).
        self.showSqrtMonthsTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtMonthsTextFlag

        # TimeMeasurementGraphicsItem showSqrdMonthsTextFlag (bool).
        self.showSqrdMonthsTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdMonthsTextFlag

        # TimeMeasurementGraphicsItem showTimeRangeTextFlag (bool).
        self.showTimeRangeTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowTimeRangeTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtTimeRangeTextFlag (bool).
        self.showSqrtTimeRangeTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtTimeRangeTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdTimeRangeTextFlag (bool).
        self.showSqrdTimeRangeTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdTimeRangeTextFlag
    
        # TimeMeasurementGraphicsItem showScaledValueRangeTextFlag (bool).
        self.showScaledValueRangeTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowScaledValueRangeTextFlag
    
        # TimeMeasurementGraphicsItem showSqrtScaledValueRangeTextFlag (bool).
        self.showSqrtScaledValueRangeTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtScaledValueRangeTextFlag
    
        # TimeMeasurementGraphicsItem showSqrdScaledValueRangeTextFlag (bool).
        self.showSqrdScaledValueRangeTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdScaledValueRangeTextFlag
    
        # TimeMeasurementGraphicsItem showAyanaTextFlag (bool).
        self.showAyanaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowAyanaTextFlag

        # TimeMeasurementGraphicsItem showSqrtAyanaTextFlag (bool).
        self.showSqrtAyanaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtAyanaTextFlag

        # TimeMeasurementGraphicsItem showSqrdAyanaTextFlag (bool).
        self.showSqrdAyanaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdAyanaTextFlag

        # TimeMeasurementGraphicsItem showMuhurtaTextFlag (bool).
        self.showMuhurtaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowMuhurtaTextFlag

        # TimeMeasurementGraphicsItem showSqrtMuhurtaTextFlag (bool).
        self.showSqrtMuhurtaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtMuhurtaTextFlag

        # TimeMeasurementGraphicsItem showSqrdMuhurtaTextFlag (bool).
        self.showSqrdMuhurtaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdMuhurtaTextFlag

        # TimeMeasurementGraphicsItem showVaraTextFlag (bool).
        self.showVaraTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowVaraTextFlag

        # TimeMeasurementGraphicsItem showSqrtVaraTextFlag (bool).
        self.showSqrtVaraTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtVaraTextFlag

        # TimeMeasurementGraphicsItem showSqrdVaraTextFlag (bool).
        self.showSqrdVaraTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdVaraTextFlag

        # TimeMeasurementGraphicsItem showRtuTextFlag (bool).
        self.showRtuTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowRtuTextFlag

        # TimeMeasurementGraphicsItem showSqrtRtuTextFlag (bool).
        self.showSqrtRtuTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtRtuTextFlag

        # TimeMeasurementGraphicsItem showSqrdRtuTextFlag (bool).
        self.showSqrdRtuTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdRtuTextFlag

        # TimeMeasurementGraphicsItem showMasaTextFlag (bool).
        self.showMasaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowMasaTextFlag

        # TimeMeasurementGraphicsItem showSqrtMasaTextFlag (bool).
        self.showSqrtMasaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtMasaTextFlag

        # TimeMeasurementGraphicsItem showSqrdMasaTextFlag (bool).
        self.showSqrdMasaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdMasaTextFlag

        # TimeMeasurementGraphicsItem showPaksaTextFlag (bool).
        self.showPaksaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowPaksaTextFlag

        # TimeMeasurementGraphicsItem showSqrtPaksaTextFlag (bool).
        self.showSqrtPaksaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtPaksaTextFlag

        # TimeMeasurementGraphicsItem showSqrdPaksaTextFlag (bool).
        self.showSqrdPaksaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdPaksaTextFlag

        # TimeMeasurementGraphicsItem showSamaTextFlag (bool).
        self.showSamaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSamaTextFlag

        # TimeMeasurementGraphicsItem showSqrtSamaTextFlag (bool).
        self.showSqrtSamaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrtSamaTextFlag

        # TimeMeasurementGraphicsItem showSqrdSamaTextFlag (bool).
        self.showSqrdSamaTextFlag = \
            priceBarChartSettings.\
            timeMeasurementGraphicsItemShowSqrdSamaTextFlag

        ####################################################################

        # Update the text item with the new settings.
        self.reApplyTextItemAttributes(self.textItem)

        # Update the time measurement calculations since scaling could
        # have changed.
        self.recalculateTimeMeasurement()
        
        # Update the timeMeasurement text item position.
        self._updateTextItemPositions()
        
        # Set the new color of the pen for drawing the bar.
        self.timeMeasurementPen.\
            setColor(self.timeMeasurementGraphicsItemColor)
        
        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculateTimeMeasurement()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)
            
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def _updateTextItemPositions(self):
        """Updates the location of the internal text items based on
        where the start and end points are.
        """
        
        # Update the timeMeasurement label position.
        
        # Changes in x and y.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()
        
        # Get bounding rectangle of text item.
        boundingRect = self.textItem.boundingRect()

        # Find largest text height and width.
        largestTextHeight = boundingRect.height()
        largestTextWidth = boundingRect.width()

        # Now replace the above with the scaled version of it. 
        largestTextHeight = largestTextHeight * self.textTransform.m22()
        largestTextWidth = largestTextWidth * self.textTransform.m11()

        self.log.debug("largestTextHeight = {}".format(largestTextHeight))
        self.log.debug("largestTextWidth = {}".format(largestTextWidth))
        
        # Get the x and y of the point to place the text, referenced
        # on the line from start point to end point, but offset by a
        # certain amount such that the largest text would be centered
        # on the line.
        midX = self.mapFromScene(\
            QPointF(self.startPointF.x() + (deltaX * 0.5), 0.0)).x()
        midY = self.mapFromScene(\
            QPointF(0.0, self.startPointF.y() + (deltaY * 0.5))).y()

        self.log.debug("midX={}, midY={}".format(midX, midY))
                       
        startX = midX
        startY = midY

        # Amount to mutiply to get a largest offset from startY.
        offsetY = largestTextHeight
        offsetX = (largestTextWidth / 2.0)
        
        x = startX - offsetX
        y = startY - offsetY
        
        self.textItem.setPos(QPointF(x, y))
                    
    def setStartPointF(self, pointF):
        """Sets the starting point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        x = pointF.x()

        newValue = QPointF(x, self.endPointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            # Update the timeMeasurement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the timemeasurement.
                self.recalculateTimeMeasurement()
                self.prepareGeometryChange()
                
    def setEndPointF(self, pointF):
        """Sets the ending point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        x = pointF.x()

        newValue = QPointF(x, self.startPointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            # Update the timeMeasurement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the timemeasurement.
                self.recalculateTimeMeasurement()
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        if self.startPointF.x() > self.endPointF.x():
            self.log.debug("Normalization of TimeMeasurementGraphicsItem " +
                           "required.")
            
            # Swap the points.
            temp = self.startPointF
            self.startPointF = self.endPointF
            self.endPointF = temp

            self.recalculateTimeMeasurement()
            
            # Update the timeMeasurement text item position.
            self._updateTextItemPositions()
            
            super().setPos(self.startPointF)
            

    def recalculateTimeMeasurement(self):
        """Sets the internal variables:
        
        self.numPriceBars
        self.numSqrtPriceBars
        self.numSqrdPriceBars
        self.numHours
        self.numSqrtHours
        self.numSqrdHours
        self.numDays
        self.numSqrtDays
        self.numSqrdDays
        self.numWeeks
        self.numSqrtWeeks
        self.numSqrdWeeks
        self.numMonths
        self.numSqrtMonths
        self.numSqrdMonths
        self.numTimeRange
        self.numSqrtTimeRange
        self.numSqrdTimeRange
        self.numScaledValueRange
        self.numSqrtScaledValueRange
        self.numSqrdScaledValueRange
        self.numAyana
        self.numSqrtAyana
        self.numSqrdAyana
        self.numMuhurta
        self.numSqrtMuhurta
        self.numSqrdMuhurta
        self.numVara
        self.numSqrtVara
        self.numSqrdVara
        self.numRtu
        self.numSqrtRtu
        self.numSqrdRtu
        self.numMasa
        self.numSqrtMasa
        self.numSqrdMasa
        self.numPaksa
        self.numSqrtPaksa
        self.numSqrdPaksa
        self.numSama
        self.numSqrtSama
        self.numSqrdSama
            
        to hold the amount of time between the start and end points.
        """

        scene = self.scene()

        # Reset the values.
        self.numPriceBars = 0.0
        self.numSqrtPriceBars = 0.0
        self.numSqrdPriceBars = 0.0
        self.numHours = 0.0
        self.numSqrtHours = 0.0
        self.numSqrdHours = 0.0
        self.numDays = 0.0
        self.numSqrtDays = 0.0
        self.numSqrdDays = 0.0
        self.numWeeks = 0.0
        self.numSqrtWeeks = 0.0
        self.numSqrdWeeks = 0.0
        self.numMonths = 0.0
        self.numSqrtMonths = 0.0
        self.numSqrdMonths = 0.0
        self.numTimeRange = 0.0
        self.numSqrtTimeRange = 0.0
        self.numSqrdTimeRange = 0.0
        self.numScaledValueRange = 0.0
        self.numSqrtScaledValueRange = 0.0
        self.numSqrdScaledValueRange = 0.0
        self.numAyana = 0.0
        self.numSqrtAyana = 0.0
        self.numSqrdAyana = 0.0
        self.numMuhurta = 0.0
        self.numSqrtMuhurta = 0.0
        self.numSqrdMuhurta = 0.0
        self.numVara = 0.0
        self.numSqrtVara = 0.0
        self.numSqrdVara = 0.0
        self.numRtu = 0.0
        self.numSqrtRtu = 0.0
        self.numSqrdRtu = 0.0
        self.numMasa = 0.0
        self.numSqrtMasa = 0.0
        self.numSqrdMasa = 0.0
        self.numPaksa = 0.0
        self.numSqrtPaksa = 0.0
        self.numSqrdPaksa = 0.0
        self.numSama = 0.0
        self.numSqrtSama = 0.0
        self.numSqrdSama = 0.0
        
        if scene != None:
            # Get all the QGraphicsItems.
            graphicsItems = scene.items()

            # Go through the PriceBarGraphicsItems and count the bars in
            # between self.startPointF and self.endPointF.
            for item in graphicsItems:
                if isinstance(item, PriceBarGraphicsItem):

                    x = item.getPriceBarHighScenePoint().x()

                    # Here we check for the bar being in between
                    # the self.startPointF and the self.endPointF.
                    # This handles the case when the start and end
                    # points are reversed also.
                    if (self.startPointF.x() < x <= self.endPointF.x()) or \
                       (self.endPointF.x() < x <= self.startPointF.x()):

                        self.numPriceBars += 1
        
            # Calculate the number of (calendar) days.
            startTimestamp = \
                scene.sceneXPosToDatetime(self.startPointF.x())
            
            timestampStr = Ephemeris.datetimeToDayStr(startTimestamp)
            self.log.debug("startTimestamp: " + timestampStr)
            
            endTimestamp = \
                scene.sceneXPosToDatetime(self.endPointF.x())
            
            timestampStr = Ephemeris.datetimeToDayStr(endTimestamp)
            self.log.debug("endTimestamp: " + timestampStr)
            
            timeDelta = endTimestamp - startTimestamp
            
            self.log.debug("timeDelta is: " + timeDelta.__str__())

            # Calculate number of days.
            self.numDays = timeDelta.days
            self.numDays += (timeDelta.seconds / 86400.0)

            # Calculate number of hours.
            self.numHours = self.numDays * 24.0
            
            # Calculate number of weeks.
            self.numWeeks = self.numDays / 7.0

            # Calculate number of months.
            daysInTropicalYear = 365.242199
            daysInMonth = daysInTropicalYear / 12.0
            self.numMonths = self.numDays / daysInMonth

            # Calculate the time range.  (In what units should we do
            # this?... for now we will just use the default.)
            self.numTimeRange = abs(self.endPointF.x() - self.startPointF.x())
            
            # Calculate the scaled value range.
            self.numScaledValueRange = \
                abs(scene.convertDatetimeToScaledValue(endTimestamp) -
                    scene.convertDatetimeToScaledValue(startTimestamp))
            
            # Calculate number of ayanas (6 months).
            # Ayana is half of a tropical year (solstice to solstice).
            daysInAyana = daysInTropicalYear / 2.0
            self.numAyana = self.numDays / daysInAyana

            # Calculate number of muhurtas (48 minutes).
            minutesInDay = 1440
            self.numMuhurta = (self.numDays * minutesInDay) / 48.0

            # Calculate number of varas (24-hour day).
            self.numVara = float(self.numDays)

            # Calculate number of rtu (season of 2 months).  Although
            # some authors say this is relative to sidereal zodiac, I
            # believe it's supposed to be relative to divisions of a
            # tropical year, so I will use that below.
            daysInRtu = daysInTropicalYear / 6.0
            self.numRtu = self.numDays / daysInRtu

            # Calculate number of masa (lunar synodic months).
            daysInLunarSynodicMonth = 29.530588853
            self.numMasa = self.numDays / daysInLunarSynodicMonth
            
            # Calculate number of paksa (fortnights).
            daysInPaksa = daysInLunarSynodicMonth / 2.0
            self.numPaksa = self.numDays / daysInPaksa

            # Calculate number of sama (solar year).
            self.numSama = self.numDays / daysInTropicalYear
            
            self.log.debug("self.numPriceBars={}".format(self.numPriceBars))
            self.log.debug("self.numHours={}".format(self.numHours))
            self.log.debug("self.numDays={}".format(self.numDays))
            self.log.debug("self.numWeeks={}".format(self.numWeeks))
            self.log.debug("self.numMonths={}".format(self.numMonths))
            self.log.debug("self.numTimeRange={}".format(self.numTimeRange))
            self.log.debug("self.numScaledValueRange={}".
                           format(self.numScaledValueRange))
            self.log.debug("self.numAyana={}".format(self.numAyana))
            self.log.debug("self.numMuhurta={}".format(self.numMuhurta))
            self.log.debug("self.numVara={}".format(self.numVara))
            self.log.debug("self.numRtu={}".format(self.numRtu))
            self.log.debug("self.numMasa={}".format(self.numMasa))
            self.log.debug("self.numPaksa={}".format(self.numPaksa))
            self.log.debug("self.numSama={}".format(self.numSama))

            self.numSqrtPriceBars = math.sqrt(abs(self.numPriceBars))
            self.numSqrtHours = math.sqrt(abs(self.numHours))
            self.numSqrtDays = math.sqrt(abs(self.numDays))
            self.numSqrtWeeks = math.sqrt(abs(self.numWeeks))
            self.numSqrtMonths = math.sqrt(abs(self.numMonths))
            self.numSqrtTimeRange = math.sqrt(abs(self.numTimeRange))
            self.numSqrtScaledValueRange = \
                math.sqrt(abs(self.numScaledValueRange))
            self.numSqrtAyana = math.sqrt(abs(self.numAyana))
            self.numSqrtMuhurta = math.sqrt(abs(self.numMuhurta))
            self.numSqrtVara = math.sqrt(abs(self.numVara))
            self.numSqrtRtu = math.sqrt(abs(self.numRtu))
            self.numSqrtMasa = math.sqrt(abs(self.numMasa))
            self.numSqrtPaksa = math.sqrt(abs(self.numPaksa))
            self.numSqrtSama = math.sqrt(abs(self.numSama))

            self.log.debug("self.numSqrtPriceBars={}".\
                           format(self.numSqrtPriceBars))
            self.log.debug("self.numSqrtHours={}".format(self.numSqrtHours))
            self.log.debug("self.numSqrtDays={}".format(self.numSqrtDays))
            self.log.debug("self.numSqrtWeeks={}".format(self.numSqrtWeeks))
            self.log.debug("self.numSqrtMonths={}".format(self.numSqrtMonths))
            self.log.debug("self.numSqrtTimeRange={}".\
                format(self.numSqrtTimeRange))
            self.log.debug("self.numSqrtScaledValueRange={}".\
                format(self.numSqrtScaledValueRange))
            self.log.debug("self.numSqrtAyana={}".format(self.numSqrtAyana))
            self.log.debug("self.numSqrtMuhurta={}".format(self.numSqrtMuhurta))
            self.log.debug("self.numSqrtVara={}".format(self.numSqrtVara))
            self.log.debug("self.numSqrtRtu={}".format(self.numSqrtRtu))
            self.log.debug("self.numSqrtMasa={}".format(self.numSqrtMasa))
            self.log.debug("self.numSqrtPaksa={}".format(self.numSqrtPaksa))
            self.log.debug("self.numSqrtSama={}".format(self.numSqrtSama))

            self.numSqrdPriceBars = math.pow(self.numPriceBars, 2.0)
            self.numSqrdHours = math.pow(self.numHours, 2.0)
            self.numSqrdDays = math.pow(self.numDays, 2.0)
            self.numSqrdWeeks = math.pow(self.numWeeks, 2.0)
            self.numSqrdMonths = math.pow(self.numMonths, 2.0)
            self.numSqrdTimeRange = math.pow(self.numTimeRange, 2.0)
            self.numSqrdScaledValueRange = \
                math.pow(self.numScaledValueRange, 2.0)
            self.numSqrdAyana = math.pow(self.numAyana, 2.0)
            self.numSqrdMuhurta = math.pow(self.numMuhurta, 2.0)
            self.numSqrdVara = math.pow(self.numVara, 2.0)
            self.numSqrdRtu = math.pow(self.numRtu, 2.0)
            self.numSqrdMasa = math.pow(self.numMasa, 2.0)
            self.numSqrdPaksa = math.pow(self.numPaksa, 2.0)
            self.numSqrdSama = math.pow(self.numSama, 2.0)
            
            self.log.debug("self.numSqrdPriceBars={}".\
                           format(self.numSqrdPriceBars))
            self.log.debug("self.numSqrdHours={}".format(self.numSqrdHours))
            self.log.debug("self.numSqrdDays={}".format(self.numSqrdDays))
            self.log.debug("self.numSqrdWeeks={}".format(self.numSqrdWeeks))
            self.log.debug("self.numSqrdMonths={}".format(self.numSqrdMonths))
            self.log.debug("self.numSqrdTimeRange={}".\
                format(self.numSqrdTimeRange))
            self.log.debug("self.numSqrdScaledValueRange={}".\
                format(self.numSqrdScaledValueRange))
            self.log.debug("self.numSqrdAyana={}".format(self.numSqrdAyana))
            self.log.debug("self.numSqrdMuhurta={}".format(self.numSqrdMuhurta))
            self.log.debug("self.numSqrdVara={}".format(self.numSqrdVara))
            self.log.debug("self.numSqrdRtu={}".format(self.numSqrdRtu))
            self.log.debug("self.numSqrdMasa={}".format(self.numSqrdMasa))
            self.log.debug("self.numSqrdPaksa={}".format(self.numSqrdPaksa))
            self.log.debug("self.numSqrdSama={}".format(self.numSqrdSama))

        # Update the text of the internal items.
        barsText = "{} B".format(self.numPriceBars)
        sqrtBarsText = "{:.2f} sqrt B".format(self.numSqrtPriceBars)
        sqrdBarsText = "{:.2f} sqrd B".format(self.numSqrdPriceBars)
        hoursText = "{:.2f} H".format(self.numHours)
        sqrtHoursText = "{:.2f} sqrt H".format(self.numSqrtHours)
        sqrdHoursText = "{:.2f} sqrd H".format(self.numSqrdHours)
        daysText = "{:.2f} CD".format(self.numDays)
        sqrtDaysText = "{:.2f} sqrt CD".format(self.numSqrtDays)
        sqrdDaysText = "{:.2f} sqrd CD".format(self.numSqrdDays)
        weeksText = "{:.2f} W".format(self.numWeeks)
        sqrtWeeksText = "{:.2f} sqrt W".format(self.numSqrtWeeks)
        sqrdWeeksText = "{:.2f} sqrd W".format(self.numSqrdWeeks)
        monthsText = "{:.2f} M".format(self.numMonths)
        sqrtMonthsText = "{:.2f} sqrt M".format(self.numSqrtMonths)
        sqrdMonthsText = "{:.2f} sqrd M".format(self.numSqrdMonths)
        timeRangeText = \
            "{:.4f} t_range".format(self.numTimeRange)
        sqrtTimeRangeText = \
            "{:.4f} sqrt(t_range)".format(self.numSqrtTimeRange)
        sqrdTimeRangeText = \
            "{:.4f} sqrd(t_range)".format(self.numSqrdTimeRange)
        scaledValueRangeText = \
            "{:.4f} u_range".format(self.numScaledValueRange)
        sqrtScaledValueRangeText = \
            "{:.4f} sqrt(u_range)".format(self.numSqrtScaledValueRange)
        sqrdScaledValueRangeText = \
            "{:.4f} sqrd(u_range)".format(self.numSqrdScaledValueRange)
        ayanaText = "{:.2f} ayana".format(self.numAyana)
        sqrtAyanaText = "{:.2f} sqrt ayana".format(self.numSqrtAyana)
        sqrdAyanaText = "{:.2f} sqrd ayana".format(self.numSqrdAyana)
        muhurtaText = "{:.2f} muhurta".format(self.numMuhurta)
        sqrtMuhurtaText = "{:.2f} sqrt muhurta".format(self.numSqrtMuhurta)
        sqrdMuhurtaText = "{:.2f} sqrd muhurta".format(self.numSqrdMuhurta)
        varaText = "{:.2f} vara".format(self.numVara)
        sqrtVaraText = "{:.2f} sqrt vara".format(self.numSqrtVara)
        sqrdVaraText = "{:.2f} sqrd vara".format(self.numSqrdVara)
        rtuText = "{:.2f} rtu".format(self.numRtu)
        sqrtRtuText = "{:.2f} sqrt rtu".format(self.numSqrtRtu)
        sqrdRtuText = "{:.2f} sqrd rtu".format(self.numSqrdRtu)
        masaText = "{:.2f} masa".format(self.numMasa)
        sqrtMasaText = "{:.2f} sqrt masa".format(self.numSqrtMasa)
        sqrdMasaText = "{:.2f} sqrd masa".format(self.numSqrdMasa)
        paksaText = "{:.2f} paksa".format(self.numPaksa)
        sqrtPaksaText = "{:.2f} sqrt paksa".format(self.numSqrtPaksa)
        sqrdPaksaText = "{:.2f} sqrd paksa".format(self.numSqrdPaksa)
        samaText = "{:.2f} sama".format(self.numSama)
        sqrtSamaText = "{:.2f} sqrt sama".format(self.numSqrtSama)
        sqrdSamaText = "{:.2f} sqrd sama".format(self.numSqrdSama)

        # Text to set in the text item.
        text = ""

        if self.showBarsTextFlag == True:
            text += barsText + os.linesep
        if self.showSqrtBarsTextFlag == True:
            text += sqrtBarsText + os.linesep
        if self.showSqrdBarsTextFlag == True:
            text += sqrdBarsText + os.linesep
        if self.showHoursTextFlag == True:
            text += hoursText + os.linesep
        if self.showSqrtHoursTextFlag == True:
            text += sqrtHoursText + os.linesep
        if self.showSqrdHoursTextFlag == True:
            text += sqrdHoursText + os.linesep
        if self.showDaysTextFlag == True:
            text += daysText + os.linesep
        if self.showSqrtDaysTextFlag == True:
            text += sqrtDaysText + os.linesep
        if self.showSqrdDaysTextFlag == True:
            text += sqrdDaysText + os.linesep
        if self.showWeeksTextFlag == True:
            text += weeksText + os.linesep
        if self.showSqrtWeeksTextFlag == True:
            text += sqrtWeeksText + os.linesep
        if self.showSqrdWeeksTextFlag == True:
            text += sqrdWeeksText + os.linesep
        if self.showMonthsTextFlag == True:
            text += monthsText + os.linesep
        if self.showSqrtMonthsTextFlag == True:
            text += sqrtMonthsText + os.linesep
        if self.showSqrdMonthsTextFlag == True:
            text += sqrdMonthsText + os.linesep
        if self.showTimeRangeTextFlag == True:
            text += timeRangeText + os.linesep
        if self.showSqrtTimeRangeTextFlag == True:
            text += sqrtTimeRangeText + os.linesep
        if self.showSqrdTimeRangeTextFlag == True:
            text += sqrdTimeRangeText + os.linesep
        if self.showScaledValueRangeTextFlag == True:
            text += scaledValueRangeText + os.linesep
        if self.showSqrtScaledValueRangeTextFlag == True:
            text += sqrtScaledValueRangeText + os.linesep
        if self.showSqrdScaledValueRangeTextFlag == True:
            text += sqrdScaledValueRangeText + os.linesep
        if self.showAyanaTextFlag == True:
            text += ayanaText + os.linesep
        if self.showSqrtAyanaTextFlag == True:
            text += sqrtAyanaText + os.linesep
        if self.showSqrdAyanaTextFlag == True:
            text += sqrdAyanaText + os.linesep
        if self.showMuhurtaTextFlag == True:
            text += muhurtaText + os.linesep
        if self.showSqrtMuhurtaTextFlag == True:
            text += sqrtMuhurtaText + os.linesep
        if self.showSqrdMuhurtaTextFlag == True:
            text += sqrdMuhurtaText + os.linesep
        if self.showVaraTextFlag == True:
            text += varaText + os.linesep
        if self.showSqrtVaraTextFlag == True:
            text += sqrtVaraText + os.linesep
        if self.showSqrdVaraTextFlag == True:
            text += sqrdVaraText + os.linesep
        if self.showRtuTextFlag == True:
            text += rtuText + os.linesep
        if self.showSqrtRtuTextFlag == True:
            text += sqrtRtuText + os.linesep
        if self.showSqrdRtuTextFlag == True:
            text += sqrdRtuText + os.linesep
        if self.showMasaTextFlag == True:
            text += masaText + os.linesep
        if self.showSqrtMasaTextFlag == True:
            text += sqrtMasaText + os.linesep
        if self.showSqrdMasaTextFlag == True:
            text += sqrdMasaText + os.linesep
        if self.showPaksaTextFlag == True:
            text += paksaText + os.linesep
        if self.showSqrtPaksaTextFlag == True:
            text += sqrtPaksaText + os.linesep
        if self.showSqrdPaksaTextFlag == True:
            text += sqrdPaksaText + os.linesep
        if self.showSamaTextFlag == True:
            text += samaText + os.linesep
        if self.showSqrtSamaTextFlag == True:
            text += sqrtSamaText + os.linesep
        if self.showSqrdSamaTextFlag == True:
            text += sqrdSamaText + os.linesep

        text = text.rstrip()
        self.textItem.setText(text)
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartTimeMeasurementArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartTimeMeasurementArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartTimeMeasurementArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartTimeMeasurementArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.timeMeasurementTextXScaling = self.artifact.getTextXScaling()
        self.timeMeasurementTextYScaling = self.artifact.getTextYScaling()
        self.timeMeasurementTextFont = self.artifact.getFont()
        self.timeMeasurementGraphicsItemTextColor = self.artifact.getTextColor()
        self.timeMeasurementPen.setColor(self.artifact.getColor())
        
        self.showBarsTextFlag = self.artifact.getShowBarsTextFlag()
        self.showSqrtBarsTextFlag = self.artifact.getShowSqrtBarsTextFlag()
        self.showSqrdBarsTextFlag = self.artifact.getShowSqrdBarsTextFlag()
        self.showHoursTextFlag = self.artifact.getShowHoursTextFlag()
        self.showSqrtHoursTextFlag = self.artifact.getShowSqrtHoursTextFlag()
        self.showSqrdHoursTextFlag = self.artifact.getShowSqrdHoursTextFlag()
        self.showDaysTextFlag = self.artifact.getShowDaysTextFlag()
        self.showSqrtDaysTextFlag = self.artifact.getShowSqrtDaysTextFlag()
        self.showSqrdDaysTextFlag = self.artifact.getShowSqrdDaysTextFlag()
        self.showWeeksTextFlag = self.artifact.getShowWeeksTextFlag()
        self.showSqrtWeeksTextFlag = self.artifact.getShowSqrtWeeksTextFlag()
        self.showSqrdWeeksTextFlag = self.artifact.getShowSqrdWeeksTextFlag()
        self.showMonthsTextFlag = self.artifact.getShowMonthsTextFlag()
        self.showSqrtMonthsTextFlag = self.artifact.getShowSqrtMonthsTextFlag()
        self.showSqrdMonthsTextFlag = self.artifact.getShowSqrdMonthsTextFlag()
        self.showTimeRangeTextFlag = \
            self.artifact.getShowTimeRangeTextFlag()
        self.showSqrtTimeRangeTextFlag = \
            self.artifact.getShowSqrtTimeRangeTextFlag()
        self.showSqrdTimeRangeTextFlag = \
            self.artifact.getShowSqrdTimeRangeTextFlag()
        self.showScaledValueRangeTextFlag = \
            self.artifact.getShowScaledValueRangeTextFlag()
        self.showSqrtScaledValueRangeTextFlag = \
            self.artifact.getShowSqrtScaledValueRangeTextFlag()
        self.showSqrdScaledValueRangeTextFlag = \
            self.artifact.getShowSqrdScaledValueRangeTextFlag()
        self.showAyanaTextFlag = \
            self.artifact.getShowAyanaTextFlag()
        self.showSqrtAyanaTextFlag = \
            self.artifact.getShowSqrtAyanaTextFlag()
        self.showSqrdAyanaTextFlag = \
            self.artifact.getShowSqrdAyanaTextFlag()
        self.showMuhurtaTextFlag = \
            self.artifact.getShowMuhurtaTextFlag()
        self.showSqrtMuhurtaTextFlag = \
            self.artifact.getShowSqrtMuhurtaTextFlag()
        self.showSqrdMuhurtaTextFlag = \
            self.artifact.getShowSqrdMuhurtaTextFlag()
        self.showVaraTextFlag = \
            self.artifact.getShowVaraTextFlag()
        self.showSqrtVaraTextFlag = \
            self.artifact.getShowSqrtVaraTextFlag()
        self.showSqrdVaraTextFlag = \
            self.artifact.getShowSqrdVaraTextFlag()
        self.showRtuTextFlag = \
            self.artifact.getShowRtuTextFlag()
        self.showSqrtRtuTextFlag = \
            self.artifact.getShowSqrtRtuTextFlag()
        self.showSqrdRtuTextFlag = \
            self.artifact.getShowSqrdRtuTextFlag()
        self.showMasaTextFlag = \
            self.artifact.getShowMasaTextFlag()
        self.showSqrtMasaTextFlag = \
            self.artifact.getShowSqrtMasaTextFlag()
        self.showSqrdMasaTextFlag = \
            self.artifact.getShowSqrdMasaTextFlag()
        self.showPaksaTextFlag = \
            self.artifact.getShowPaksaTextFlag()
        self.showSqrtPaksaTextFlag = \
            self.artifact.getShowSqrtPaksaTextFlag()
        self.showSqrdPaksaTextFlag = \
            self.artifact.getShowSqrdPaksaTextFlag()
        self.showSamaTextFlag = \
            self.artifact.getShowSamaTextFlag()
        self.showSqrtSamaTextFlag = \
            self.artifact.getShowSqrtSamaTextFlag()
        self.showSqrdSamaTextFlag = \
            self.artifact.getShowSqrdSamaTextFlag()

        #############

        # Update all the text item with the new settings.
        self.reApplyTextItemAttributes(self.textItem)

        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the time measurements will be zero, since it
        # can't look up PriceBarGraphicsItems in the scene.
        self.recalculateTimeMeasurement()
        
        # Update the timeMeasurement text item position.
        self._updateTextItemPositions()
        
        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartTimeMeasurementArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartTimeMeasurementArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        self.artifact.setTextXScaling(self.timeMeasurementTextXScaling)
        self.artifact.setTextYScaling(self.timeMeasurementTextYScaling)
        self.artifact.setFont(self.timeMeasurementTextFont)
        self.artifact.setTextColor(self.timeMeasurementGraphicsItemTextColor)
        self.artifact.setColor(self.timeMeasurementPen.color())
        
        self.artifact.setShowBarsTextFlag(self.showBarsTextFlag)
        self.artifact.setShowSqrtBarsTextFlag(self.showSqrtBarsTextFlag)
        self.artifact.setShowSqrdBarsTextFlag(self.showSqrdBarsTextFlag)
        self.artifact.setShowHoursTextFlag(self.showHoursTextFlag)
        self.artifact.setShowSqrtHoursTextFlag(self.showSqrtHoursTextFlag)
        self.artifact.setShowSqrdHoursTextFlag(self.showSqrdHoursTextFlag)
        self.artifact.setShowDaysTextFlag(self.showDaysTextFlag)
        self.artifact.setShowSqrtDaysTextFlag(self.showSqrtDaysTextFlag)
        self.artifact.setShowSqrdDaysTextFlag(self.showSqrdDaysTextFlag)
        self.artifact.setShowWeeksTextFlag(self.showWeeksTextFlag)
        self.artifact.setShowSqrtWeeksTextFlag(self.showSqrtWeeksTextFlag)
        self.artifact.setShowSqrdWeeksTextFlag(self.showSqrdWeeksTextFlag)
        self.artifact.setShowMonthsTextFlag(self.showMonthsTextFlag)
        self.artifact.setShowSqrtMonthsTextFlag(self.showSqrtMonthsTextFlag)
        self.artifact.setShowSqrdMonthsTextFlag(self.showSqrdMonthsTextFlag)
        self.artifact.setShowTimeRangeTextFlag(\
            self.showTimeRangeTextFlag)
        self.artifact.setShowSqrtTimeRangeTextFlag(\
            self.showSqrtTimeRangeTextFlag)
        self.artifact.setShowSqrdTimeRangeTextFlag(\
            self.showSqrdTimeRangeTextFlag)
        self.artifact.setShowScaledValueRangeTextFlag(\
            self.showScaledValueRangeTextFlag)
        self.artifact.setShowSqrtScaledValueRangeTextFlag(\
            self.showSqrtScaledValueRangeTextFlag)
        self.artifact.setShowSqrdScaledValueRangeTextFlag(\
            self.showSqrdScaledValueRangeTextFlag)
        self.artifact.setShowAyanaTextFlag(self.showAyanaTextFlag)
        self.artifact.setShowSqrtAyanaTextFlag(self.showSqrtAyanaTextFlag)
        self.artifact.setShowSqrdAyanaTextFlag(self.showSqrdAyanaTextFlag)
        self.artifact.setShowMuhurtaTextFlag(self.showMuhurtaTextFlag)
        self.artifact.setShowSqrtMuhurtaTextFlag(self.showSqrtMuhurtaTextFlag)
        self.artifact.setShowSqrdMuhurtaTextFlag(self.showSqrdMuhurtaTextFlag)
        self.artifact.setShowVaraTextFlag(self.showVaraTextFlag)
        self.artifact.setShowSqrtVaraTextFlag(self.showSqrtVaraTextFlag)
        self.artifact.setShowSqrdVaraTextFlag(self.showSqrdVaraTextFlag)
        self.artifact.setShowRtuTextFlag(self.showRtuTextFlag)
        self.artifact.setShowSqrtRtuTextFlag(self.showSqrtRtuTextFlag)
        self.artifact.setShowSqrdRtuTextFlag(self.showSqrdRtuTextFlag)
        self.artifact.setShowMasaTextFlag(self.showMasaTextFlag)
        self.artifact.setShowSqrtMasaTextFlag(self.showSqrtMasaTextFlag)
        self.artifact.setShowSqrdMasaTextFlag(self.showSqrdMasaTextFlag)
        self.artifact.setShowPaksaTextFlag(self.showPaksaTextFlag)
        self.artifact.setShowSqrtPaksaTextFlag(self.showSqrtPaksaTextFlag)
        self.artifact.setShowSqrdPaksaTextFlag(self.showSqrdPaksaTextFlag)
        self.artifact.setShowSamaTextFlag(self.showSamaTextFlag)
        self.artifact.setShowSqrtSamaTextFlag(self.showSqrtSamaTextFlag)
        self.artifact.setShowSqrdSamaTextFlag(self.showSqrdSamaTextFlag)
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.

        # The QRectF returned is relative to this (0, 0) point.

        # Get the QRectF with just the lines.
        xDelta = self.endPointF.x() - self.startPointF.x()

        topLeft = \
            QPointF(0.0, -1.0 *
                    (self.timeMeasurementGraphicsItemBarHeight * 0.5))
        
        bottomRight = \
            QPointF(xDelta, 1.0 *
                    (self.timeMeasurementGraphicsItemBarHeight * 0.5))

        # Initalize to the above boundaries.  We will set them below.
        localHighY = topLeft.y()
        localLowY = bottomRight.y()
        if self.drawVerticalDottedLinesFlag or self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighestPriceBarY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()

                # Overwrite the high if it is larger.
                if localHighestPriceBarY > localHighY:
                    localHighY = localHighestPriceBarY

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowestPriceBarY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
            
                # Overwrite the low if it is smaller.
                if localLowestPriceBarY < localLowY:
                    localLowY = localLowestPriceBarY
                
        xValues = []
        xValues.append(topLeft.x())
        xValues.append(bottomRight.x())

        yValues = []
        yValues.append(topLeft.y())
        yValues.append(bottomRight.y())
        yValues.append(localHighY)
        yValues.append(localLowY)

        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Get the QRectF with just the lines.
        xDelta = self.endPointF.x() - self.startPointF.x()
        
        topLeft = \
            QPointF(0.0, -1.0 *
                    (self.timeMeasurementGraphicsItemBarHeight * 0.5))
        
        bottomRight = \
            QPointF(xDelta, 1.0 *
                    (self.timeMeasurementGraphicsItemBarHeight * 0.5))

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.timeMeasurementPen is set to what we want for the drawing
        style.
        """

        if painter.pen() != self.timeMeasurementPen:
            painter.setPen(self.timeMeasurementPen)
        
        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (self.timeMeasurementGraphicsItemBarHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (self.timeMeasurementGraphicsItemBarHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        x1 = 0.0 + xDelta
        y1 = 1.0 * (self.timeMeasurementGraphicsItemBarHeight * 0.5)
        x2 = 0.0 + xDelta
        y2 = -1.0 * (self.timeMeasurementGraphicsItemBarHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle horizontal line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = 0.0
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled tick area if the
        # flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.timeMeasurementPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                # Vertical line at the beginning.
                localPosX = 0.0
                startPoint = QPointF(localPosX, largestY)
                endPoint = QPointF(localPosX, smallestY)
                        
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
            
                # Vertical line at the end.
                localPosX = 0.0 + xDelta
                startPoint = QPointF(localPosX, largestY)
                endPoint = QPointF(localPosX, smallestY)
                        
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
        # Draw the bounding rect if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.timeMeasurementPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this TimeMeasurementGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        TimeMeasurementGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartTimeMeasurementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartTimeMeasurementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the TimeMeasurementGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the TimeMeasurementGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the TimeMeasurementGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        TimeMeasurementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        TimeMeasurementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the TimeMeasurementGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the TimeMeasurementGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the TimeMeasurementGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        TimeMeasurementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        TimeMeasurementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class VerticalTickGraphicsItem(QGraphicsItem):
    """QGraphicsItem that draws a vertical tick line. """

    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)
        
        # Logger
        self.log = logging.getLogger("pricebarchart.VerticalTickGraphicsItem")

        self.barHeight = 0.2
        
        # Pen which is used to do the painting of the bar tick.
        self.pen = QPen()
        self.penWidth = 0.0
        self.pen.setWidthF(self.penWidth)

    def setPen(self, pen):
        """Sets the pen used to draw this QGraphicsItem."""
        
        self.pen = pen
        
    def setPenWidth(self, penWidth):
        """Sets the pen width used to draw this QGraphicsItem.
        Arguments:

        penWidth - float value for the pen width.
        """
        
        self.penWidth = penWidth
        self.pen.setWidthF(self.penWidth)
    
    def setBarHeight(self, barHeight):
        """Sets the bar height of the tick.

        Arguments:
        barHeight - float value for the bar height.
        """

        self.barHeight = barHeight

    def getBarHeight(self):
        """Returns the bar height of the tick."""
        
        return self.barHeight

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        topLeft = QPointF(self.penWidth * -0.5,
                          1.0 * self.barHeight * 0.5)
        
        bottomRight = QPointF(self.penWidth * 0.5,
                              -1.0 * self.barHeight * 0.5)

        return QRectF(topLeft, bottomRight).normalized()

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.pen is set
        to what we want for the drawing style.
        """

        if painter.pen() != self.pen:
            painter.setPen(QPen(self.pen))
            
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (self.barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (self.barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

               
class HorizontalTickGraphicsItem(QGraphicsItem):
    """QGraphicsItem that draws a horizontal tick line. """

    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)
        
        # Logger
        self.log = logging.getLogger("pricebarchart.HorizontalTickGraphicsItem")

        self.barWidth = 1.0
        
        # Pen which is used to do the painting of the bar tick.
        self.pen = QPen()
        self.penWidth = 0.0
        self.pen.setWidthF(self.penWidth)

    def setPen(self, pen):
        """Sets the pen used to draw this QGraphicsItem."""
        
        self.pen = pen
        
    def setPenWidth(self, penWidth):
        """Sets the pen width used to draw this QGraphicsItem.
        Arguments:

        penWidth - float value for the pen width.
        """
        
        self.penWidth = penWidth
        self.pen.setWidthF(self.penWidth)
    
    def setBarWidth(self, barWidth):
        """Sets the bar width of the tick.

        Arguments:
        barWidth - float value for the bar width.
        """

        self.barWidth = barWidth

    def getBarWidth(self):
        """Returns the bar width of the tick."""
        
        return self.barWidth

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        topLeft = QPointF(1.0 * self.barWidth * 0.5,
                          self.penWidth * -0.5)
        
        bottomRight = QPointF(-1.0 * self.barWidth * 0.5,
                              self.penWidth * 0.5)

        return QRectF(topLeft, bottomRight).normalized()

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.pen is set
        to what we want for the drawing style.
        """

        if painter.pen() != self.pen:
            painter.setPen(QPen(self.pen))
            
        # Draw the left horizontal bar part.
        x1 = 1.0 * (self.barWidth * 0.5)
        y1 = 0.0
        x2 = -1.0 * (self.barWidth * 0.5)
        y2 = 0.0
        painter.drawLine(QLineF(x1, y1, x2, y2))

               
class TimeModalScaleGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new TimeModalScaleGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.TimeModalScaleGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar (QColor).
        self.timeModalScaleGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultTimeModalScaleGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem (QColor).
        self.timeModalScaleGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultTimeModalScaleGraphicsItemTextColor

        # TimeModalScaleGraphicsItem bar height (float).
        self.timeModalScaleGraphicsItemBarHeight = \
            PriceBarChartSettings.\
                defaultTimeModalScaleGraphicsItemBarHeight

        # TimeModalScaleGraphicsItem font size (float).
        self.timeModalScaleGraphicsItemFontSize = \
            PriceBarChartSettings.\
                defaultTimeModalScaleGraphicsItemFontSize
        
        # X scaling of the text (float).
        self.timeModalScaleTextXScaling = \
            PriceBarChartSettings.\
                defaultTimeModalScaleGraphicsItemTextXScaling 

        # Y scaling of the text (float).
        self.timeModalScaleTextYScaling = \
            PriceBarChartSettings.\
                defaultTimeModalScaleGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartTimeModalScaleArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.timeModalScalePenWidth = 0.0
        self.timeModalScalePen = QPen()
        self.timeModalScalePen.setColor(self.timeModalScaleGraphicsItemColor)
        self.timeModalScalePen.setWidthF(self.timeModalScalePenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.timeModalScaleTextFont = QFont("Sans Serif")
        self.timeModalScaleTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.timeModalScaleTextPen = self.dummyItem.pen()
        self.timeModalScaleTextPen.\
            setColor(self.timeModalScaleGraphicsItemTextColor)

        # Set the brush color of the text.
        self.timeModalScaleTextBrush = self.dummyItem.brush()
        self.timeModalScaleTextBrush.\
            setColor(self.timeModalScaleGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.timeModalScaleTextXScaling, \
                            self.timeModalScaleTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartTimeModalScaleArtifact.  The 2 texts displayed
        # for each MusicalRatio is:
        #
        # 1) Fraction (or float if no numerator and no denominator is set).
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.timeModalScalePen)
            
            fractionTextItem = QGraphicsSimpleTextItem("", self)
            fractionTextItem.setPos(self.endPointF)
            fractionTextItem.setFont(self.timeModalScaleTextFont)
            fractionTextItem.setPen(self.timeModalScaleTextPen)
            fractionTextItem.setBrush(self.timeModalScaleTextBrush)
            fractionTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.timeModalScaleTextFont)
            timestampTextItem.setPen(self.timeModalScaleTextPen)
            timestampTextItem.setBrush(self.timeModalScaleTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([fractionTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          timeModalScaleGraphicsItemMusicalRatios)
        
        # TimeModalScaleGraphicsItem bar color (QColor).
        self.timeModalScaleGraphicsItemColor = \
            priceBarChartSettings.timeModalScaleGraphicsItemBarColor

        # TimeModalScaleGraphicsItem text color (QColor).
        self.timeModalScaleGraphicsItemTextColor = \
            priceBarChartSettings.timeModalScaleGraphicsItemTextColor
        
        # TimeModalScaleGraphicsItem bar height (float).
        self.timeModalScaleGraphicsItemBarHeight = \
            priceBarChartSettings.timeModalScaleGraphicsItemBarHeight

        # TimeModalScaleGraphicsItem font size (float).
        self.timeModalScaleGraphicsItemFontSize = \
            priceBarChartSettings.timeModalScaleGraphicsItemFontSize
        
        # X scaling of the text (float).
        self.timeModalScaleTextXScaling = \
            priceBarChartSettings.\
                timeModalScaleGraphicsItemTextXScaling 

        # Y scaling of the text (float).
        self.timeModalScaleTextYScaling = \
            priceBarChartSettings.\
                timeModalScaleGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            timeModalScaleGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.timeModalScaleGraphicsItemColor)
        self.artifact.setTextColor(self.timeModalScaleGraphicsItemTextColor)
        self.artifact.setBarHeight(self.timeModalScaleGraphicsItemBarHeight)
        self.artifact.setFontSize(self.timeModalScaleGraphicsItemFontSize)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the timeModalScale label text item texts.
        if self.scene() != None:
            self.recalculateTimeModalScale()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateTimeModalScale() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.timeModalScaleTextXScaling, \
                                    self.timeModalScaleTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y),
                    # but instead at an offset slightly below that
                    # point so that multiple texts dont' overlap
                    # each other.
                    offsetX = (textItem.boundingRect().height() * \
                               self.timeModalScaleTextYScaling * 0.95) * j
                    textItem.setPos(QPointF(pointF.x() - offsetX,
                                            pointF.y()))
                    textItem.setFont(self.timeModalScaleTextFont)
                    textItem.setPen(self.timeModalScaleTextPen)
                    textItem.setBrush(self.timeModalScaleTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                self.verticalTickItems[i].\
                    setBarHeight(self.timeModalScaleGraphicsItemBarHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the timeModalScale.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the timeModalScale label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the timeModalScale.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("TimeModalScaleGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the timeModalScale label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of TimeModalScaleGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the timeModalScale label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateTimeModalScale(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # The text here is either the note in a
                            # scale (do, re, me, fa, sol, la, ti, do)
                            # or the fraction (if the numerator and
                            # denominator are available), or the float
                            # value for the ratio.

                            # The note string is obtained from the
                            # description and is located within the
                            # 3rd set of parenthesis.
                            noteText = ""
                            description = musicalRatio.getDescription()
                            firstOpenParenPos = \
                                description.find("(", 0)
                            secondOpenParenPos = \
                                description.find("(", firstOpenParenPos + 1)
                            thirdOpenParenPos = \
                                description.find("(", secondOpenParenPos + 1)
                            firstCloseParenPos = \
                                description.find(")", 0)
                            secondCloseParenPos = \
                                description.find(")", firstCloseParenPos + 1)
                            thirdCloseParenPos = \
                                description.find(")", secondCloseParenPos + 1)
                            
                            if firstOpenParenPos != -1 and \
                               firstCloseParenPos != -1 and \
                               secondOpenParenPos != -1 and \
                               secondCloseParenPos != -1 and \
                               thirdOpenParenPos != -1 and \
                               thirdCloseParenPos != -1:

                                start = thirdOpenParenPos + 1
                                end = thirdCloseParenPos
                                noteText = description[start:end]

                            # Get the numerator and denominator.
                            numerator = musicalRatio.getNumerator()
                            denominator = musicalRatio.getDenominator()

                            if noteText != "":
                                textItem.setText(noteText)
                            elif numerator != None and denominator != None:
                                fractionText = \
                                    "{}/{}".format(numerator, denominator)
                                textItem.setText(fractionText)
                            else:
                                ratio = musicalRatio.getRatio()
                                ratioText = "{}".format(ratio)
                                textItem.setText(ratioText)
                        elif j == 1:
                            # Timestamp text.
                            
                            # Get the x location and then convert to a datetime.
                            (x, y) = artifact.getXYForMusicalRatio(i)
                            timestamp = \
                                self.scene().sceneXPosToDatetime(x)
                            timestampText = \
                                Ephemeris.datetimeToDayStr(timestamp)
                            # TODO:  This below has been temporarily commented out.  Uncomment if I want the timestamps to be displayed.
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartTimeModalScaleArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartTimeModalScaleArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartTimeModalScaleArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartTimeModalScaleArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.timeModalScaleTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.timeModalScalePen.\
            setColor(self.artifact.getColor())
        self.timeModalScaleTextPen.\
            setColor(self.artifact.getTextColor())
        self.timeModalScaleTextBrush.\
            setColor(self.artifact.getTextColor())
        self.timeModalScaleGraphicsItemBarHeight = self.artifact.getBarHeight()
        self.timeModalScaleGraphicsItemFontSize = self.artifact.getFontSize()

        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartTimeModalScaleArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartTimeModalScaleArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = self.timeModalScaleGraphicsItemBarHeight
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)
        
        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = self.timeModalScaleGraphicsItemBarHeight
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.timeModalScalePen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered TimeModalScaleGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.timeModalScalePen:
            painter.setPen(self.timeModalScalePen)

        barHeight = self.timeModalScaleGraphicsItemBarHeight

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.timeModalScalePen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.timeModalScalePen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this TimeModalScaleGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        TimeModalScaleGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartTimeModalScaleArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartTimeModalScaleArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the TimeModalScaleGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the TimeModalScaleGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the TimeModalScaleGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        TimeModalScaleGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        TimeModalScaleGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the TimeModalScaleGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the TimeModalScaleGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the TimeModalScaleGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        TimeModalScaleGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        TimeModalScaleGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class PriceModalScaleGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point width bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new PriceModalScaleGraphicsItem
    the position and points can be consistently set.
    """

    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.PriceModalScaleGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.
        
        # Color of the graphicsitem bar (QColor).
        self.priceModalScaleGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultPriceModalScaleGraphicsItemBarColor

        # Color of the text that is associated with the bar count
        # graphicsitem (QColor).
        self.priceModalScaleGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultPriceModalScaleGraphicsItemTextColor

        # PriceModalScaleGraphicsItem bar width (float).
        self.priceModalScaleGraphicsItemBarWidth = \
            PriceBarChartSettings.\
                defaultPriceModalScaleGraphicsItemBarWidth

        # PriceModalScaleGraphicsItem font size (float).
        self.priceModalScaleGraphicsItemFontSize = \
            PriceBarChartSettings.\
                defaultPriceModalScaleGraphicsItemFontSize
        
        # X scaling of the text (float).
        self.priceModalScaleTextXScaling = \
            PriceBarChartSettings.\
                defaultPriceModalScaleGraphicsItemTextXScaling 

        # Y scaling of the text (float).
        self.priceModalScaleTextYScaling = \
            PriceBarChartSettings.\
                defaultPriceModalScaleGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartPriceModalScaleArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.priceModalScalePenWidth = 0.0
        self.priceModalScalePen = QPen()
        self.priceModalScalePen.setColor(self.priceModalScaleGraphicsItemColor)
        self.priceModalScalePen.setWidthF(self.priceModalScalePenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.priceModalScaleTextFont = QFont("Sans Serif")
        self.priceModalScaleTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.priceModalScaleTextPen = self.dummyItem.pen()
        self.priceModalScaleTextPen.\
            setColor(self.priceModalScaleGraphicsItemTextColor)

        # Set the brush color of the text.
        self.priceModalScaleTextBrush = self.dummyItem.brush()
        self.priceModalScaleTextBrush.\
            setColor(self.priceModalScaleGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 0.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.priceModalScaleTextXScaling, \
                            self.priceModalScaleTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartPriceModalScaleArtifact.  The 2 texts displayed
        # for each MusicalRatio is:
        #
        # 1) Fraction (or float if no numerator and no denominator is set).
        # 2) Price value
        #
        self.musicalRatioTextItems = []

        # Below is a list of HorizontalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.horizontalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            horizontalTickItem = HorizontalTickGraphicsItem(self)
            horizontalTickItem.setPos(self.endPointF)
            horizontalTickItem.setPen(self.priceModalScalePen)
            
            fractionTextItem = QGraphicsSimpleTextItem("", self)
            fractionTextItem.setPos(self.endPointF)
            fractionTextItem.setFont(self.priceModalScaleTextFont)
            fractionTextItem.setPen(self.priceModalScaleTextPen)
            fractionTextItem.setBrush(self.priceModalScaleTextBrush)
            fractionTextItem.setTransform(textTransform)
            
            priceTextItem = QGraphicsSimpleTextItem("", self)
            priceTextItem.setPos(self.endPointF)
            priceTextItem.setFont(self.priceModalScaleTextFont)
            priceTextItem.setPen(self.priceModalScaleTextPen)
            priceTextItem.setBrush(self.priceModalScaleTextBrush)
            priceTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([fractionTextItem, priceTextItem])

            self.horizontalTickItems.append(horizontalTickItem)

        # Flag that indicates that horizontal dotted lines should be drawn.
        self.drawHorizontalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawHorizontalDottedLinesFlag(self, flag):
        """If flag is set to true, then the horizontal dotted lines are drawn.
        """

        self.drawHorizontalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra horizontal lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          priceModalScaleGraphicsItemMusicalRatios)
        
        # PriceModalScaleGraphicsItem bar color (QColor).
        self.priceModalScaleGraphicsItemColor = \
            priceBarChartSettings.priceModalScaleGraphicsItemBarColor

        # PriceModalScaleGraphicsItem text color (QColor).
        self.priceModalScaleGraphicsItemTextColor = \
            priceBarChartSettings.priceModalScaleGraphicsItemTextColor
        
        # PriceModalScaleGraphicsItem bar width (float).
        self.priceModalScaleGraphicsItemBarWidth = \
            priceBarChartSettings.priceModalScaleGraphicsItemBarWidth

        # PriceModalScaleGraphicsItem font size (float).
        self.priceModalScaleGraphicsItemFontSize = \
            priceBarChartSettings.priceModalScaleGraphicsItemFontSize
        
        # X scaling of the text (float).
        self.priceModalScaleTextXScaling = \
            priceBarChartSettings.\
                priceModalScaleGraphicsItemTextXScaling 

        # Y scaling of the text (float).
        self.priceModalScaleTextYScaling = \
            priceBarChartSettings.\
                priceModalScaleGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            priceModalScaleGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.
        
        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.priceModalScaleGraphicsItemColor)
        self.artifact.setTextColor(self.priceModalScaleGraphicsItemTextColor)
        self.artifact.setBarWidth(self.priceModalScaleGraphicsItemBarWidth)
        self.artifact.setFontSize(self.priceModalScaleGraphicsItemFontSize)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosY = event.scenePos().y()
            self.log.debug("DEBUG: scenePosY={}".format(scenePosY))
            
            startingPointY = self.startPointF.y()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointY))
            endingPointY = self.endPointF.y()
            self.log.debug("DEBUG: endingPointY={}".format(endingPointY))
            
            diff = endingPointY - startingPointY
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointY + (diff * (1.0 / 5))
            endThreshold = endingPointY - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointY <= scenePosY <= startThreshold or \
                   startingPointY >= scenePosY >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointY <= scenePosY <= endThreshold or \
                   endingPointY >= scenePosY >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(self.startPointF.x(),
                                                event.scenePos().y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(self.endPointF.x(),
                                              event.scenePos().y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the priceModalScale label text item texts.
        if self.scene() != None:
            self.recalculatePriceModalScale()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculatePriceModalScale() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.priceModalScaleTextXScaling, \
                                    self.priceModalScaleTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y),
                    # but instead at an offset slightly below that
                    # point so that multiple texts dont' overlap
                    # each other.
                    offsetY = (textItem.boundingRect().height() * \
                               self.priceModalScaleTextYScaling * 0.95) * j
                    textItem.setPos(QPointF(pointF.x(),
                                            pointF.y() + offsetY))
                    textItem.setFont(self.priceModalScaleTextFont)
                    textItem.setPen(self.priceModalScaleTextPen)
                    textItem.setBrush(self.priceModalScaleTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the horizontal tick line.
                self.horizontalTickItems[i].\
                    setBarWidth(self.priceModalScaleGraphicsItemBarWidth)
                self.horizontalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the priceModalScale.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the priceModalScale label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the priceModalScale.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("PriceModalScaleGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the priceModalScale label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of PriceModalScaleGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the priceModalScale label text item positions.
        #    self.refreshTextItems()
        pass
            

    def recalculatePriceModalScale(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and price.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Fraction text.  This is either the
                            # fraction (if the numerator and
                            # denominator are available), or the float
                            # value for the ratio.
                            
                            numerator = musicalRatio.getNumerator()
                            denominator = musicalRatio.getDenominator()
                            
                            if numerator != None and denominator != None:
                                fractionText = \
                                    "{}/{}".format(numerator, denominator)
                                textItem.setText(fractionText)
                            else:
                                ratio = musicalRatio.getRatio()
                                ratioText = "{}".format(ratio)
                                textItem.setText(ratioText)
                        elif j == 1:
                            # Price text.
                            
                            # Get the y location and then convert to a price.
                            (x, y) = artifact.getXYForMusicalRatio(i)
                            price = self.scene().sceneYPosToPrice(y)
                            priceText = "{}".format(price)
                            textItem.setText(priceText)

                    # Also enable and set the horizontal tick line.
                    self.horizontalTickItems[i].setVisible(True)
                    self.horizontalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the horizontal tick line.
                    self.horizontalTickItems[i].setVisible(False)
                    self.horizontalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartPriceModalScaleArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartPriceModalScaleArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartPriceModalScaleArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartPriceModalScaleArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.priceModalScaleTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.priceModalScalePen.\
            setColor(self.artifact.getColor())
        self.priceModalScaleTextPen.\
            setColor(self.artifact.getTextColor())
        self.priceModalScaleTextBrush.\
            setColor(self.artifact.getTextColor())
        self.priceModalScaleGraphicsItemBarWidth = self.artifact.getBarWidth()
        self.priceModalScaleGraphicsItemFontSize = self.artifact.getFontSize()
        
        # Need to recalculate the price measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartPriceModalScaleArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartPriceModalScaleArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)

        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the horizontal bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        barWidth = self.priceModalScaleGraphicsItemBarWidth
        
        # The QRectF returned is relative to this (0, 0) point.
        xBottomRight = 1.0 * (barWidth * 0.5)
        yBottomRight = 0.0
        
        xBottomLeft = -1.0 * (barWidth * 0.5)
        yBottomLeft = 0.0
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopLeft = (-1.0 * (barWidth * 0.5)) + xDelta
        yTopLeft = 0.0 + yDelta

        xTopRight = (1.0 * (barWidth * 0.5)) + xDelta
        yTopRight = 0.0 + yDelta
        
        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)
        
        # Get the last and first PriceBar's timestamp in local
        # coordinates.
        if self.drawHorizontalDottedLinesFlag == True or self.isSelected():
            earliestPriceBar = self.scene().getEarliestPriceBar()
            if earliestPriceBar != None:
                smallestPriceBarX = \
                    self.scene().datetimeToSceneXPos(earliestPriceBar.timestamp)
                localSmallestPriceBarX = \
                    self.mapFromScene(QPointF(smallestPriceBarX, 0.0)).x()
                xValues.append(localSmallestPriceBarX)
                
            latestPriceBar = self.scene().getLatestPriceBar()
            if latestPriceBar != None:
                largestPriceBarX = \
                    self.scene().datetimeToSceneXPos(latestPriceBar.timestamp)
                localLargestPriceBarX = \
                    self.mapFromScene(QPointF(largestPriceBarX, 0.0)).x()
                xValues.append(localLargestPriceBarX)
        
        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barWidth = self.priceModalScaleGraphicsItemBarWidth
        
        # The QRectF returned is relative to this (0, 0) point.
        xBottomRight = 1.0 * (barWidth * 0.5)
        yBottomRight = 0.0
        
        xBottomLeft = -1.0 * (barWidth * 0.5)
        yBottomLeft = 0.0
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopLeft = (-1.0 * (barWidth * 0.5)) + xDelta
        yTopLeft = 0.0 + yDelta

        xTopRight = (1.0 * (barWidth * 0.5)) + xDelta
        yTopRight = 0.0 + yDelta
        
        topLeft = QPointF(xTopLeft, yTopLeft)
        topRight = QPointF(xTopRight, yTopRight)
        bottomRight = QPointF(xBottomRight, yBottomRight)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.priceModalScalePen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered PriceModalScaleGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.priceModalScalePen:
            painter.setPen(self.priceModalScalePen)

        barWidth = self.priceModalScaleGraphicsItemBarWidth

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left horizontal bar part.
        x1 = 1.0 * (barWidth * 0.5)
        y1 = 0.0
        x2 = -1.0 * (barWidth * 0.5)
        y2 = 0.0
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right horizontal bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = (1.0 * (barWidth * 0.5)) + xDelta
        y1 = 0.0 + yDelta
        x2 = (-1.0 * (barWidth * 0.5)) + xDelta
        y2 = 0.0 + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw horizontal dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawHorizontalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.priceModalScalePen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the last and first PriceBar's timestamp in local
                # coordinates.
                earliestPriceBar = self.scene().getEarliestPriceBar()
                if earliestPriceBar != None:
                    smallestPriceBarX = \
                        self.scene().\
                        datetimeToSceneXPos(earliestPriceBar.timestamp)
                    localSmallestPriceBarX = \
                        self.mapFromScene(QPointF(smallestPriceBarX, 0.0)).x()
                    xValues.append(localSmallestPriceBarX)
                
                latestPriceBar = self.scene().getLatestPriceBar()
                if latestPriceBar != None:
                    largestPriceBarX = \
                        self.scene().\
                        datetimeToSceneXPos(latestPriceBar.timestamp)
                    localLargestPriceBarX = \
                        self.mapFromScene(QPointF(largestPriceBarX, 0.0)).x()
                    xValues.append(localLargestPriceBarX)

                # We have all x values now, so sort them to get the
                # low and high.
                xValues.sort()
                smallestX = xValues[0]
                largestX = xValues[-1]
        
                for horizontalTickItem in self.horizontalTickItems:
                    if horizontalTickItem.isEnabled() and \
                       horizontalTickItem.isVisible():
                    
                        localPosY = horizontalTickItem.pos().y()

                        startPoint = QPointF(largestX, localPosY)
                        endPoint = QPointF(smallestX, localPosY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
            
                # Draw the horizontal line for the start point.
                startPoint = QPointF(largestX, 0.0)
                endPoint = QPointF(smallestX, 0.0)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the horizontal line for the end point.
                startPoint = QPointF(largestX, 0.0 + yDelta)
                endPoint = QPointF(smallestX, 0.0 + yDelta)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                
        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.priceModalScalePen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PriceModalScaleGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        PriceModalScaleGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)

        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)

    def rotateDown(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the TimeModalScaleGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceModalScaleArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceModalScaleArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the PriceModalScaleGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the PriceModalScaleGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the PriceModalScaleGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the PriceModalScaleGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the PriceModalScaleGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the PriceModalScaleGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        PriceModalScaleGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        PriceModalScaleGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
        
class PlanetLongitudeMovementMeasurementGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a time measurement in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new
    PlanetLongitudeMovementMeasurementGraphicsItem the position and
    points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger("pricebarchart.PlanetLongitudeMovementMeasurementGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.
        
        # Height of the vertical bar drawn.
        self.planetLongitudeMovementMeasurementGraphicsItemBarHeight = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemBarHeight 
 
        # Text rotation angle, in degrees (float).
        self.planetLongitudeMovementMeasurementGraphicsItemTextRotationAngle = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemTextRotationAngle 
 
        # X scaling of the text.
        self.planetLongitudeMovementMeasurementTextXScaling = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.planetLongitudeMovementMeasurementTextYScaling = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemTextYScaling 

        # Font.
        self.planetLongitudeMovementMeasurementTextFont = QFont()
        self.planetLongitudeMovementMeasurementTextFont.fromString(\
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.planetLongitudeMovementMeasurementGraphicsItemTextColor = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemDefaultTextColor

        # Color of the item.
        self.planetLongitudeMovementMeasurementGraphicsItemColor = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemDefaultColor

        # Flag for measuring planet geocentric longitude movement,
        # where retrograde movements count as zero.
        self.showGeocentricRetroAsZeroTextFlag = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemShowGeocentricRetroAsZeroTextFlag
        
        # Flag for measuring planet geocentric longitude movement,
        # where retrograde movements count as positive values.
        self.showGeocentricRetroAsPositiveTextFlag = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemShowGeocentricRetroAsPositiveTextFlag
        
        # Flag for measuring planet geocentric longitude movement,
        # where retrograde movements count as negative values.
        self.showGeocentricRetroAsNegativeTextFlag = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemShowGeocentricRetroAsNegativeTextFlag
        
        # Flag for measuring planet heliocentric longitude movement.
        self.showHeliocentricTextFlag = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemShowHeliocentricTextFlag
        
        # Flag for using the tropical zodiac in measurements.
        self.tropicalZodiacFlag = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemTropicalZodiacFlag
        
        # Flag for using the sidereal zodiac in measurements.
        self.siderealZodiacFlag = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemSiderealZodiacFlag
        
        # Flag for displaying measurements in degrees.
        self.measurementUnitDegreesEnabled = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemMeasurementUnitDegreesEnabled
        
        # Flag for displaying measurements in number of circles.
        self.measurementUnitCirclesEnabled = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemMeasurementUnitCirclesEnabled

        # Flag for displaying measurements in number of biblical circles.
        self.measurementUnitBiblicalCirclesEnabled = \
            PriceBarChartSettings.\
            defaultPlanetLongitudeMovementMeasurementGraphicsItemMeasurementUnitBiblicalCirclesEnabled

        # List of names of the enabled planets.
        self.planetNamesEnabled = []
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH1EnabledFlag == True:
            self.planetNamesEnabled.append("H1")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH2EnabledFlag == True:
            self.planetNamesEnabled.append("H2")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH3EnabledFlag == True:
            self.planetNamesEnabled.append("H3")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH4EnabledFlag == True:
            self.planetNamesEnabled.append("H4")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH5EnabledFlag == True:
            self.planetNamesEnabled.append("H5")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH6EnabledFlag == True:
            self.planetNamesEnabled.append("H6")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH7EnabledFlag == True:
            self.planetNamesEnabled.append("H7")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH8EnabledFlag == True:
            self.planetNamesEnabled.append("H8")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH9EnabledFlag == True:
            self.planetNamesEnabled.append("H9")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH10EnabledFlag == True:
            self.planetNamesEnabled.append("H10")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH11EnabledFlag == True:
            self.planetNamesEnabled.append("H11")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetH12EnabledFlag == True:
            self.planetNamesEnabled.append("H12")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetARMCEnabledFlag == True:
            self.planetNamesEnabled.append("ARMC")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetVertexEnabledFlag == True:
            self.planetNamesEnabled.append("Vertex")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetEquatorialAscendantEnabledFlag == True:
            self.planetNamesEnabled.append("EquatorialAscendant")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetCoAscendant1EnabledFlag == True:
            self.planetNamesEnabled.append("CoAscendant1")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetCoAscendant2EnabledFlag == True:
            self.planetNamesEnabled.append("CoAscendant2")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetPolarAscendantEnabledFlag == True:
            self.planetNamesEnabled.append("PolarAscendant")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetHoraLagnaEnabledFlag == True:
            self.planetNamesEnabled.append("HoraLagna")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetGhatiLagnaEnabledFlag == True:
            self.planetNamesEnabled.append("GhatiLagna")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeanLunarApogeeEnabledFlag == True:
            self.planetNamesEnabled.append("MeanLunarApogee")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetOsculatingLunarApogeeEnabledFlag == True:
            self.planetNamesEnabled.append("OsculatingLunarApogee")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetInterpolatedLunarApogeeEnabledFlag == True:
            self.planetNamesEnabled.append("InterpolatedLunarApogee")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetInterpolatedLunarPerigeeEnabledFlag == True:
            self.planetNamesEnabled.append("InterpolatedLunarPerigee")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetSunEnabledFlag == True:
            self.planetNamesEnabled.append("Sun")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMoonEnabledFlag == True:
            self.planetNamesEnabled.append("Moon")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMercuryEnabledFlag == True:
            self.planetNamesEnabled.append("Mercury")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetVenusEnabledFlag == True:
            self.planetNamesEnabled.append("Venus")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetEarthEnabledFlag == True:
            self.planetNamesEnabled.append("Earth")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMarsEnabledFlag == True:
            self.planetNamesEnabled.append("Mars")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetJupiterEnabledFlag == True:
            self.planetNamesEnabled.append("Jupiter")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetSaturnEnabledFlag == True:
            self.planetNamesEnabled.append("Saturn")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetUranusEnabledFlag == True:
            self.planetNamesEnabled.append("Uranus")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetNeptuneEnabledFlag == True:
            self.planetNamesEnabled.append("Neptune")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetPlutoEnabledFlag == True:
            self.planetNamesEnabled.append("Pluto")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeanNorthNodeEnabledFlag == True:
            self.planetNamesEnabled.append("MeanNorthNode")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeanSouthNodeEnabledFlag == True:
            self.planetNamesEnabled.append("MeanSouthNode")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetTrueNorthNodeEnabledFlag == True:
            self.planetNamesEnabled.append("TrueNorthNode")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetTrueSouthNodeEnabledFlag == True:
            self.planetNamesEnabled.append("TrueSouthNode")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetCeresEnabledFlag == True:
            self.planetNamesEnabled.append("Ceres")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetPallasEnabledFlag == True:
            self.planetNamesEnabled.append("Pallas")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetJunoEnabledFlag == True:
            self.planetNamesEnabled.append("Juno")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetVestaEnabledFlag == True:
            self.planetNamesEnabled.append("Vesta")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetIsisEnabledFlag == True:
            self.planetNamesEnabled.append("Isis")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetNibiruEnabledFlag == True:
            self.planetNamesEnabled.append("Nibiru")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetChironEnabledFlag == True:
            self.planetNamesEnabled.append("Chiron")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetGulikaEnabledFlag == True:
            self.planetNamesEnabled.append("Gulika")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMandiEnabledFlag == True:
            self.planetNamesEnabled.append("Mandi")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeanOfFiveEnabledFlag == True:
            self.planetNamesEnabled.append("MeanOfFive")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetCycleOfEightEnabledFlag == True:
            self.planetNamesEnabled.append("CycleOfEight")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetAvgMaJuSaUrNePlEnabledFlag == True:
            self.planetNamesEnabled.append("AvgMaJuSaUrNePl")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetAvgJuSaUrNeEnabledFlag == True:
            self.planetNamesEnabled.append("AvgJuSaUrNe")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetAvgJuSaEnabledFlag == True:
            self.planetNamesEnabled.append("AvgJuSa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetAsSuEnabledFlag == True:
            self.planetNamesEnabled.append("AsSu")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetAsMoEnabledFlag == True:
            self.planetNamesEnabled.append("AsMo")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMoSuEnabledFlag == True:
            self.planetNamesEnabled.append("MoSu")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeVeEnabledFlag == True:
            self.planetNamesEnabled.append("MeVe")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeEaEnabledFlag == True:
            self.planetNamesEnabled.append("MeEa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeMaEnabledFlag == True:
            self.planetNamesEnabled.append("MeMa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeJuEnabledFlag == True:
            self.planetNamesEnabled.append("MeJu")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeSaEnabledFlag == True:
            self.planetNamesEnabled.append("MeSa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMeUrEnabledFlag == True:
            self.planetNamesEnabled.append("MeUr")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetVeEaEnabledFlag == True:
            self.planetNamesEnabled.append("VeEa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetVeMaEnabledFlag == True:
            self.planetNamesEnabled.append("VeMa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetVeJuEnabledFlag == True:
            self.planetNamesEnabled.append("VeJu")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetVeSaEnabledFlag == True:
            self.planetNamesEnabled.append("VeSa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetVeUrEnabledFlag == True:
            self.planetNamesEnabled.append("VeUr")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetEaMaEnabledFlag == True:
            self.planetNamesEnabled.append("EaMa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetEaJuEnabledFlag == True:
            self.planetNamesEnabled.append("EaJu")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetEaSaEnabledFlag == True:
            self.planetNamesEnabled.append("EaSa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetEaUrEnabledFlag == True:
            self.planetNamesEnabled.append("EaUr")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMaJuEnabledFlag == True:
            self.planetNamesEnabled.append("MaJu")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMaSaEnabledFlag == True:
            self.planetNamesEnabled.append("MaSa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetMaUrEnabledFlag == True:
            self.planetNamesEnabled.append("MaUr")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetJuSaEnabledFlag == True:
            self.planetNamesEnabled.append("JuSa")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetJuUrEnabledFlag == True:
            self.planetNamesEnabled.append("JuUr")
        if PriceBarChartSettings.\
               defaultPlanetLongitudeMovementMeasurementGraphicsItemPlanetSaUrEnabledFlag == True:
            self.planetNamesEnabled.append("SaUr")
        
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartPlanetLongitudeMovementMeasurementArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.planetLongitudeMovementMeasurementPenWidth = 0.0
        self.planetLongitudeMovementMeasurementPen = QPen()
        self.planetLongitudeMovementMeasurementPen.\
            setColor(self.planetLongitudeMovementMeasurementGraphicsItemColor)
        self.planetLongitudeMovementMeasurementPen.\
            setWidthF(self.planetLongitudeMovementMeasurementPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)
        
        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)
        
        # Internal QGraphicsItem that holds the text of the measurement.
        # Initialize to blank and set at the end point.
        self.textItem = QGraphicsSimpleTextItem("", self)
        self.textItem.setPos(self.endPointF)
        
        # Transform object applied to the text item.
        self.textTransform = QTransform()
        
        # Set the text item with the properties we want it to have.
        self.reApplyTextItemAttributes(self.textItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def reApplyTextItemAttributes(self, textItem):
        """Takes the given text item and reapplies the pen, brush,
        transform, etc. that should be set for the text item.
        """

        # Set properties of the text item.
        
        # Set the font of the text.
        textItem.setFont(self.planetLongitudeMovementMeasurementTextFont)
        
        # Set the pen color of the text.
        self.planetLongitudeMovementMeasurementTextPen = textItem.pen()
        self.planetLongitudeMovementMeasurementTextPen.\
            setColor(self.planetLongitudeMovementMeasurementGraphicsItemTextColor)
            
        textItem.setPen(self.planetLongitudeMovementMeasurementTextPen)

        # Set the brush color of the text.
        self.planetLongitudeMovementMeasurementTextBrush = textItem.brush()
        self.planetLongitudeMovementMeasurementTextBrush.\
            setColor(self.planetLongitudeMovementMeasurementGraphicsItemTextColor)
            
        textItem.setBrush(self.planetLongitudeMovementMeasurementTextBrush)

        # Apply some size scaling to the text.
        self.textTransform = QTransform()
        self.textTransform.scale(\
            self.planetLongitudeMovementMeasurementTextXScaling, \
            self.planetLongitudeMovementMeasurementTextYScaling)
        self.textTransform.rotate(\
            self.planetLongitudeMovementMeasurementGraphicsItemTextRotationAngle)
        textItem.setTransform(self.textTransform)
        
    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag

        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Height of the vertical bar drawn.
        self.planetLongitudeMovementMeasurementGraphicsItemBarHeight = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemBarHeight 
 
        # Text rotation angle, in degrees (float).
        self.planetLongitudeMovementMeasurementGraphicsItemTextRotationAngle = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemTextRotationAngle
 
        # X scaling of the text.
        self.planetLongitudeMovementMeasurementTextXScaling = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.planetLongitudeMovementMeasurementTextYScaling = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemTextYScaling 

        # Font.
        self.planetLongitudeMovementMeasurementTextFont = QFont()
        self.planetLongitudeMovementMeasurementTextFont.fromString(\
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.planetLongitudeMovementMeasurementGraphicsItemTextColor = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemDefaultTextColor

        # Color of the item.
        self.planetLongitudeMovementMeasurementGraphicsItemColor = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemDefaultColor

        # Flag for measuring planet geocentric longitude movement,
        # where retrograde movements count as zero.
        self.showGeocentricRetroAsZeroTextFlag = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemShowGeocentricRetroAsZeroTextFlag
        
        # Flag for measuring planet geocentric longitude movement,
        # where retrograde movements count as positive values.
        self.showGeocentricRetroAsPositiveTextFlag = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemShowGeocentricRetroAsPositiveTextFlag
        
        # Flag for measuring planet geocentric longitude movement,
        # where retrograde movements count as negative values.
        self.showGeocentricRetroAsNegativeTextFlag = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemShowGeocentricRetroAsNegativeTextFlag
        
        # Flag for measuring planet heliocentric longitude movement.
        self.showHeliocentricTextFlag = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemShowHeliocentricTextFlag
        
        # Flag for using the tropical zodiac in measurements.
        self.tropicalZodiacFlag = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemTropicalZodiacFlag
        
        # Flag for using the sidereal zodiac in measurements.
        self.siderealZodiacFlag = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemSiderealZodiacFlag
        
        # Flag for displaying measurements in degrees.
        self.measurementUnitDegreesEnabled = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemMeasurementUnitDegreesEnabled
        
        # Flag for displaying measurements in number of circles.
        self.measurementUnitCirclesEnabled = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemMeasurementUnitCirclesEnabled

        # Flag for displaying measurements in number of biblical circles.
        self.measurementUnitBiblicalCirclesEnabled = \
            priceBarChartSettings.\
            planetLongitudeMovementMeasurementGraphicsItemMeasurementUnitBiblicalCirclesEnabled

        # Remove contents of the list and retrieve the list of enabled
        # planets from priceBarChartSettings.
        del self.planetNamesEnabled[:]
        
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH1EnabledFlag == True:
            self.planetNamesEnabled.append("H1")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH2EnabledFlag == True:
            self.planetNamesEnabled.append("H2")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH3EnabledFlag == True:
            self.planetNamesEnabled.append("H3")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH4EnabledFlag == True:
            self.planetNamesEnabled.append("H4")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH5EnabledFlag == True:
            self.planetNamesEnabled.append("H5")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH6EnabledFlag == True:
            self.planetNamesEnabled.append("H6")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH7EnabledFlag == True:
            self.planetNamesEnabled.append("H7")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH8EnabledFlag == True:
            self.planetNamesEnabled.append("H8")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH9EnabledFlag == True:
            self.planetNamesEnabled.append("H9")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH10EnabledFlag == True:
            self.planetNamesEnabled.append("H10")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH11EnabledFlag == True:
            self.planetNamesEnabled.append("H11")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetH12EnabledFlag == True:
            self.planetNamesEnabled.append("H12")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetARMCEnabledFlag == True:
            self.planetNamesEnabled.append("ARMC")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetVertexEnabledFlag == True:
            self.planetNamesEnabled.append("Vertex")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetEquatorialAscendantEnabledFlag == True:
            self.planetNamesEnabled.append("EquatorialAscendant")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetCoAscendant1EnabledFlag == True:
            self.planetNamesEnabled.append("CoAscendant1")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetCoAscendant2EnabledFlag == True:
            self.planetNamesEnabled.append("CoAscendant2")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetPolarAscendantEnabledFlag == True:
            self.planetNamesEnabled.append("PolarAscendant")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetHoraLagnaEnabledFlag == True:
            self.planetNamesEnabled.append("HoraLagna")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetGhatiLagnaEnabledFlag == True:
            self.planetNamesEnabled.append("GhatiLagna")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeanLunarApogeeEnabledFlag == True:
            self.planetNamesEnabled.append("MeanLunarApogee")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetOsculatingLunarApogeeEnabledFlag == True:
            self.planetNamesEnabled.append("OsculatingLunarApogee")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetInterpolatedLunarApogeeEnabledFlag == True:
            self.planetNamesEnabled.append("InterpolatedLunarApogee")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetInterpolatedLunarPerigeeEnabledFlag == True:
            self.planetNamesEnabled.append("InterpolatedLunarPerigee")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetSunEnabledFlag == True:
            self.planetNamesEnabled.append("Sun")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMoonEnabledFlag == True:
            self.planetNamesEnabled.append("Moon")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMercuryEnabledFlag == True:
            self.planetNamesEnabled.append("Mercury")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetVenusEnabledFlag == True:
            self.planetNamesEnabled.append("Venus")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetEarthEnabledFlag == True:
            self.planetNamesEnabled.append("Earth")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMarsEnabledFlag == True:
            self.planetNamesEnabled.append("Mars")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetJupiterEnabledFlag == True:
            self.planetNamesEnabled.append("Jupiter")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetSaturnEnabledFlag == True:
            self.planetNamesEnabled.append("Saturn")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetUranusEnabledFlag == True:
            self.planetNamesEnabled.append("Uranus")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetNeptuneEnabledFlag == True:
            self.planetNamesEnabled.append("Neptune")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetPlutoEnabledFlag == True:
            self.planetNamesEnabled.append("Pluto")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeanNorthNodeEnabledFlag == True:
            self.planetNamesEnabled.append("MeanNorthNode")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeanSouthNodeEnabledFlag == True:
            self.planetNamesEnabled.append("MeanSouthNode")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetTrueNorthNodeEnabledFlag == True:
            self.planetNamesEnabled.append("TrueNorthNode")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetTrueSouthNodeEnabledFlag == True:
            self.planetNamesEnabled.append("TrueSouthNode")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetCeresEnabledFlag == True:
            self.planetNamesEnabled.append("Ceres")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetPallasEnabledFlag == True:
            self.planetNamesEnabled.append("Pallas")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetJunoEnabledFlag == True:
            self.planetNamesEnabled.append("Juno")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetVestaEnabledFlag == True:
            self.planetNamesEnabled.append("Vesta")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetIsisEnabledFlag == True:
            self.planetNamesEnabled.append("Isis")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetNibiruEnabledFlag == True:
            self.planetNamesEnabled.append("Nibiru")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetChironEnabledFlag == True:
            self.planetNamesEnabled.append("Chiron")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetGulikaEnabledFlag == True:
            self.planetNamesEnabled.append("Gulika")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMandiEnabledFlag == True:
            self.planetNamesEnabled.append("Mandi")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeanOfFiveEnabledFlag == True:
            self.planetNamesEnabled.append("MeanOfFive")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetCycleOfEightEnabledFlag == True:
            self.planetNamesEnabled.append("CycleOfEight")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetAvgMaJuSaUrNePlEnabledFlag == True:
            self.planetNamesEnabled.append("AvgMaJuSaUrNePl")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetAvgJuSaUrNeEnabledFlag == True:
            self.planetNamesEnabled.append("AvgJuSaUrNe")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetAvgJuSaEnabledFlag == True:
            self.planetNamesEnabled.append("AvgJuSa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetAsSuEnabledFlag == True:
            self.planetNamesEnabled.append("AsSu")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetAsMoEnabledFlag == True:
            self.planetNamesEnabled.append("AsMo")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMoSuEnabledFlag == True:
            self.planetNamesEnabled.append("MoSu")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeVeEnabledFlag == True:
            self.planetNamesEnabled.append("MeVe")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeEaEnabledFlag == True:
            self.planetNamesEnabled.append("MeEa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeMaEnabledFlag == True:
            self.planetNamesEnabled.append("MeMa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeJuEnabledFlag == True:
            self.planetNamesEnabled.append("MeJu")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeSaEnabledFlag == True:
            self.planetNamesEnabled.append("MeSa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMeUrEnabledFlag == True:
            self.planetNamesEnabled.append("MeUr")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetVeEaEnabledFlag == True:
            self.planetNamesEnabled.append("VeEa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetVeMaEnabledFlag == True:
            self.planetNamesEnabled.append("VeMa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetVeJuEnabledFlag == True:
            self.planetNamesEnabled.append("VeJu")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetVeSaEnabledFlag == True:
            self.planetNamesEnabled.append("VeSa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetVeUrEnabledFlag == True:
            self.planetNamesEnabled.append("VeUr")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetEaMaEnabledFlag == True:
            self.planetNamesEnabled.append("EaMa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetEaJuEnabledFlag == True:
            self.planetNamesEnabled.append("EaJu")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetEaSaEnabledFlag == True:
            self.planetNamesEnabled.append("EaSa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetEaUrEnabledFlag == True:
            self.planetNamesEnabled.append("EaUr")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMaJuEnabledFlag == True:
            self.planetNamesEnabled.append("MaJu")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMaSaEnabledFlag == True:
            self.planetNamesEnabled.append("MaSa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetMaUrEnabledFlag == True:
            self.planetNamesEnabled.append("MaUr")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetJuSaEnabledFlag == True:
            self.planetNamesEnabled.append("JuSa")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetJuUrEnabledFlag == True:
            self.planetNamesEnabled.append("JuUr")
        if priceBarChartSettings.\
               planetLongitudeMovementMeasurementGraphicsItemPlanetSaUrEnabledFlag == True:
            self.planetNamesEnabled.append("SaUr")
        
        ####################################################################

        # Update the text item with the new settings.
        self.reApplyTextItemAttributes(self.textItem)

        # Update the planetLongitudeMovementMeasurement text item position.
        self._updateTextItemPositions()
        
        # Set the new color of the pen for drawing the bar.
        self.planetLongitudeMovementMeasurementPen.\
            setColor(self.planetLongitudeMovementMeasurementGraphicsItemColor)
        
        # Schedule an update.
        self.prepareGeometryChange()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculatePlanetLongitudeMovementMeasurement()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)
            
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def _updateTextItemPositions(self):
        """Updates the location of the internal text items based on
        where the start and end points are.
        """
        
        # Update the planetLongitudeMovementMeasurement label position.
        
        # Changes in x and y.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()
        
        # Get bounding rectangle of text item.
        boundingRect = self.textItem.boundingRect()

        # Find largest text height and width.
        largestTextHeight = boundingRect.height()
        largestTextWidth = boundingRect.width()

        # Now replace the above with the scaled version of it. 
        largestTextHeight = largestTextHeight * self.textTransform.m22()
        largestTextWidth = largestTextWidth * self.textTransform.m11()

        self.log.debug("largestTextHeight = {}".format(largestTextHeight))
        self.log.debug("largestTextWidth = {}".format(largestTextWidth))
        
        # Get the x and y of the point to place the text, referenced
        # on the line from start point to end point, but offset by a
        # certain amount such that the largest text would be centered
        # on the line.
        midX = self.mapFromScene(\
            QPointF(self.startPointF.x() + (deltaX * 0.5), 0.0)).x()
        midY = self.mapFromScene(\
            QPointF(0.0, self.startPointF.y() + (deltaY * 0.5))).y()

        self.log.debug("midX={}, midY={}".format(midX, midY))
                       
        startX = midX
        startY = midY

        # Amount to mutiply to get a largest offset from startY.
        offsetY = largestTextHeight
        offsetX = (largestTextWidth / 2.0)
        
        x = startX - offsetX
        y = startY - offsetY
        
        self.textItem.setPos(QPointF(x, y))
                    
    def setStartPointF(self, pointF):
        """Sets the starting point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        x = pointF.x()

        newValue = QPointF(x, self.endPointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            # Update the planetLongitudeMovementMeasurement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the timemeasurement.
                self.recalculatePlanetLongitudeMovementMeasurement()
                self.prepareGeometryChange()
                
    def setEndPointF(self, pointF):
        """Sets the ending point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        x = pointF.x()

        newValue = QPointF(x, self.startPointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            # Update the planetLongitudeMovementMeasurement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the timemeasurement.
                self.recalculatePlanetLongitudeMovementMeasurement()
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        if self.startPointF.x() > self.endPointF.x():
            self.log.debug("Normalization of PlanetLongitudeMovementMeasurementGraphicsItem " +
                           "required.")
            
            # Swap the points.
            temp = self.startPointF
            self.startPointF = self.endPointF
            self.endPointF = temp

            self.recalculatePlanetLongitudeMovementMeasurement()
            
            # Update the planetLongitudeMovementMeasurement text item position.
            self._updateTextItemPositions()
            
            super().setPos(self.startPointF)
            

    def recalculatePlanetLongitudeMovementMeasurement(self):
        """Does calculations to determine the planetary measurements
        between the start and end points.
        """

        scene = self.scene()

        # maxErrorTd - datetime.timedelta object holding the maximum
        #              time difference between the exact planetary
        #              timestamp for the phenomena, and the one
        #              calculated.  This would define the accuracy of
        #              the calculations.
        #
        # TODO: Perhaps I should put this setting into QSettings?
        maxErrorTd = datetime.timedelta(minutes=1)

        # Text to set in the text item.
        text = ""

        if scene != None:
            # Determine the start and end timestamps from the
            # start and end points.
            startTimestamp = \
                scene.sceneXPosToDatetime(self.startPointF.x())
            
            timestampStr = Ephemeris.datetimeToDayStr(startTimestamp)
            if self.log.isEnabledFor(logging.DEBUG) == True:
                self.log.debug("startTimestamp: " + timestampStr)
            
            endTimestamp = \
                scene.sceneXPosToDatetime(self.endPointF.x())
            
            timestampStr = Ephemeris.datetimeToDayStr(endTimestamp)
            if self.log.isEnabledFor(logging.DEBUG) == True:
                self.log.debug("endTimestamp: " + timestampStr)

            # If startTimestamp is after endTimestamp, then swap their
            # values.  This can happen if the person is measuring
            # 'backwards' from the future towards the past.  We have
            # to swap the values or else some of the measurements
            # would be totally invalid (due to how we subtract and
            # normalize to get elapsed longitude).
            if startTimestamp > endTimestamp:
                temp = startTimestamp
                startTimestamp = endTimestamp
                endTimestamp = temp
            
            # Set the birth location in the Ephemeris.
            # We need to set this each time because there is no
            # guarantee that the last use of the Ephemeris was with
            # this location.
            birthInfo = scene.getBirthInfo()
            Ephemeris.setGeographicPosition(birthInfo.longitudeDegrees,
                                            birthInfo.latitudeDegrees,
                                            birthInfo.elevation)
            
            # Based on what kind of options are selected, compute and
            # make measurements of the planet(s) movement.

            listOfTuples = []
            
            for planetName in self.planetNamesEnabled:
                
                # If the start and end timestamps are the same, then
                # don't do any calculations.
                if startTimestamp == endTimestamp:
                    break

                # If at least one of the zodiacs are not selected,
                # then don't do any calculations.
                if self.tropicalZodiacFlag == False and \
                   self.siderealZodiacFlag == False:
                    break
                
                # If there are no measurement unit types specified,
                # then don't do calculations for any planets.
                if self.measurementUnitDegreesEnabled == False and \
                   self.measurementUnitCirclesEnabled == False and \
                   self.measurementUnitBiblicalCirclesEnabled == False:
                    break

                # Assemble a tuple of arguments to pass to the
                # multiprocessing parallel calculation.
                argsTuple = (planetName,
                             startTimestamp,
                             endTimestamp,
                             self.showGeocentricRetroAsZeroTextFlag,
                             self.showGeocentricRetroAsPositiveTextFlag,
                             self.showGeocentricRetroAsNegativeTextFlag,
                             self.showHeliocentricTextFlag,
                             self.tropicalZodiacFlag,
                             self.siderealZodiacFlag,
                             self.measurementUnitDegreesEnabled,
                             self.measurementUnitCirclesEnabled,
                             self.measurementUnitBiblicalCirclesEnabled,
                             maxErrorTd,
                             birthInfo.longitudeDegrees,
                             birthInfo.latitudeDegrees,
                             birthInfo.elevation)

                listOfTuples.append(argsTuple)

            # If there are measurements to make and process, then ago ahead and
            # do them in parallel.
            if len(listOfTuples) > 0:
                text = PlanetLongitudeMovementMeasurementParallel.getPlanetLongitudeMovementMeasurementText(listOfTuples)
            else:
                text = ""
                
        self.textItem.setText(text)
        
    def setArtifact(self, artifact):
        """Loads a given
        PriceBarChartPlanetLongitudeMovementMeasurementArtifact
        object's data into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartPlanetLongitudeMovementMeasurementArtifact
                   object with information about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartPlanetLongitudeMovementMeasurementArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartPlanetLongitudeMovementMeasurementArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)
        
        self.planetLongitudeMovementMeasurementTextXScaling = self.artifact.getTextXScaling()
        self.planetLongitudeMovementMeasurementTextYScaling = self.artifact.getTextYScaling()
        self.planetLongitudeMovementMeasurementTextFont = self.artifact.getFont()
        self.planetLongitudeMovementMeasurementGraphicsItemTextColor = self.artifact.getTextColor()
        self.planetLongitudeMovementMeasurementPen.setColor(self.artifact.getColor())
        
        self.planetLongitudeMovementMeasurementGraphicsItemBarHeight = \
            self.artifact.getBarHeight()
        self.planetLongitudeMovementMeasurementGraphicsItemTextRotationAngle = \
            self.artifact.getTextRotationAngle()

        self.showGeocentricRetroAsZeroTextFlag = \
            self.artifact.getGeocentricRetroAsZeroTextFlag()
        self.showGeocentricRetroAsPositiveTextFlag = \
            self.artifact.getGeocentricRetroAsPositiveTextFlag()
        self.showGeocentricRetroAsNegativeTextFlag = \
            self.artifact.getGeocentricRetroAsNegativeTextFlag()
        self.showHeliocentricTextFlag = \
            self.artifact.getHeliocentricTextFlag()
        self.tropicalZodiacFlag = \
            self.artifact.getTropicalZodiacFlag()
        self.siderealZodiacFlag = \
            self.artifact.getSiderealZodiacFlag()
        self.measurementUnitDegreesEnabled = \
            self.artifact.getMeasurementUnitDegreesEnabled()
        self.measurementUnitCirclesEnabled = \
            self.artifact.getMeasurementUnitCirclesEnabled()
        self.measurementUnitBiblicalCirclesEnabled = \
            self.artifact.getMeasurementUnitBiblicalCirclesEnabled()
        
        # Remove contents of the list and retrieve the list of enabled
        # planets from priceBarChartSettings.
        del self.planetNamesEnabled[:]
        
        if self.artifact.getPlanetH1EnabledFlag():
            self.planetNamesEnabled.append("H1")
        if self.artifact.getPlanetH2EnabledFlag():
            self.planetNamesEnabled.append("H2")
        if self.artifact.getPlanetH3EnabledFlag():
            self.planetNamesEnabled.append("H3")
        if self.artifact.getPlanetH4EnabledFlag():
            self.planetNamesEnabled.append("H4")
        if self.artifact.getPlanetH5EnabledFlag():
            self.planetNamesEnabled.append("H5")
        if self.artifact.getPlanetH6EnabledFlag():
            self.planetNamesEnabled.append("H6")
        if self.artifact.getPlanetH7EnabledFlag():
            self.planetNamesEnabled.append("H7")
        if self.artifact.getPlanetH8EnabledFlag():
            self.planetNamesEnabled.append("H8")
        if self.artifact.getPlanetH9EnabledFlag():
            self.planetNamesEnabled.append("H9")
        if self.artifact.getPlanetH10EnabledFlag():
            self.planetNamesEnabled.append("H10")
        if self.artifact.getPlanetH11EnabledFlag():
            self.planetNamesEnabled.append("H11")
        if self.artifact.getPlanetH12EnabledFlag():
            self.planetNamesEnabled.append("H12")
        if self.artifact.getPlanetARMCEnabledFlag():
            self.planetNamesEnabled.append("ARMC")
        if self.artifact.getPlanetVertexEnabledFlag():
            self.planetNamesEnabled.append("Vertex")
        if self.artifact.getPlanetEquatorialAscendantEnabledFlag():
            self.planetNamesEnabled.append("EquatorialAscendant")
        if self.artifact.getPlanetCoAscendant1EnabledFlag():
            self.planetNamesEnabled.append("CoAscendant1")
        if self.artifact.getPlanetCoAscendant2EnabledFlag():
            self.planetNamesEnabled.append("CoAscendant2")
        if self.artifact.getPlanetPolarAscendantEnabledFlag():
            self.planetNamesEnabled.append("PolarAscendant")
        if self.artifact.getPlanetHoraLagnaEnabledFlag():
            self.planetNamesEnabled.append("HoraLagna")
        if self.artifact.getPlanetGhatiLagnaEnabledFlag():
            self.planetNamesEnabled.append("GhatiLagna")
        if self.artifact.getPlanetMeanLunarApogeeEnabledFlag():
            self.planetNamesEnabled.append("MeanLunarApogee")
        if self.artifact.getPlanetOsculatingLunarApogeeEnabledFlag():
            self.planetNamesEnabled.append("OsculatingLunarApogee")
        if self.artifact.getPlanetInterpolatedLunarApogeeEnabledFlag():
            self.planetNamesEnabled.append("InterpolatedLunarApogee")
        if self.artifact.getPlanetInterpolatedLunarPerigeeEnabledFlag():
            self.planetNamesEnabled.append("InterpolatedLunarPerigee")
        if self.artifact.getPlanetSunEnabledFlag():
            self.planetNamesEnabled.append("Sun")
        if self.artifact.getPlanetMoonEnabledFlag():
            self.planetNamesEnabled.append("Moon")
        if self.artifact.getPlanetMercuryEnabledFlag():
            self.planetNamesEnabled.append("Mercury")
        if self.artifact.getPlanetVenusEnabledFlag():
            self.planetNamesEnabled.append("Venus")
        if self.artifact.getPlanetEarthEnabledFlag():
            self.planetNamesEnabled.append("Earth")
        if self.artifact.getPlanetMarsEnabledFlag():
            self.planetNamesEnabled.append("Mars")
        if self.artifact.getPlanetJupiterEnabledFlag():
            self.planetNamesEnabled.append("Jupiter")
        if self.artifact.getPlanetSaturnEnabledFlag():
            self.planetNamesEnabled.append("Saturn")
        if self.artifact.getPlanetUranusEnabledFlag():
            self.planetNamesEnabled.append("Uranus")
        if self.artifact.getPlanetNeptuneEnabledFlag():
            self.planetNamesEnabled.append("Neptune")
        if self.artifact.getPlanetPlutoEnabledFlag():
            self.planetNamesEnabled.append("Pluto")
        if self.artifact.getPlanetMeanNorthNodeEnabledFlag():
            self.planetNamesEnabled.append("MeanNorthNode")
        if self.artifact.getPlanetMeanSouthNodeEnabledFlag():
            self.planetNamesEnabled.append("MeanSouthNode")
        if self.artifact.getPlanetTrueNorthNodeEnabledFlag():
            self.planetNamesEnabled.append("TrueNorthNode")
        if self.artifact.getPlanetTrueSouthNodeEnabledFlag():
            self.planetNamesEnabled.append("TrueSouthNode")
        if self.artifact.getPlanetCeresEnabledFlag():
            self.planetNamesEnabled.append("Ceres")
        if self.artifact.getPlanetPallasEnabledFlag():
            self.planetNamesEnabled.append("Pallas")
        if self.artifact.getPlanetJunoEnabledFlag():
            self.planetNamesEnabled.append("Juno")
        if self.artifact.getPlanetVestaEnabledFlag():
            self.planetNamesEnabled.append("Vesta")
        if self.artifact.getPlanetIsisEnabledFlag():
            self.planetNamesEnabled.append("Isis")
        if self.artifact.getPlanetNibiruEnabledFlag():
            self.planetNamesEnabled.append("Nibiru")
        if self.artifact.getPlanetChironEnabledFlag():
            self.planetNamesEnabled.append("Chiron")
        if self.artifact.getPlanetGulikaEnabledFlag():
            self.planetNamesEnabled.append("Gulika")
        if self.artifact.getPlanetMandiEnabledFlag():
            self.planetNamesEnabled.append("Mandi")
        if self.artifact.getPlanetMeanOfFiveEnabledFlag():
            self.planetNamesEnabled.append("MeanOfFive")
        if self.artifact.getPlanetCycleOfEightEnabledFlag():
            self.planetNamesEnabled.append("CycleOfEight")
        if self.artifact.getPlanetAvgMaJuSaUrNePlEnabledFlag():
            self.planetNamesEnabled.append("AvgMaJuSaUrNePl")
        if self.artifact.getPlanetAvgJuSaUrNeEnabledFlag():
            self.planetNamesEnabled.append("AvgJuSaUrNe")
        if self.artifact.getPlanetAvgJuSaEnabledFlag():
            self.planetNamesEnabled.append("AvgJuSa")
        if self.artifact.getPlanetAsSuEnabledFlag():
            self.planetNamesEnabled.append("AsSu")
        if self.artifact.getPlanetAsMoEnabledFlag():
            self.planetNamesEnabled.append("AsMo")
        if self.artifact.getPlanetMoSuEnabledFlag():
            self.planetNamesEnabled.append("MoSu")
        if self.artifact.getPlanetMeVeEnabledFlag():
            self.planetNamesEnabled.append("MeVe")
        if self.artifact.getPlanetMeEaEnabledFlag():
            self.planetNamesEnabled.append("MeEa")
        if self.artifact.getPlanetMeMaEnabledFlag():
            self.planetNamesEnabled.append("MeMa")
        if self.artifact.getPlanetMeJuEnabledFlag():
            self.planetNamesEnabled.append("MeJu")
        if self.artifact.getPlanetMeSaEnabledFlag():
            self.planetNamesEnabled.append("MeSa")
        if self.artifact.getPlanetMeUrEnabledFlag():
            self.planetNamesEnabled.append("MeUr")
        if self.artifact.getPlanetVeEaEnabledFlag():
            self.planetNamesEnabled.append("VeEa")
        if self.artifact.getPlanetVeMaEnabledFlag():
            self.planetNamesEnabled.append("VeMa")
        if self.artifact.getPlanetVeJuEnabledFlag():
            self.planetNamesEnabled.append("VeJu")
        if self.artifact.getPlanetVeSaEnabledFlag():
            self.planetNamesEnabled.append("VeSa")
        if self.artifact.getPlanetVeUrEnabledFlag():
            self.planetNamesEnabled.append("VeUr")
        if self.artifact.getPlanetEaMaEnabledFlag():
            self.planetNamesEnabled.append("EaMa")
        if self.artifact.getPlanetEaJuEnabledFlag():
            self.planetNamesEnabled.append("EaJu")
        if self.artifact.getPlanetEaSaEnabledFlag():
            self.planetNamesEnabled.append("EaSa")
        if self.artifact.getPlanetEaUrEnabledFlag():
            self.planetNamesEnabled.append("EaUr")
        if self.artifact.getPlanetMaJuEnabledFlag():
            self.planetNamesEnabled.append("MaJu")
        if self.artifact.getPlanetMaSaEnabledFlag():
            self.planetNamesEnabled.append("MaSa")
        if self.artifact.getPlanetMaUrEnabledFlag():
            self.planetNamesEnabled.append("MaUr")
        if self.artifact.getPlanetJuSaEnabledFlag():
            self.planetNamesEnabled.append("JuSa")
        if self.artifact.getPlanetJuUrEnabledFlag():
            self.planetNamesEnabled.append("JuUr")
        if self.artifact.getPlanetSaUrEnabledFlag():
            self.planetNamesEnabled.append("SaUr")

        #############

        # Update all the text item with the new settings.
        self.reApplyTextItemAttributes(self.textItem)

        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the time measurements will be zero, since it
        # can't look up PriceBarGraphicsItems in the scene.
        self.recalculatePlanetLongitudeMovementMeasurement()
        
        # Update the planetLongitudeMovementMeasurement text item position.
        self._updateTextItemPositions()
        
        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartPlanetLongitudeMovementMeasurementArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartPlanetLongitudeMovementMeasurementArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        self.artifact.setTextXScaling(self.planetLongitudeMovementMeasurementTextXScaling)
        self.artifact.setTextYScaling(self.planetLongitudeMovementMeasurementTextYScaling)
        self.artifact.setFont(self.planetLongitudeMovementMeasurementTextFont)
        self.artifact.setTextColor(self.planetLongitudeMovementMeasurementGraphicsItemTextColor)
        self.artifact.setColor(self.planetLongitudeMovementMeasurementPen.color())

        self.artifact.setBarHeight(\
            self.planetLongitudeMovementMeasurementGraphicsItemBarHeight)
        self.artifact.setTextRotationAngle(\
            self.planetLongitudeMovementMeasurementGraphicsItemTextRotationAngle)

        self.artifact.setGeocentricRetroAsZeroTextFlag(\
            self.showGeocentricRetroAsZeroTextFlag)
        self.artifact.setGeocentricRetroAsPositiveTextFlag(\
            self.showGeocentricRetroAsPositiveTextFlag)
        self.artifact.setGeocentricRetroAsNegativeTextFlag(\
            self.showGeocentricRetroAsNegativeTextFlag)
        self.artifact.setHeliocentricTextFlag(\
            self.showHeliocentricTextFlag)
        self.artifact.setTropicalZodiacFlag(\
            self.tropicalZodiacFlag)
        self.artifact.setSiderealZodiacFlag(\
            self.siderealZodiacFlag)
        self.artifact.setMeasurementUnitDegreesEnabled(\
            self.measurementUnitDegreesEnabled)
        self.artifact.setMeasurementUnitCirclesEnabled(\
            self.measurementUnitCirclesEnabled)
        self.artifact.setMeasurementUnitBiblicalCirclesEnabled(\
            self.measurementUnitBiblicalCirclesEnabled)
        
        self.artifact.setPlanetH1EnabledFlag(\
            "H1" in self.planetNamesEnabled)
        self.artifact.setPlanetH2EnabledFlag(\
            "H2" in self.planetNamesEnabled)
        self.artifact.setPlanetH3EnabledFlag(\
            "H3" in self.planetNamesEnabled)
        self.artifact.setPlanetH4EnabledFlag(\
            "H4" in self.planetNamesEnabled)
        self.artifact.setPlanetH5EnabledFlag(\
            "H5" in self.planetNamesEnabled)
        self.artifact.setPlanetH6EnabledFlag(\
            "H6" in self.planetNamesEnabled)
        self.artifact.setPlanetH7EnabledFlag(\
            "H7" in self.planetNamesEnabled)
        self.artifact.setPlanetH8EnabledFlag(\
            "H8" in self.planetNamesEnabled)
        self.artifact.setPlanetH9EnabledFlag(\
            "H9" in self.planetNamesEnabled)
        self.artifact.setPlanetH10EnabledFlag(\
            "H10" in self.planetNamesEnabled)
        self.artifact.setPlanetH11EnabledFlag(\
            "H11" in self.planetNamesEnabled)
        self.artifact.setPlanetH12EnabledFlag(\
            "H12" in self.planetNamesEnabled)
        self.artifact.setPlanetARMCEnabledFlag(\
            "ARMC" in self.planetNamesEnabled)
        self.artifact.setPlanetVertexEnabledFlag(\
            "Vertex" in self.planetNamesEnabled)
        self.artifact.setPlanetEquatorialAscendantEnabledFlag(\
            "EquatorialAscendant" in self.planetNamesEnabled)
        self.artifact.setPlanetCoAscendant1EnabledFlag(\
            "CoAscendant1" in self.planetNamesEnabled)
        self.artifact.setPlanetCoAscendant2EnabledFlag(\
            "CoAscendant2" in self.planetNamesEnabled)
        self.artifact.setPlanetPolarAscendantEnabledFlag(\
            "PolarAscendant" in self.planetNamesEnabled)
        self.artifact.setPlanetHoraLagnaEnabledFlag(\
            "HoraLagna" in self.planetNamesEnabled)
        self.artifact.setPlanetGhatiLagnaEnabledFlag(\
            "GhatiLagna" in self.planetNamesEnabled)
        self.artifact.setPlanetMeanLunarApogeeEnabledFlag(\
            "MeanLunarApogee" in self.planetNamesEnabled)
        self.artifact.setPlanetOsculatingLunarApogeeEnabledFlag(\
            "OsculatingLunarApogee" in self.planetNamesEnabled)
        self.artifact.setPlanetInterpolatedLunarApogeeEnabledFlag(\
            "InterpolatedLunarApogee" in self.planetNamesEnabled)
        self.artifact.setPlanetInterpolatedLunarPerigeeEnabledFlag(\
            "InterpolatedLunarPerigee" in self.planetNamesEnabled)
        self.artifact.setPlanetSunEnabledFlag(\
            "Sun" in self.planetNamesEnabled)
        self.artifact.setPlanetMoonEnabledFlag(\
            "Moon" in self.planetNamesEnabled)
        self.artifact.setPlanetMercuryEnabledFlag(\
            "Mercury" in self.planetNamesEnabled)
        self.artifact.setPlanetVenusEnabledFlag(\
            "Venus" in self.planetNamesEnabled)
        self.artifact.setPlanetEarthEnabledFlag(\
            "Earth" in self.planetNamesEnabled)
        self.artifact.setPlanetMarsEnabledFlag(\
            "Mars" in self.planetNamesEnabled)
        self.artifact.setPlanetJupiterEnabledFlag(\
            "Jupiter" in self.planetNamesEnabled)
        self.artifact.setPlanetSaturnEnabledFlag(\
            "Saturn" in self.planetNamesEnabled)
        self.artifact.setPlanetUranusEnabledFlag(\
            "Uranus" in self.planetNamesEnabled)
        self.artifact.setPlanetNeptuneEnabledFlag(\
            "Neptune" in self.planetNamesEnabled)
        self.artifact.setPlanetPlutoEnabledFlag(\
            "Pluto" in self.planetNamesEnabled)
        self.artifact.setPlanetMeanNorthNodeEnabledFlag(\
            "MeanNorthNode" in self.planetNamesEnabled)
        self.artifact.setPlanetMeanSouthNodeEnabledFlag(\
            "MeanSouthNode" in self.planetNamesEnabled)
        self.artifact.setPlanetTrueNorthNodeEnabledFlag(\
            "TrueNorthNode" in self.planetNamesEnabled)
        self.artifact.setPlanetTrueSouthNodeEnabledFlag(\
            "TrueSouthNode" in self.planetNamesEnabled)
        self.artifact.setPlanetCeresEnabledFlag(\
            "Ceres" in self.planetNamesEnabled)
        self.artifact.setPlanetPallasEnabledFlag(\
            "Pallas" in self.planetNamesEnabled)
        self.artifact.setPlanetJunoEnabledFlag(\
            "Juno" in self.planetNamesEnabled)
        self.artifact.setPlanetVestaEnabledFlag(\
            "Vesta" in self.planetNamesEnabled)
        self.artifact.setPlanetIsisEnabledFlag(\
            "Isis" in self.planetNamesEnabled)
        self.artifact.setPlanetNibiruEnabledFlag(\
            "Nibiru" in self.planetNamesEnabled)
        self.artifact.setPlanetChironEnabledFlag(\
            "Chiron" in self.planetNamesEnabled)
        self.artifact.setPlanetGulikaEnabledFlag(\
            "Gulika" in self.planetNamesEnabled)
        self.artifact.setPlanetMandiEnabledFlag(\
            "Mandi" in self.planetNamesEnabled)
        self.artifact.setPlanetMeanOfFiveEnabledFlag(\
            "MeanOfFive" in self.planetNamesEnabled)
        self.artifact.setPlanetCycleOfEightEnabledFlag(\
            "CycleOfEight" in self.planetNamesEnabled)
        self.artifact.setPlanetAvgMaJuSaUrNePlEnabledFlag(\
            "AvgMaJuSaUrNePl" in self.planetNamesEnabled)
        self.artifact.setPlanetAvgJuSaUrNeEnabledFlag(\
            "AvgJuSaUrNe" in self.planetNamesEnabled)
        self.artifact.setPlanetAvgJuSaEnabledFlag(\
            "AvgJuSa" in self.planetNamesEnabled)
        self.artifact.setPlanetAsSuEnabledFlag(\
            "AsSu" in self.planetNamesEnabled)
        self.artifact.setPlanetAsMoEnabledFlag(\
            "AsMo" in self.planetNamesEnabled)
        self.artifact.setPlanetMoSuEnabledFlag(\
            "MoSu" in self.planetNamesEnabled)
        self.artifact.setPlanetMeVeEnabledFlag(\
            "MeVe" in self.planetNamesEnabled)
        self.artifact.setPlanetMeEaEnabledFlag(\
            "MeEa" in self.planetNamesEnabled)
        self.artifact.setPlanetMeMaEnabledFlag(\
            "MeMa" in self.planetNamesEnabled)
        self.artifact.setPlanetMeJuEnabledFlag(\
            "MeJu" in self.planetNamesEnabled)
        self.artifact.setPlanetMeSaEnabledFlag(\
            "MeSa" in self.planetNamesEnabled)
        self.artifact.setPlanetMeUrEnabledFlag(\
            "MeUr" in self.planetNamesEnabled)
        self.artifact.setPlanetVeEaEnabledFlag(\
            "VeEa" in self.planetNamesEnabled)
        self.artifact.setPlanetVeMaEnabledFlag(\
            "VeMa" in self.planetNamesEnabled)
        self.artifact.setPlanetVeJuEnabledFlag(\
            "VeJu" in self.planetNamesEnabled)
        self.artifact.setPlanetVeSaEnabledFlag(\
            "VeSa" in self.planetNamesEnabled)
        self.artifact.setPlanetVeUrEnabledFlag(\
            "VeUr" in self.planetNamesEnabled)
        self.artifact.setPlanetEaMaEnabledFlag(\
            "EaMa" in self.planetNamesEnabled)
        self.artifact.setPlanetEaJuEnabledFlag(\
            "EaJu" in self.planetNamesEnabled)
        self.artifact.setPlanetEaSaEnabledFlag(\
            "EaSa" in self.planetNamesEnabled)
        self.artifact.setPlanetEaUrEnabledFlag(\
            "EaUr" in self.planetNamesEnabled)
        self.artifact.setPlanetMaJuEnabledFlag(\
            "MaJu" in self.planetNamesEnabled)
        self.artifact.setPlanetMaSaEnabledFlag(\
            "MaSa" in self.planetNamesEnabled)
        self.artifact.setPlanetMaUrEnabledFlag(\
            "MaUr" in self.planetNamesEnabled)
        self.artifact.setPlanetJuSaEnabledFlag(\
            "JuSa" in self.planetNamesEnabled)
        self.artifact.setPlanetJuUrEnabledFlag(\
            "JuUr" in self.planetNamesEnabled)
        self.artifact.setPlanetSaUrEnabledFlag(\
            "SaUr" in self.planetNamesEnabled)
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.

        # The QRectF returned is relative to this (0, 0) point.

        # Get the QRectF with just the lines.
        xDelta = self.endPointF.x() - self.startPointF.x()

        topLeft = \
            QPointF(0.0, -1.0 *
                    (self.planetLongitudeMovementMeasurementGraphicsItemBarHeight * 0.5))
        
        bottomRight = \
            QPointF(xDelta, 1.0 *
                    (self.planetLongitudeMovementMeasurementGraphicsItemBarHeight * 0.5))

        # Initalize to the above boundaries.  We will set them below.
        localHighY = topLeft.y()
        localLowY = bottomRight.y()
        if self.drawVerticalDottedLinesFlag or self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighestPriceBarY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()

                # Overwrite the high if it is larger.
                if localHighestPriceBarY > localHighY:
                    localHighY = localHighestPriceBarY

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowestPriceBarY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
            
                # Overwrite the low if it is smaller.
                if localLowestPriceBarY < localLowY:
                    localLowY = localLowestPriceBarY
                
        xValues = []
        xValues.append(topLeft.x())
        xValues.append(bottomRight.x())

        yValues = []
        yValues.append(topLeft.y())
        yValues.append(bottomRight.y())
        yValues.append(localHighY)
        yValues.append(localLowY)

        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Get the QRectF with just the lines.
        xDelta = self.endPointF.x() - self.startPointF.x()
        
        topLeft = \
            QPointF(0.0, -1.0 *
                    (self.planetLongitudeMovementMeasurementGraphicsItemBarHeight * 0.5))
        
        bottomRight = \
            QPointF(xDelta, 1.0 *
                    (self.planetLongitudeMovementMeasurementGraphicsItemBarHeight * 0.5))

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.planetLongitudeMovementMeasurementPen is set to what we want for the drawing
        style.
        """

        if painter.pen() != self.planetLongitudeMovementMeasurementPen:
            painter.setPen(self.planetLongitudeMovementMeasurementPen)
        
        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (self.planetLongitudeMovementMeasurementGraphicsItemBarHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (self.planetLongitudeMovementMeasurementGraphicsItemBarHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        x1 = 0.0 + xDelta
        y1 = 1.0 * (self.planetLongitudeMovementMeasurementGraphicsItemBarHeight * 0.5)
        x2 = 0.0 + xDelta
        y2 = -1.0 * (self.planetLongitudeMovementMeasurementGraphicsItemBarHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle horizontal line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = 0.0
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled tick area if the
        # flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.planetLongitudeMovementMeasurementPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                # Vertical line at the beginning.
                localPosX = 0.0
                startPoint = QPointF(localPosX, largestY)
                endPoint = QPointF(localPosX, smallestY)
                        
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
            
                # Vertical line at the end.
                localPosX = 0.0 + xDelta
                startPoint = QPointF(localPosX, largestY)
                endPoint = QPointF(localPosX, smallestY)
                        
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
        # Draw the bounding rect if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.planetLongitudeMovementMeasurementPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PlanetLongitudeMovementMeasurementGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        PlanetLongitudeMovementMeasurementGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPlanetLongitudeMovementMeasurementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPlanetLongitudeMovementMeasurementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the PlanetLongitudeMovementMeasurementGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the PlanetLongitudeMovementMeasurementGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the PlanetLongitudeMovementMeasurementGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        PlanetLongitudeMovementMeasurementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        PlanetLongitudeMovementMeasurementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the PlanetLongitudeMovementMeasurementGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the PlanetLongitudeMovementMeasurementGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the PlanetLongitudeMovementMeasurementGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        PlanetLongitudeMovementMeasurementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        PlanetLongitudeMovementMeasurementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class PriceTimeInfoGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a PriceBarChartPriceTimeInfoArtifact."""
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)
        
        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartPriceTimeInfoArtifact()

        # Convert object.
        self.convertObj = None
        
        # BirthInfo object that holds information about the birth of
        # this trading entity.  This is used so we can determine
        # amount of time elapsed since birth.
        self.birthInfo = None
        
        # Internal QGraphicsItem that holds the text of the bar count.
        # Initialize to blank and set at the end point.
        self.textItem = QGraphicsSimpleTextItem("", self)
        self.textItem.setPos(0.0, 0.0)

        # Set the font of the text.
        self.textItemFont = self.artifact.getFont()
        self.textItem.setFont(self.textItemFont)

        # Set the color of the text.
        self.color = self.artifact.getColor()
        
        # Set the pen color of the text.
        self.textItemPen = self.textItem.pen()
        self.textItemPen.setColor(self.artifact.getColor())
        self.textItem.setPen(self.textItemPen)

        # Set the brush color of the text.
        self.textItemBrush = self.textItem.brush()
        self.textItemBrush.setColor(self.artifact.getColor())
        self.textItem.setBrush(self.textItemBrush)

        # Apply some size scaling to the text.
        textTransform = QTransform()
        textTransform.scale(self.artifact.getTextXScaling(), \
                            self.artifact.getTextYScaling())
        self.textItem.setTransform(textTransform)

        # Flag that indicates that we should draw a dotted line to the
        # infoPointF.
        self.drawLineToInfoPointFFlag = False

    def setDrawLineToInfoPointFFlag(self, flag):
        """If set to true, then a line is drawn from the box to the
        infoPointF point during paint calls.  If false, then that line
        is not drawn.
        """

        self.drawLineToInfoPointFFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra line being drawn.
        self.prepareGeometryChange()
        
    def setConvertObj(self, convertObj):
        """Object for doing conversions from x and datetime and y to
        price.  This should be the graphics scene.  This is used
        because sometimes we want to be able to do conversions and
        stuff before we even add the item to the scene.
        """

        self.log.debug("Entered setConvertObj()")
        
        self.convertObj = convertObj
        
        self.log.debug("Exiting setConvertObj()")
        
    def setBirthInfo(self, birthInfo):
        """Sets the internal BirthInfo object so that time elapsed
        from birth can be calculated.
        """

        self.birthInfo = birthInfo

        # Update the text according to what's in infoPointF and birthInfo.
        self._updateText()
        self.prepareGeometryChange()
        
    def getBirthInfo(self):
        """Returns the internal BirthInfo object.
        """

        return self.birthInfo

    def setInfoPointF(self, infoPointF):
        """Sets the infoPointF used in this QGraphicsItem.  Also
        updates the artifact accordingly.
        """

        self.artifact.setInfoPointF(infoPointF)
    
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartPriceTimeInfoArtifact object's data
        into this QGraphicsPriceTimeInfoItem.

        Arguments:
        artifact - PriceBarChartPriceTimeInfoArtifact object with information
                   about this PriceTimeInfoGraphisItem
        """

        self.log.debug("Entered setArtifact()")

        if isinstance(artifact, PriceBarChartPriceTimeInfoArtifact):
            self.artifact = artifact

            self.log.debug("Setting PriceTimeInfoGraphicsItem with the " +
                           "following artifact: " + self.artifact.toString())
            self.log.debug("Font in artifact is: " +
                           self.artifact.getFont().toString())
                           
            # Extract and set the internals according to the info 
            # in self.artifact.
            self.setPos(self.artifact.getPos())

            # Update the text according to what's in infoPointF and birthInfo.
            self._updateText()
            
            # Set the font of the text.
            self.textItemFont = self.artifact.getFont()
            self.textItem.setFont(self.textItemFont)

            # Set the color of the text.
            self.color = self.artifact.getColor()
            
            # Set the pen color of the text.
            self.textItemPen = self.textItem.pen()
            self.textItemPen.setColor(self.color)
            self.textItem.setPen(self.textItemPen)

            # Set the brush color of the text.
            self.textItemBrush = self.textItem.brush()
            self.textItemBrush.setColor(self.color)
            self.textItem.setBrush(self.textItemBrush)

            # Apply some size scaling to the text.
            self.textTransform = QTransform()
            self.textTransform.scale(self.artifact.getTextXScaling(), \
                                     self.artifact.getTextYScaling())
            self.textItem.setTransform(self.textTransform)

            self.prepareGeometryChange()
        else:
            raise TypeError("Expected artifact type: " +
                            "PriceBarChartPriceTimeInfoArtifact")
    
        self.log.debug("Exiting setArtifact()")

    def recalculatePriceTimeInfo(self):
        """Just updates the text."""

        self._updateText()
        
    def _updateText(self):
        """Updates the text based on what is in the artifact.
        """

        # This object needs either the self.convertObj set, or the
        # parent graphicsscene set or else it won't have the capacity
        # to do price and datetime conversions to coordinates.
        if self.convertObj == None:
            if self.scene() == None:
                self.log.debug("_updateText(): Not able to update the text " +
                               "because QGraphicsScene for unit conversions " +
                               "was not set (or the item wasn't added to a " +
                               "qgraphicsscene yet")
                self.textItem.setText("INVALID")
                return
            else:
                self.convertObj = self.scene()
        
        # Set the text according to various flags in the artifact.
        # Internal QGraphicsItem that holds the text.
        # Initialize to blank and set at the end point.
        infoPointF = self.artifact.getInfoPointF()
        dt = self.convertObj.sceneXPosToDatetime(infoPointF.x())
        price = self.convertObj.sceneYPosToPrice(infoPointF.y())

        text = ""

        if self.artifact.getShowTimestampFlag():
            text += "t={}".format(Ephemeris.datetimeToDayStr(dt)) + \
                    os.linesep

            # Uncomment out this line if you want the timestamp text
            # without time.
            text = text[:16] + os.linesep

            text += "t=[{}]".\
                format(HebrewCalendarUtils.datetimeToHebrewDateStr(dt)) + \
                os.linesep
                
            text += "t={}".\
                format(HebrewCalendarUtils.datetimeToHebrewMonthDayStr(dt)) + \
                os.linesep
            
        if self.artifact.getShowPriceFlag():
            text += "p={:.4f}".format(price) + os.linesep
            
        if self.artifact.getShowSqrtPriceFlag():
            text += "sqrt(p)={:.4f}".format(math.sqrt(abs(price))) + os.linesep
            
        if self.artifact.getShowTimeElapsedSinceBirthFlag():
            if self.birthInfo != None:
                # Get the birth timestamp and convert to X coordinate.
                birthDtUtc = self.birthInfo.getBirthUtcDatetime()
                birthX = self.convertObj.datetimeToSceneXPos(birthDtUtc)

                # Find the difference between the info points and birthX
                xDiff = infoPointF.x() - birthX

                text += "t_elapsed={:.4f}".format(xDiff) + os.linesep
                
        if self.artifact.getShowSqrtTimeElapsedSinceBirthFlag():
            if self.birthInfo != None:
                # Get the birth timestamp and convert to X coordinate.
                birthDtUtc = self.birthInfo.getBirthUtcDatetime()
                birthX = self.convertObj.datetimeToSceneXPos(birthDtUtc)

                # Find the difference between the info points and birthX
                xDiff = infoPointF.x() - birthX

                text += "sqrt(t_elapsed)={:.4f}".\
                        format(math.sqrt(abs(xDiff))) + \
                        os.linesep
        
        if self.artifact.getShowPriceScaledValueFlag():
            scaledValue = self.convertObj.convertPriceToScaledValue(price)
            text += "p_u={:.4f}".format(scaledValue) + os.linesep
            
        if self.artifact.getShowSqrtPriceScaledValueFlag():
            scaledValue = self.convertObj.convertPriceToScaledValue(price)
            sqrtScaledValue = math.sqrt(abs(scaledValue))
            text += "sqrt(p_u)={:.4f}".format(sqrtScaledValue) + os.linesep
            
        if self.artifact.getShowTimeScaledValueFlag():
            scaledValue = self.convertObj.convertDatetimeToScaledValue(dt)
            text += "t_u={:.4f}".format(scaledValue) + os.linesep
            
        if self.artifact.getShowSqrtTimeScaledValueFlag():
            scaledValue = self.convertObj.convertDatetimeToScaledValue(dt)
            sqrtScaledValue = math.sqrt(abs(scaledValue))
            text += "sqrt(t_u)={:.4f}".format(sqrtScaledValue) + os.linesep

        text = text.rstrip()
        self.textItem.setText(text)
        self.prepareGeometryChange()
        
    def getArtifact(self):
        """Returns a PriceBarChartPriceTimeInfoArtifact for this QGraphicsItem 
        so that it may be pickled.
        """

        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartPriceTimeInfoArtifact to be 
        # current, then return it.
        self.artifact.setPos(self.pos())
        self.artifact.setFont(self.textItemFont)
        self.artifact.setColor(self.color)
        self.artifact.setTextXScaling(self.textTransform.m11())
        self.artifact.setTextYScaling(self.textTransform.m22())
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        # Set values from the priceBarChartSettings into the internal
        # member variables.
        
        self.textItemFont = QFont()
        self.textItemFont.\
            fromString(priceBarChartSettings.\
                       priceTimeInfoGraphicsItemDefaultFontDescription) 
        self.color = \
            priceBarChartSettings.priceTimeInfoGraphicsItemDefaultColor
        
        self.textTransform = QTransform()
        self.textTransform.scale(priceBarChartSettings.\
                                 priceTimeInfoGraphicsItemDefaultXScaling,
                                 priceBarChartSettings.\
                                 priceTimeInfoGraphicsItemDefaultYScaling)

        # Set values in the artifact since that's what we reference to
        # draw things.

        # showTimestampFlag (bool).
        self.artifact.setShowTimestampFlag(\
            priceBarChartSettings.priceTimeInfoGraphicsItemShowTimestampFlag)

        # showPriceFlag (bool).
        self.artifact.setShowPriceFlag(\
            priceBarChartSettings.priceTimeInfoGraphicsItemShowPriceFlag)
        
        # showSqrtPriceFlag (bool).
        self.artifact.setShowSqrtPriceFlag(\
            priceBarChartSettings.priceTimeInfoGraphicsItemShowSqrtPriceFlag)
        
        # showTimeElapsedSinceBirthFlag (bool).
        self.artifact.setShowTimeElapsedSinceBirthFlag(\
            priceBarChartSettings.\
            priceTimeInfoGraphicsItemShowTimeElapsedSinceBirthFlag)
        
        # showSqrtTimeElapsedSinceBirthFlag (bool).
        self.artifact.setShowSqrtTimeElapsedSinceBirthFlag(\
            priceBarChartSettings.\
            priceTimeInfoGraphicsItemShowSqrtTimeElapsedSinceBirthFlag)

        # showPriceScaledValueFlag (bool).
        self.artifact.setShowPriceScaledValueFlag(\
            priceBarChartSettings.\
            priceTimeInfoGraphicsItemShowPriceScaledValueFlag)
        
        # showSqrtPriceScaledValueFlag (bool).
        self.artifact.setShowSqrtPriceScaledValueFlag(\
            priceBarChartSettings.\
            priceTimeInfoGraphicsItemShowSqrtPriceScaledValueFlag)
        
        # showTimeScaledValueFlag (bool).
        self.artifact.setShowTimeScaledValueFlag(\
            priceBarChartSettings.\
            priceTimeInfoGraphicsItemShowTimeScaledValueFlag)
        
        # showSqrtTimeScaledValueFlag (bool).
        self.artifact.setShowSqrtTimeScaledValueFlag(\
            priceBarChartSettings.\
            priceTimeInfoGraphicsItemShowSqrtTimeScaledValueFlag)
        
        # showLineToInfoPointFlag (bool).
        self.artifact.setShowLineToInfoPointFlag(\
            priceBarChartSettings.\
            priceTimeInfoGraphicsItemShowLineToInfoPointFlag)

        # Update the internal text item.
        self.textItem.setFont(self.textItemFont)

        self.textItemPen = self.textItem.pen()
        self.textItemPen.setColor(self.color)
        self.textItem.setPen(self.textItemPen)

        self.textItemBrush = self.textItem.brush()
        self.textItemBrush.setColor(self.color)
        self.textItem.setBrush(self.textItemBrush)

        self.textItem.setTransform(self.textTransform)

        # Update text since the flags for what to display could have
        # been updated.
        self._updateText()
        
        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        pass

    def setTextLabelEdgeYLocation(self, y):
        """Sets the y location of the edge of the box that is the text
        graphics item.

        Arguments:
        y - float value for the y position of the edge of the box.
        """

        artifact = self.getArtifact()
        infoPointF = artifact.getInfoPointF()
        
        # Here we need to scale the bounding rect so that
        # it takes into account the transform that we did.
        textBoundingRect = self.textItem.boundingRect().normalized()
        width = textBoundingRect.width()
        height = textBoundingRect.height()
        scaledWidth = width * self.textTransform.m11()
        scaledHeight = height * self.textTransform.m22()
        
        if y > infoPointF.y():
            # Below.
            posX = infoPointF.x() - (scaledWidth * 0.5)
            posY = y
            pos = QPointF(posX, posY)
            self.setPos(pos)
        else:
            # Above
            posX = infoPointF.x() - (scaledWidth * 0.5)
            posY = y - scaledHeight
            pos = QPointF(posX, posY)
            self.setPos(pos)

        self.prepareGeometryChange()
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Arguments:
        pos - QPointF holding the new position.
        """
        
        super().setPos(pos)

    def _getScaledRectOfTextItem(self):
        """Returns the scaled QRectF of the self.textItem."""
        
        # Coordinate (0, 0) is the location of the internal text item
        # in local coordinates.  The QRectF returned is relative to
        # this (0, 0) point.

        textItemBoundingRect = self.textItem.boundingRect()

        self.log.debug("Bounding rect of textItem is: x={}, y={}, w={}, h={}".\
                       format(textItemBoundingRect.x(),
                              textItemBoundingRect.y(),
                              textItemBoundingRect.width(),
                              textItemBoundingRect.height()))
                       
        # Here we need to scale the bounding rect so that
        # it takes into account the transform that we did.
        width = textItemBoundingRect.width()
        height = textItemBoundingRect.height()
        scaledWidth = width * self.textTransform.m11()
        scaledHeight = height * self.textTransform.m22()

        topLeft = QPointF(0, 0)
        bottomRight = QPointF(scaledWidth, scaledHeight)
        scaledTextRect = QRectF(topLeft, bottomRight)

        return scaledTextRect
    
    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        self.log.debug("Entered boundingRect()")

        scaledTextRect = self._getScaledRectOfTextItem()
        
        self.log.debug("scaledTextRect is: x={}, y={}, w={}, h={}".\
                       format(scaledTextRect.x(),
                              scaledTextRect.y(),
                              scaledTextRect.width(),
                              scaledTextRect.height()))
                       
        localInfoPointF = self.mapFromScene(self.artifact.getInfoPointF())
        
        self.log.debug("localInfoPointF is: x={}, y={}".\
                       format(localInfoPointF.x(),
                              localInfoPointF.y()))
                       
        xValues = []
        xValues.append(scaledTextRect.topLeft().x())
        xValues.append(scaledTextRect.bottomLeft().x())
        xValues.append(scaledTextRect.topRight().x())
        xValues.append(scaledTextRect.bottomRight().x())
        xValues.append(localInfoPointF.x())

        yValues = []
        yValues.append(scaledTextRect.topLeft().y())
        yValues.append(scaledTextRect.bottomLeft().y())
        yValues.append(scaledTextRect.topRight().y())
        yValues.append(scaledTextRect.bottomRight().y())
        yValues.append(localInfoPointF.y())

        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        self.log.debug("rv coordinates are: ({}, {}), width={}, height={}".\
                       format(rv.x(), rv.y(), rv.width(), rv.height()))
        
        self.log.debug("Exiting boundingRect()")
        
        return rv
    
    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        self.log.debug("Entering shape()")
        
        scaledTextRect = self._getScaledRectOfTextItem()

        painterPath = QPainterPath()
        painterPath.addRect(scaledTextRect)

        self.log.debug("scaledTextRect coordinates are: " +
                       "({}, {}), width={}, height={}".\
                       format(scaledTextRect.x(),
                              scaledTextRect.y(),
                              scaledTextRect.width(),
                              scaledTextRect.height()))
        
        self.log.debug("Exiting shape()")
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.textItemPen is set
        to what we want for the drawing style.
        """

        self.log.debug("Entering paint()")
        self.log.debug("self.drawLineToInfoPointFFlag={}".\
                       format(self.drawLineToInfoPointFFlag))
        
        if painter.pen() != self.textItemPen:
            painter.setPen(QPen(self.textItemPen))

        if self.drawLineToInfoPointFFlag == True or \
               option.state & QStyle.State_Selected:

            self.log.debug("Drawing the line to the infoPointF...")
            
            # Draw a line to the infoPointF.  Below is setting the colors
            # and drawing parameters.
            pad = self.textItemPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            bgcolor = QColor(r, g, b)
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
    
            scaledTextRect = self._getScaledRectOfTextItem()
            
            topLeft = scaledTextRect.topLeft()
            bottomRight = scaledTextRect.bottomRight()
            localInfoPointF = self.mapFromScene(self.artifact.getInfoPointF())
    
            x = scaledTextRect.width() * 0.5
            y = None
            if localInfoPointF.y() > 0:
                y = scaledTextRect.height()
            else:
                y = 0.0
                
            # Set the start and end points to the line.
            startLinePoint = QPointF(x, y)
            endLinePoint = localInfoPointF
    
            self.log.debug("Start and end points of the line are: " +
                           "({}, {}), ({}, {})".\
                           format(startLinePoint.x(),
                                  startLinePoint.y(),
                                  endLinePoint.x(),
                                  endLinePoint.y()))
            
            # Draw the line.
            painter.drawLine(startLinePoint, endLinePoint)
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawLine(startLinePoint, endLinePoint)
        
        elif self.artifact.getShowLineToInfoPointFlag() == True:
            
            self.log.debug("Drawing regular line to InfoPoint.")
            
            scaledTextRect = self._getScaledRectOfTextItem()
            
            topLeft = scaledTextRect.topLeft()
            bottomRight = scaledTextRect.bottomRight()
            localInfoPointF = self.mapFromScene(self.artifact.getInfoPointF())
    
            x = scaledTextRect.width() * 0.5
            y = None
            if localInfoPointF.y() > 0:
                y = scaledTextRect.height()
            else:
                y = 0.0
                
            # Set the start and end points to the line.
            startLinePoint = QPointF(x, y)
            endLinePoint = localInfoPointF

            self.log.debug("Start and end points of the line are: " +
                           "({}, {}), ({}, {})".\
                           format(startLinePoint.x(),
                                  startLinePoint.y(),
                                  endLinePoint.x(),
                                  endLinePoint.y()))
                           
            # Draw the line.
            pen = QPen()
            pen.setColor(self.artifact.getColor())
            pen.setWidth(0)
            painter.setPen(pen)
            
            brush = QBrush()
            brush.setColor(self.artifact.getColor())
            painter.setBrush(brush)
            
            painter.drawLine(startLinePoint, endLinePoint)
            
        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.textItemPen.widthF() * 0.5;

            self.log.debug("Drawing selected dotted line.")
            
            penWidth = 0.0

            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

        self.log.debug("Exiting paint()")
        
    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PriceBarChartArtifactGraphicsItem.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        setAstro1Action = \
            QAction("Set info point timestamp on Astro Chart &1", parent)
        setAstro2Action = \
            QAction("Set info point timestamp on Astro Chart &2", parent)
        setAstro3Action = \
            QAction("Set info point timestamp on Astro Chart &3", parent)
        openJHoraAction = \
            QAction("Open JHor&a with info point timestamp", parent)
        openAstrologAction = \
            QAction("Open As&trolog with timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setAstro1Action.triggered.\
            connect(self._handleSetAstro1Action)
        setAstro2Action.triggered.\
            connect(self._handleSetAstro2Action)
        setAstro3Action.triggered.\
            connect(self._handleSetAstro3Action)
        openJHoraAction.triggered.\
            connect(self._handleOpenJHoraAction)
        openAstrologAction.triggered.\
            connect(self._handleOpenAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setAstro1Action.setEnabled(True)
        setAstro2Action.setEnabled(True)
        setAstro3Action.setEnabled(True)
        openJHoraAction.setEnabled(True)
        openAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setAstro1Action)
        menu.addAction(setAstro2Action)
        menu.addAction(setAstro3Action)
        menu.addAction(openJHoraAction)
        menu.addAction(openAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()

        self.log.debug("Inside _handleInfoAction(): artifact is: " +
                       artifact.toString())
        
        dialog = PriceBarChartPriceTimeInfoArtifactEditDialog(artifact,
                                                              self.scene(),
                                                              readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceTimeInfoArtifactEditDialog(artifact,
                                                     self.scene(),
                                                     readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of this PriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart1(self.artifact.getInfoPointF().x())
        
    def _handleSetAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of this PriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart2(self.artifact.getInfoPointF().x())
        
    def _handleSetAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of this PriceBarGraphicsItem.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().setAstroChart3(self.artifact.getInfoPointF().x())

    def _handleOpenJHoraAction(self):
        """Causes the timestamp of this PriceBarGraphicsItem to be
        opened in JHora.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().openJHora(self.artifact.getInfoPointF().x())

    def _handleOpenAstrologAction(self):
        """Causes the timestamp of this PriceBarGraphicsItem to be
        opened in Astrolog.
        """

        # The GraphicsItem's scene X position represents the time.
        self.scene().openAstrolog(self.artifact.getInfoPointF().x())

        
class PriceMeasurementGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a measurement ruler for price in
    the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point of the start point of the ruler.
    """

    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger("pricebarchart.PriceMeasurementGraphicsItem")
        self.log.debug("Entered __init__().")


        ############################################################
        # Set default values for preferences/settings.
        
        # Width of the horizontal bar drawn.
        self.priceMeasurementGraphicsItemBarWidth = \
            PriceBarChartSettings.\
                defaultPriceMeasurementGraphicsItemBarWidth
 
        # X scaling of the text.
        self.priceMeasurementTextXScaling = \
            PriceBarChartSettings.\
                defaultPriceMeasurementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.priceMeasurementTextYScaling = \
            PriceBarChartSettings.\
                defaultPriceMeasurementGraphicsItemTextYScaling 

        # Font.
        self.priceMeasurementTextFont = QFont()
        self.priceMeasurementTextFont.fromString(\
            PriceBarChartSettings.\
            defaultPriceMeasurementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.priceMeasurementGraphicsItemTextColor = \
            PriceBarChartSettings.\
            defaultPriceMeasurementGraphicsItemDefaultTextColor

        # Color of the item.
        self.priceMeasurementGraphicsItemColor = \
            PriceBarChartSettings.\
            defaultPriceMeasurementGraphicsItemDefaultColor

        # PriceMeasurementGraphicsItem showPriceRangeTextFlag (bool).
        self.showPriceRangeTextFlag = \
            PriceBarChartSettings.\
            defaultPriceMeasurementGraphicsItemShowPriceRangeTextFlag
    
        # PriceMeasurementGraphicsItem showSqrtPriceRangeTextFlag (bool).
        self.showSqrtPriceRangeTextFlag = \
            PriceBarChartSettings.\
            defaultPriceMeasurementGraphicsItemShowSqrtPriceRangeTextFlag
    
        # PriceMeasurementGraphicsItem showScaledValueRangeTextFlag (bool).
        self.showScaledValueRangeTextFlag = \
            PriceBarChartSettings.\
            defaultPriceMeasurementGraphicsItemShowScaledValueRangeTextFlag
    
        # PriceMeasurementGraphicsItem showSqrtScaledValueRangeTextFlag (bool).
        self.showSqrtScaledValueRangeTextFlag = \
            PriceBarChartSettings.\
            defaultPriceMeasurementGraphicsItemShowSqrtScaledValueRangeTextFlag
    
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartPriceMeasurementArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.priceMeasurementPenWidth = 0.0
        self.priceMeasurementPen = QPen()
        self.priceMeasurementPen.\
            setColor(self.priceMeasurementGraphicsItemColor)
        self.priceMeasurementPen.setWidthF(self.priceMeasurementPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Variables holding the price measurement values.
        self.priceRange = 0.0
        self.sqrtPriceRange = 0.0
        self.scaledValueRange = 0.0
        self.sqrtScaledValueRange = 0.0
        
        # Internal QGraphicsItem that holds the text of the price measurements.
        # Initialize to blank and set at the end point.
        self.priceMeasurementPriceRangeText = \
            QGraphicsSimpleTextItem("", self)
        self.priceMeasurementSqrtPriceRangeText = \
            QGraphicsSimpleTextItem("", self)
        self.priceMeasurementScaledValueRangeText = \
            QGraphicsSimpleTextItem("", self)
        self.priceMeasurementSqrtScaledValueRangeText = \
            QGraphicsSimpleTextItem("", self)

        # List of text items as created above.  This is so we can more
        # quickly and easily apply new settings.  It also helps for
        # painting things nicely.
        self.textItems = []
        self.textItems.append(self.priceMeasurementPriceRangeText)
        self.textItems.append(self.priceMeasurementSqrtPriceRangeText)
        self.textItems.append(self.priceMeasurementScaledValueRangeText)
        self.textItems.append(self.priceMeasurementSqrtScaledValueRangeText)

        for textItem in self.textItems:
            textItem.setPos(self.endPointF)
        
            # Set the font of the text.
            textItem.setFont(self.priceMeasurementTextFont)
        
            # Set the pen color of the text.
            self.priceMeasurementTextPen = textItem.pen()
            self.priceMeasurementTextPen.\
                setColor(self.priceMeasurementGraphicsItemTextColor)
            
            textItem.setPen(self.priceMeasurementTextPen)

            # Set the brush color of the text.
            self.priceMeasurementTextBrush = textItem.brush()
            self.priceMeasurementTextBrush.\
                setColor(self.priceMeasurementGraphicsItemTextColor)
            
            textItem.setBrush(self.priceMeasurementTextBrush)

            # Apply some size scaling to the text.
            textTransform = QTransform()
            textTransform.scale(self.priceMeasurementTextXScaling, \
                                self.priceMeasurementTextYScaling)
            textItem.setTransform(textTransform)

        # Flag that indicates that horizontaldotted lines should be drawn.
        self.drawHorizontalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None
        
    def setDrawHorizontalDottedLinesFlag(self, flag):
        """If flag is set to true, then the horizontal dotted lines are drawn.
        """

        self.drawHorizontalDottedLinesFlag = flag

        # Need to call this because the bounding box is updated with
        # all the extra horizontal lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Width of the horizontal bar drawn.
        self.priceMeasurementGraphicsItemBarWidth = \
            priceBarChartSettings.\
                priceMeasurementGraphicsItemDefaultBarWidth
 
        # X scaling of the text.
        self.priceMeasurementTextXScaling = \
            priceBarChartSettings.\
                priceMeasurementGraphicsItemDefaultTextXScaling 

        # Y scaling of the text.
        self.priceMeasurementTextYScaling = \
            priceBarChartSettings.\
                priceMeasurementGraphicsItemDefaultTextYScaling 

        # Font.
        self.priceMeasurementTextFont = QFont()
        self.priceMeasurementTextFont.fromString(\
            priceBarChartSettings.\
            priceMeasurementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.priceMeasurementGraphicsItemTextColor = \
            priceBarChartSettings.\
            priceMeasurementGraphicsItemDefaultTextColor

        # Color of the item.
        self.priceMeasurementGraphicsItemColor = \
            priceBarChartSettings.\
            priceMeasurementGraphicsItemDefaultColor

        # PriceMeasurementGraphicsItem showPriceRangeTextFlag (bool).
        self.showPriceRangeTextFlag = \
            priceBarChartSettings.\
            priceMeasurementGraphicsItemShowPriceRangeTextFlag
    
        # PriceMeasurementGraphicsItem showSqrtPriceRangeTextFlag (bool).
        self.showSqrtPriceRangeTextFlag = \
            priceBarChartSettings.\
            priceMeasurementGraphicsItemShowSqrtPriceRangeTextFlag
    
        # PriceMeasurementGraphicsItem showScaledValueRangeTextFlag (bool).
        self.showScaledValueRangeTextFlag = \
            priceBarChartSettings.\
            priceMeasurementGraphicsItemShowScaledValueRangeTextFlag
    
        # PriceMeasurementGraphicsItem showSqrtScaledValueRangeTextFlag (bool).
        self.showSqrtScaledValueRangeTextFlag = \
            priceBarChartSettings.\
            priceMeasurementGraphicsItemShowSqrtScaledValueRangeTextFlag
    
        ####################################################################

        # Set specific items enabled or disabled, visible or not,
        # based on the above flags being set.
        
        # Set the text items as enabled or disabled.
        self.priceMeasurementPriceRangeText.\
            setEnabled(self.showPriceRangeTextFlag)
        self.priceMeasurementSqrtPriceRangeText.\
            setEnabled(self.showSqrtPriceRangeTextFlag)
        self.priceMeasurementScaledValueRangeText.\
            setEnabled(self.showScaledValueRangeTextFlag)
        self.priceMeasurementSqrtScaledValueRangeText.\
            setEnabled(self.showSqrtScaledValueRangeTextFlag)

        # Set the text items as visible or invisible.
        self.priceMeasurementPriceRangeText.\
            setVisible(self.showPriceRangeTextFlag)
        self.priceMeasurementSqrtPriceRangeText.\
            setVisible(self.showSqrtPriceRangeTextFlag)
        self.priceMeasurementScaledValueRangeText.\
            setVisible(self.showScaledValueRangeTextFlag)
        self.priceMeasurementSqrtScaledValueRangeText.\
            setVisible(self.showSqrtScaledValueRangeTextFlag)
        
        # Update all the text items with the new settings.
        for textItem in self.textItems:
            # Set the font of the text.
            textItem.setFont(self.priceMeasurementTextFont)
        
            # Set the pen color of the text.
            self.priceMeasurementTextPen = textItem.pen()
            self.priceMeasurementTextPen.\
                setColor(self.priceMeasurementGraphicsItemTextColor)
            
            textItem.setPen(self.priceMeasurementTextPen)

            # Set the brush color of the text.
            self.priceMeasurementTextBrush = textItem.brush()
            self.priceMeasurementTextBrush.\
                setColor(self.priceMeasurementGraphicsItemTextColor)
            
            textItem.setBrush(self.priceMeasurementTextBrush)

            # Apply some size scaling to the text.
            textTransform = QTransform()
            textTransform.scale(self.priceMeasurementTextXScaling, \
                                self.priceMeasurementTextYScaling)
            textItem.setTransform(textTransform)

        # Recalculate the price measurement because scaling could have changed.
        self.recalculatePriceMeasurement()
        
        # Update the priceMeasurement text item position.
        self._updateTextItemPositions()

        # Set the new color of the pen for drawing the bar.
        self.priceMeasurementPen.\
            setColor(self.priceMeasurementGraphicsItemColor)
        
        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculatePriceMeasurement()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the ruler.
            scenePosY = event.scenePos().y()
            self.log.debug("DEBUG: scenePosY={}".format(scenePosY))
            
            startingPointY = self.startPointF.y()
            self.log.debug("DEBUG: startingPointY={}".format(startingPointY))
            endingPointY = self.endPointF.y()
            self.log.debug("DEBUG: endingPointY={}".format(endingPointY))
            
            diff = endingPointY - startingPointY
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointY + (diff * (1.0 / 5))
            endThreshold = endingPointY - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if scenePosY <= startThreshold:
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
            elif scenePosY >= endThreshold:
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(self.startPointF.x(),
                                                event.scenePos().y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(self.endPointF.x(),
                                              event.scenePos().y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)
            
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def _updateTextItemPositions(self):
        """Updates the location of the internal text items based on
        where the start and end points are.
        """
        
        # Update the priceMeasurement label position.
            
        # Y location where to place the item.
        deltaY = self.endPointF.y() - self.startPointF.y()
        y = deltaY * 0.5

        # Starting Y location to place the text item.
        startY = y

        # Amount to mutiply to the bar width to get the offset.
        offsetY = 0.3

        # j is the running index of the enabled text item.
        j = 0

        for i in reversed(range(len(self.textItems))):
            # Get the current text item.
            textItem = self.textItems[i]

            # Set the position no matter what, but only increment
            # j if the item is enabled and displayed.  This is so
            # we keep the text items on the graphicsScene close to
            # its parent item.
            x = self.priceMeasurementGraphicsItemBarWidth * 0.5
            y = startY - \
                ((offsetY * j) * self.priceMeasurementGraphicsItemBarWidth)
            textItem.setPos(QPointF(x, y))
            if textItem.isEnabled() and textItem.isVisible():
                j += 1
                    
    def setStartPointF(self, pointF):
        """Sets the starting point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        y = pointF.y()

        newValue = QPointF(self.endPointF.x(), y)

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            # Update the priceMeasurement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the pricemeasurement.
                self.recalculatePriceMeasurement()
                self.prepareGeometryChange()
                
    def setEndPointF(self, pointF):
        """Sets the ending point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        y = pointF.y()

        newValue = QPointF(self.startPointF.x(), y)

        if self.endPointF != newValue:
            self.endPointF = newValue

            # Update the priceMeasurement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the pricemeasurement.
                self.recalculatePriceMeasurement()
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        if self.startPointF.y() > self.endPointF.y():
            self.log.debug("Normalization of PriceMeasurementGraphicsItem " +
                           "required.")
            
            # Swap the points.
            temp = self.startPointF
            self.startPointF = self.endPointF
            self.endPointF = temp

            self.recalculatePriceMeasurement()
            
            # Update the priceMeasurement text item position.
            self._updateTextItemPositions()
            
            super().setPos(self.startPointF)
            

    def recalculatePriceMeasurement(self):
        """Sets the internal variables:
        
            self.priceRange
            self.sqrtPriceRange
            self.scaledValueRange
            self.sqrtScaledValueRange
            
        to hold the amount of price between the start and end points.
        """

        scene = self.scene()

        # Reset the values.
        self.priceRange = 0.0
        self.sqrtPriceRange = 0.0
        self.scaledValueRange = 0.0
        self.sqrtScaledValueRange = 0.0

        if scene != None:
            startPointPrice = \
                scene.sceneYPosToPrice(self.startPointF.y())
            self.log.debug("startPointPrice: {}".format(startPointPrice))
            
            endPointPrice = \
                scene.sceneYPosToPrice(self.endPointF.y())
            self.log.debug("endPointPrice: {}".format(endPointPrice))

            self.priceRange = abs(endPointPrice - startPointPrice)
            self.sqrtPriceRange = math.sqrt(abs(self.priceRange))
            self.scaledValueRange = \
                abs(scene.convertPriceToScaledValue(endPointPrice) - \
                    scene.convertPriceToScaledValue(startPointPrice))
            self.sqrtScaledValueRange = \
                math.sqrt(abs(self.scaledValueRange))
            
            self.log.debug("self.priceRange={}".format(self.priceRange))
            self.log.debug("self.sqrtPriceRange={}".format(self.sqrtPriceRange))
            self.log.debug("self.scaledValueRange={}".\
                           format(self.scaledValueRange))
            self.log.debug("self.sqrtScaledValueRange={}".\
                           format(self.sqrtScaledValueRange))
            
        # Update the text of the internal items.
        priceRangeText = "{:.4f} p_range".format(self.priceRange)
        sqrtPriceRangeText = "{:.4f} sqrt(p_range)".format(self.sqrtPriceRange)
        scaledValueRangeText = "{:.4f} u_range".\
                               format(self.scaledValueRange)
        sqrtScaledValueRangeText = "{:.4f} sqrt(u_range)".\
                               format(self.sqrtScaledValueRange)
        
        self.priceMeasurementPriceRangeText.setText(priceRangeText)
        self.priceMeasurementSqrtPriceRangeText.setText(sqrtPriceRangeText)
        self.priceMeasurementScaledValueRangeText.setText(scaledValueRangeText)
        self.priceMeasurementSqrtScaledValueRangeText.\
            setText(sqrtScaledValueRangeText)
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartPriceMeasurementArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartPriceMeasurementArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartPriceMeasurementArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartPriceMeasurementArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.priceMeasurementTextXScaling = self.artifact.getTextXScaling()
        self.priceMeasurementTextYScaling = self.artifact.getTextYScaling()
        self.priceMeasurementTextFont = self.artifact.getFont()
        self.priceMeasurementGraphicsItemTextColor = \
            self.artifact.getTextColor()
        self.priceMeasurementPen.setColor(self.artifact.getColor())
        
        self.showPriceRangeTextFlag = \
            self.artifact.getShowPriceRangeTextFlag()
        self.showSqrtPriceRangeTextFlag = \
            self.artifact.getShowSqrtPriceRangeTextFlag()
        self.showScaledValueRangeTextFlag = \
            self.artifact.getShowScaledValueRangeTextFlag()
        self.showSqrtScaledValueRangeTextFlag = \
            self.artifact.getShowSqrtScaledValueRangeTextFlag()

        #############

        # Set the text items as enabled or disabled.
        self.priceMeasurementPriceRangeText.\
            setEnabled(self.showPriceRangeTextFlag)
        self.priceMeasurementSqrtPriceRangeText.\
            setEnabled(self.showSqrtPriceRangeTextFlag)
        self.priceMeasurementScaledValueRangeText.\
            setEnabled(self.showScaledValueRangeTextFlag)
        self.priceMeasurementSqrtScaledValueRangeText.\
            setEnabled(self.showSqrtScaledValueRangeTextFlag)

        # Set the text items as visible or invisible.
        self.priceMeasurementPriceRangeText.\
            setVisible(self.showPriceRangeTextFlag)
        self.priceMeasurementSqrtPriceRangeText.\
            setVisible(self.showSqrtPriceRangeTextFlag)
        self.priceMeasurementScaledValueRangeText.\
            setVisible(self.showScaledValueRangeTextFlag)
        self.priceMeasurementSqrtScaledValueRangeText.\
            setVisible(self.showSqrtScaledValueRangeTextFlag)

        # Update all the text items with the new settings.
        for textItem in self.textItems:
            # Set the font of the text.
            textItem.setFont(self.priceMeasurementTextFont)
        
            # Set the pen color of the text.
            self.priceMeasurementTextPen = textItem.pen()
            self.priceMeasurementTextPen.\
                setColor(self.priceMeasurementGraphicsItemTextColor)
            
            textItem.setPen(self.priceMeasurementTextPen)

            # Set the brush color of the text.
            self.priceMeasurementTextBrush = textItem.brush()
            self.priceMeasurementTextBrush.\
                setColor(self.priceMeasurementGraphicsItemTextColor)
            
            textItem.setBrush(self.priceMeasurementTextBrush)

            # Apply some size scaling to the text.
            textTransform = QTransform()
            textTransform.scale(self.priceMeasurementTextXScaling, \
                                self.priceMeasurementTextYScaling)
            textItem.setTransform(textTransform)

        # Update the priceMeasurement text item position.
        self._updateTextItemPositions()
            
        # Need to recalculate the price measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the price measurements will be zero, since it
        # can't look up PriceBarGraphicsItems in the scene.
        self.recalculatePriceMeasurement()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartPriceMeasurementArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartPriceMeasurementArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        self.artifact.setTextXScaling(self.priceMeasurementTextXScaling)
        self.artifact.setTextYScaling(self.priceMeasurementTextYScaling)
        self.artifact.setFont(self.priceMeasurementTextFont)
        self.artifact.setTextColor(self.priceMeasurementGraphicsItemTextColor)
        self.artifact.setColor(self.priceMeasurementPen.color())
        
        self.artifact.setShowPriceRangeTextFlag(\
            self.showPriceRangeTextFlag)
        self.artifact.setShowSqrtPriceRangeTextFlag(\
            self.showSqrtPriceRangeTextFlag)
        self.artifact.setShowScaledValueRangeTextFlag(\
            self.showScaledValueRangeTextFlag)
        self.artifact.setShowSqrtScaledValueRangeTextFlag(\
            self.showSqrtScaledValueRangeTextFlag)
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.

        # The QRectF returned is relative to this (0, 0) point.

        # Get the QRectF with just the lines.
        yDelta = self.endPointF.y() - self.startPointF.y()

        topLeft = \
            QPointF(-1.0 * \
                    (self.priceMeasurementGraphicsItemBarWidth * 0.5),
                    0.0)
        
        bottomRight = \
            QPointF(1.0 * \
                    (self.priceMeasurementGraphicsItemBarWidth * 0.5),
                    yDelta)

        # Initalize to the above boundaries.  We will set them below.
        localHighX = bottomRight.x()
        localLowX = topLeft.x()
        if self.drawHorizontalDottedLinesFlag or self.isSelected():
            # Get the last and first PriceBar's timestamp in local
            # coordinates.
            earliestPriceBar = self.scene().getEarliestPriceBar()
            if earliestPriceBar != None:
                smallestPriceBarX = \
                    self.scene().datetimeToSceneXPos(earliestPriceBar.timestamp)
                localSmallestPriceBarX = \
                    self.mapFromScene(QPointF(smallestPriceBarX, 0.0)).x()

                # Overwrite the low if it is smaller.
                if localSmallestPriceBarX < localLowX:
                    localLowX = localSmallestPriceBarX
            
            latestPriceBar = self.scene().getLatestPriceBar()
            if latestPriceBar != None:
                largestPriceBarX = \
                    self.scene().datetimeToSceneXPos(latestPriceBar.timestamp)
                localLargestPriceBarX = \
                    self.mapFromScene(QPointF(largestPriceBarX, 0.0)).x()
        
                # Overwrite the high if it is larger.
                if localLargestPriceBarX > localHighX:
                    localHighX = localLargestPriceBarX
            
        xValues = []
        xValues.append(topLeft.x())
        xValues.append(bottomRight.x())
        xValues.append(localHighX)
        xValues.append(localLowX)

        yValues = []
        yValues.append(topLeft.y())
        yValues.append(bottomRight.y())

        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Get the QRectF with just the lines.
        yDelta = self.endPointF.y() - self.startPointF.y()

        topLeft = \
            QPointF(-1.0 * (self.priceMeasurementGraphicsItemBarWidth * 0.5),
                    0.0)
        
        bottomRight = \
            QPointF(1.0 * (self.priceMeasurementGraphicsItemBarWidth * 0.5),
                    yDelta)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.priceMeasurementPen is set to what we want for the
        drawing style.
        """

        if painter.pen() != self.priceMeasurementPen:
            painter.setPen(self.priceMeasurementPen)
        
        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the start point horizontal bar part.
        x1 = -1.0 * (self.priceMeasurementGraphicsItemBarWidth * 0.5)
        y1 = 0.0
        x2 = 1.0 * (self.priceMeasurementGraphicsItemBarWidth * 0.5)
        y2 = 0.0
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the end point horizontal bar part.
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = -1.0 * (self.priceMeasurementGraphicsItemBarWidth * 0.5)
        y1 = 0.0 + yDelta
        x2 = 1.0 * (self.priceMeasurementGraphicsItemBarWidth * 0.5)
        y2 = 0.0 + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle vertical line.
        x1 = 0.0
        y1 = 0.0
        x2 = 0.0
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each tick area if the flag is
        # set to do so, or if it is selected.
        if self.drawHorizontalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.priceMeasurementPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the last and first PriceBar's timestamp in local
                # coordinates.
                earliestPriceBar = self.scene().getEarliestPriceBar()
                if earliestPriceBar != None:
                    smallestPriceBarX = \
                        self.scene().\
                        datetimeToSceneXPos(earliestPriceBar.timestamp)
                    localSmallestPriceBarX = \
                        self.mapFromScene(QPointF(smallestPriceBarX, 0.0)).x()
                    xValues.append(localSmallestPriceBarX)

                latestPriceBar = self.scene().getLatestPriceBar()
                if latestPriceBar != None:
                    largestPriceBarX = \
                        self.scene().\
                        datetimeToSceneXPos(latestPriceBar.timestamp)
                    localLargestPriceBarX = \
                        self.mapFromScene(QPointF(largestPriceBarX, 0.0)).x()
                    xValues.append(localLargestPriceBarX)

                # We have all x values now, so sort them to get the
                # low and high.
                xValues.sort()
                smallestX = xValues[0]
                largestX = xValues[-1]
        
                # Horizontal line at the startPoint.
                localPosY = 0.0
                startPoint = QPointF(largestX, localPosY)
                endPoint = QPointF(smallestX, localPosY)
                        
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
            
                # Horizontal line at the endPoint.
                localPosY = 0.0 + yDelta
                startPoint = QPointF(largestX, localPosY)
                endPoint = QPointF(smallestX, localPosY)
                        
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
        # Draw the bounding rect if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.priceMeasurementPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PriceMeasurementGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        PriceMeasurementGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceMeasurementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceMeasurementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the PriceMeasurementGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the PriceMeasurementGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the PriceMeasurementGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        PriceMeasurementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        PriceMeasurementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        

class TimeRetracementGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a time retracement in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new TimeRetracementGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger(\
            "pricebarchart.TimeRetracementGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.
        
        # Height of the vertical bar drawn.
        self.timeRetracementGraphicsItemBarHeight = \
            PriceBarChartSettings.\
                defaultTimeRetracementGraphicsItemBarHeight 
 
        # X scaling of the text.
        self.timeRetracementTextXScaling = \
            PriceBarChartSettings.\
                defaultTimeRetracementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.timeRetracementTextYScaling = \
            PriceBarChartSettings.\
                defaultTimeRetracementGraphicsItemTextYScaling 

        # Font.
        self.timeRetracementTextFont = QFont()
        self.timeRetracementTextFont.fromString(\
            PriceBarChartSettings.\
            defaultTimeRetracementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.timeRetracementGraphicsItemTextColor = \
            PriceBarChartSettings.\
            defaultTimeRetracementGraphicsItemDefaultTextColor

        # Color of the item.
        self.timeRetracementGraphicsItemColor = \
            PriceBarChartSettings.\
            defaultTimeRetracementGraphicsItemDefaultColor

        # TimeRetracementGraphicsItem showFullLinesFlag (bool).
        self.showFullLinesFlag = \
            PriceBarChartSettings.\
            defaultTimeRetracementGraphicsItemShowFullLinesFlag
    
        # TimeRetracementGraphicsItem showTimeTextFlag (bool).
        self.showTimeTextFlag = \
            PriceBarChartSettings.\
            defaultTimeRetracementGraphicsItemShowTimeTextFlag
    
        # TimeRetracementGraphicsItem showPercentTextFlag (bool).
        self.showPercentTextFlag = \
            PriceBarChartSettings.\
            defaultTimeRetracementGraphicsItemShowPercentTextFlag
    
        # TimeRetracementGraphicsItem ratios (bool).
        self.ratios = \
            copy.deepcopy(PriceBarChartSettings.\
                          defaultTimeRetracementGraphicsItemRatios)
    
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartTimeRetracementArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.timeRetracementPenWidth = 0.0
        self.timeRetracementPen = QPen()
        self.timeRetracementPen.setColor(self.timeRetracementGraphicsItemColor)
        self.timeRetracementPen.setWidthF(self.timeRetracementPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Holds the QGraphicsSimpleTextItems for the texts associated
        # with the ratios.
        self.timeRetracementRatioTimeTexts = []
        self.timeRetracementRatioPercentTexts = []

        # Holds all the above text items, so that settings may be
        # applied more easily.
        self.textItems = []

        # Create the text items and put them in the above lists.
        self._recreateRatioTextItems()
        
        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def _recreateRatioTextItems(self):
        """Re-creates the text items related to the Ratios in
        self.ratios.  This includes making sure there are the correct
        number of them, and making sure their settings are correct, as
        expected.
        """

        # Disable and remove the old text items.
        for textItem in self.textItems:
            textItem.setEnabled(False)
            textItem.setVisible(False)

            if self.scene() != None:
                self.scene().removeItem(textItem)
                
        # Clear out the arrays holding the text items.
        self.textItems = []
        self.timeRetracementRatioTimeTexts = []
        self.timeRetracementRatioPercentTexts = []

        # Recreate the text items for all the ratios.  We recreate
        # them to make sure we have enough items.
        for ratio in self.ratios:
            timeTextItem = QGraphicsSimpleTextItem("", self)
            self.timeRetracementRatioTimeTexts.append(timeTextItem)
            self.textItems.append(timeTextItem)
            
            percentTextItem = QGraphicsSimpleTextItem("", self)
            self.timeRetracementRatioPercentTexts.append(percentTextItem)
            self.textItems.append(percentTextItem)

        # Apply location, and various other settings to the text items.
        for textItem in self.textItems:
            textItem.setPos(self.endPointF)
        
            # Set the font of the text.
            textItem.setFont(self.timeRetracementTextFont)
        
            # Set the pen color of the text.
            self.timeRetracementTextPen = textItem.pen()
            self.timeRetracementTextPen.\
                setColor(self.timeRetracementGraphicsItemTextColor)
            
            textItem.setPen(self.timeRetracementTextPen)

            # Set the brush color of the text.
            self.timeRetracementTextBrush = textItem.brush()
            self.timeRetracementTextBrush.\
                setColor(self.timeRetracementGraphicsItemTextColor)
            
            textItem.setBrush(self.timeRetracementTextBrush)

            # Apply some size scaling to the text.
            textTransform = QTransform()
            textTransform.scale(self.timeRetracementTextXScaling, \
                                self.timeRetracementTextYScaling)
            textTransform.rotate(self.rotationDegrees)
            textItem.setTransform(textTransform)

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag

        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Height of the vertical bar drawn.
        self.timeRetracementGraphicsItemBarHeight = \
            priceBarChartSettings.\
                timeRetracementGraphicsItemBarHeight 
 
        # X scaling of the text.
        self.timeRetracementTextXScaling = \
            priceBarChartSettings.\
                timeRetracementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.timeRetracementTextYScaling = \
            priceBarChartSettings.\
                timeRetracementGraphicsItemTextYScaling 

        # Font.
        self.timeRetracementTextFont = QFont()
        self.timeRetracementTextFont.fromString(\
            priceBarChartSettings.\
            timeRetracementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.timeRetracementGraphicsItemTextColor = \
            priceBarChartSettings.\
            timeRetracementGraphicsItemDefaultTextColor

        # Color of the item.
        self.timeRetracementGraphicsItemColor = \
            priceBarChartSettings.\
            timeRetracementGraphicsItemDefaultColor

        # TimeRetracementGraphicsItem showFullLinesFlag (bool).
        self.showFullLinesFlag = \
            priceBarChartSettings.\
            timeRetracementGraphicsItemShowFullLinesFlag
    
        # TimeRetracementGraphicsItem showTimeTextFlag (bool).
        self.showTimeTextFlag = \
            priceBarChartSettings.\
            timeRetracementGraphicsItemShowTimeTextFlag
    
        # TimeRetracementGraphicsItem showPercentTextFlag (bool).
        self.showPercentTextFlag = \
            priceBarChartSettings.\
            timeRetracementGraphicsItemShowPercentTextFlag
    
        # TimeRetracementGraphicsItem ratios (bool).
        self.ratios = \
            copy.deepcopy(priceBarChartSettings.\
                          timeRetracementGraphicsItemRatios)
        
        ####################################################################

        # Set the new color of the pen for drawing the bar.
        self.timeRetracementPen.\
            setColor(self.timeRetracementGraphicsItemColor)
        
        # Recreate the text items for the ratios.  This will also
        # apply the new scaling and font, etc. as needed.
        self._recreateRatioTextItems()
        
        # Set the text items as enabled or disabled, visible or
        # invisible, depending on whether the show flag is set.
        for textItem in self.timeRetracementRatioTimeTexts:
            textItem.setEnabled(self.showTimeTextFlag)
            textItem.setVisible(self.showTimeTextFlag)
            
        for textItem in self.timeRetracementRatioPercentTexts:
            textItem.setEnabled(self.showPercentTextFlag)
            textItem.setVisible(self.showPercentTextFlag)

        # Go through all the Ratio objects and disable texts if the
        # Ratios are not enabled.  This will be a second pass-through
        # of settings the text items, but this time, we do not enable
        # them, we only disable them if the corresponding Ratio is disabled.
        for i in range(len(self.ratios)):
            ratio = self.ratios[i]
            
            if not ratio.isEnabled():
                self.timeRetracementRatioTimeTexts[i].setEnabled(False)
                self.timeRetracementRatioTimeTexts[i].setVisible(False)

                self.timeRetracementRatioPercentTexts[i].setEnabled(False)
                self.timeRetracementRatioPercentTexts[i].setVisible(False)

        # Update the timeRetracement text item position.
        self._updateTextItemPositions()
            
        # Need to recalculate the timeRetracement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the time retracements will be zero, since it
        # can't look up PriceBarGraphicsItems in the scene.
        self.recalculateTimeRetracement()

        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculateTimeRetracement()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.setEndPointF(QPointF(self.endPointF.x(),
                                              event.scenePos().y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              event.scenePos().y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)

                    # Update calculation/text for the retracement.
                    self.recalculateTimeRetracement()
        
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)
            
                    # Update calculation/text for the retracement.
                    self.recalculateTimeRetracement()
        
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def _updateTextItemPositions(self):
        """Updates the location of the internal text items based on
        where the start and end points are.
        """
        
        # Update the timeRetracement label position.
        
        # X range.  Used in calculations for the X coordinate of the text items.
        deltaX = self.endPointF.x() - self.startPointF.x()

        # Remember, these text items are rotated, so what we are
        # trying to do here is to put the time text to the left of the
        # tick, and the percent text to the right of the tick.
        
        for i in range(len(self.ratios)):
            ratio = self.ratios[i]

            timeTextItem = self.timeRetracementRatioTimeTexts[i]
            percentTextItem = self.timeRetracementRatioPercentTexts[i]

            x = deltaX * ratio.getRatio()
            y = 0
            
            timeTextItem.setPos(QPointF(x, y))

            offset = self.timeRetracementTextFont.pointSizeF() * 1.4
            x = x + offset

            percentTextItem.setPos(QPointF(x, y))


    def setStartPointF(self, pointF):
        """Sets the starting point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            # Update the timeRetracement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the timeretracement.
                self.recalculateTimeRetracement()
                self.prepareGeometryChange()
                
    def setEndPointF(self, pointF):
        """Sets the ending point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            # Update the timeRetracement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the timeretracement.
                self.recalculateTimeRetracement()
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Does not do anything since normalization is not applicable
        to this graphics item.
        """

        # Do don't anything.
        pass

    def recalculateTimeRetracement(self):
        """Recalculates the timeRetracement and sets the text items'
        text accordingly.
        """

        scene = self.scene()

        # X range.  Used in calculations for the X coordinate of
        # the text items.
        deltaX = self.endPointF.x() - self.startPointF.x()
        
        if scene != None:
            # Update the text of the internal items.

            for i in range(len(self.ratios)):
                ratio = self.ratios[i]

                timeTextItem = self.timeRetracementRatioTimeTexts[i]
                percentTextItem = self.timeRetracementRatioPercentTexts[i]

                sceneXPos = self.startPointF.x() + (deltaX * ratio.getRatio())
                timestamp = self.scene().sceneXPosToDatetime(sceneXPos)

                # Set texts.
                timeText = "{}".format(Ephemeris.datetimeToDayStr(timestamp))
                percentText = "{:.2f} %".format(ratio.getRatio() * 100)
                
                timeTextItem.setText(timeText)
                percentTextItem.setText(percentText)
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartTimeRetracementArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartTimeRetracementArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartTimeRetracementArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartTimeRetracementArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.timeRetracementTextXScaling = self.artifact.getTextXScaling()
        self.timeRetracementTextYScaling = self.artifact.getTextYScaling()
        self.timeRetracementTextFont = self.artifact.getFont()
        self.timeRetracementGraphicsItemTextColor = self.artifact.getTextColor()
        self.timeRetracementPen.setColor(self.artifact.getColor())
        
        self.showFullLinesFlag = self.artifact.getShowFullLinesFlag()
        self.showTimeTextFlag = self.artifact.getShowTimeTextFlag()
        self.showPercentTextFlag = self.artifact.getShowPercentTextFlag()

        self.ratios = self.artifact.getRatios()

        #############

        # Recreate the text items for the ratios.  This will also
        # apply the new scaling and font, etc. as needed.
        self._recreateRatioTextItems()
        
        # Set the text items as enabled or disabled, visible or
        # invisible, depending on whether the show flag is set.
        for textItem in self.timeRetracementRatioTimeTexts:
            textItem.setEnabled(self.showTimeTextFlag)
            textItem.setVisible(self.showTimeTextFlag)
            
        for textItem in self.timeRetracementRatioPercentTexts:
            textItem.setEnabled(self.showPercentTextFlag)
            textItem.setVisible(self.showPercentTextFlag)

        # Go through all the Ratio objects and disable texts if the
        # Ratios are not enabled.  This will be a second pass-through
        # of settings the text items, but this time, we do not enable
        # them, we only disable them if the corresponding Ratio is disabled.
        for i in range(len(self.ratios)):
            ratio = self.ratios[i]
            
            if not ratio.isEnabled():
                self.timeRetracementRatioTimeTexts[i].setEnabled(False)
                self.timeRetracementRatioTimeTexts[i].setVisible(False)

                self.timeRetracementRatioPercentTexts[i].setEnabled(False)
                self.timeRetracementRatioPercentTexts[i].setVisible(False)

        # Update the timeRetracement text item position.
        self._updateTextItemPositions()
            
        # Need to recalculate the timeRetracement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the time retracements will be zero, since it
        # can't look up PriceBarGraphicsItems in the scene.
        self.recalculateTimeRetracement()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartTimeRetracementArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartTimeRetracementArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        self.artifact.setTextXScaling(self.timeRetracementTextXScaling)
        self.artifact.setTextYScaling(self.timeRetracementTextYScaling)
        self.artifact.setFont(self.timeRetracementTextFont)
        self.artifact.setTextColor(self.timeRetracementGraphicsItemTextColor)
        self.artifact.setColor(self.timeRetracementPen.color())
        
        self.artifact.setShowFullLinesFlag(self.showFullLinesFlag)
        self.artifact.setShowTimeTextFlag(self.showTimeTextFlag)
        self.artifact.setShowPercentTextFlag(self.showPercentTextFlag)

        self.artifact.setRatios(self.ratios)
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of the
        # vertical bar that is at startPointF.  If the user created
        # the widget with the startPointF to the right of the
        # endPointF, then the startPointF will have a higher X value
        # than endPointF.

        # The QRectF returned is relative to this (0, 0) point.

        # Bounding box here is the whole area that is painted.  That
        # means we need to take into account whether or not the full
        # lines are painted for the enabled ratios (for the Y height
        # value).  We always include the endPointF, which is the 100%
        # 'retracement'.

        # Get the QRectF with just the lines.

        # Keep track of x and y values so we can get the largest and
        # smallest x and y values.
        xValues = []
        yValues = []
        
        # The left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # The right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        x1 = 0.0 + xDelta
        y1 = 1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)
        x2 = 0.0 + xDelta
        y2 = -1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # The vertical lines for all the enabled ratios.
        if self.drawVerticalDottedLinesFlag or \
               self.isSelected() or \
               self.showFullLinesFlag == True:

            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)

        # Go through the ratios and track the x values for the enabled ratios.
        for ratio in self.ratios:
            if ratio.isEnabled():
                # Calculate the x in local coordinates.
                localX = xDelta * ratio.getRatio()
                xValues.append(localX)
        
        # We have all x and y values now, so sort them to get the
        # low and high.
        xValues.sort()
        yValues.sort()

        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Get the QRectF with just the lines.
        xDelta = self.endPointF.x() - self.startPointF.x()
        
        topLeft = \
            QPointF(0.0, -1.0 *
                    (self.timeRetracementGraphicsItemBarHeight * 0.5))
        
        bottomRight = \
            QPointF(xDelta, 1.0 *
                    (self.timeRetracementGraphicsItemBarHeight * 0.5))

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.timeRetracementPen is set to what we want for the drawing
        style.
        """

        if painter.pen() != self.timeRetracementPen:
            painter.setPen(self.timeRetracementPen)
        
        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        x1 = 0.0 + xDelta
        y1 = 1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)
        x2 = 0.0 + xDelta
        y2 = -1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the vertical lines for all the enabled ratios.
        for ratio in self.ratios:
            if ratio.isEnabled():
                localX = xDelta * ratio.getRatio()

                x1 = localX
                y1 = 1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)
                x2 = localX
                y2 = -1.0 * (self.timeRetracementGraphicsItemBarHeight * 0.5)
        
                painter.drawLine(QLineF(x1, y1, x2, y2))

                xValues.append(x1)
                xValues.append(x2)
                yValues.append(y1)
                yValues.append(y2)

                # If the full lines flag is enabled, then draw the
                # full length fo the line, from the 0 Y coordinate
                # location to the self.endPointF.y() location, in
                # local coordinates.
                if self.showFullLinesFlag == True:
                    x1 = localX
                    y1 = 0
                    x2 = localX
                    y2 = self.mapFromScene(QPointF(0.0, self.endPointF.y())).y()
        
                    painter.drawLine(QLineF(x1, y1, x2, y2))

                    xValues.append(x1)
                    xValues.append(x2)
                    yValues.append(y1)
                    yValues.append(y2)

        # Draw the middle horizontal line.
        xValues.sort()
        smallestX = xValues[0]
        largestX = xValues[-1]
        
        x1 = smallestX
        y1 = 0.0
        x2 = largestX
        y2 = 0.0
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)

        # Draw vertical dotted lines at each enabled tick area if the
        # flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.timeRetracementPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)

                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]

                # Draw the vertical lines for all the enabled ratios.
                xDelta = self.endPointF.x() - self.startPointF.x()
                for ratio in self.ratios:
                    if ratio.isEnabled():
                        x = xDelta * ratio.getRatio()

                        x1 = x
                        y1 = largestY
                        x2 = x
                        y2 = smallestY

                        xValues.append(x1)
                        xValues.append(x2)
                        yValues.append(y1)
                        yValues.append(y2)
                    
                        startPoint = QPointF(x1, y1)
                        endPoint = QPointF(x2, y2)

                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
        
        # Draw the shape if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.timeRetracementPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this TimeRetracementGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        TimeRetracementGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartTimeRetracementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartTimeRetracementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the TimeRetracementGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the TimeRetracementGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the TimeRetracementGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        TimeRetracementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        TimeRetracementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the TimeRetracementGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the TimeRetracementGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the TimeRetracementGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        TimeRetracementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())

    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        TimeRetracementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())


class PriceRetracementGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a price retracement in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point width bar, on the start point (bottom part) of the bar ruler.

    That means when a user creates a new PriceRetracementGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger(\
            "pricebarchart.PriceRetracementGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.
        
        # Width of the vertical bar drawn.
        self.priceRetracementGraphicsItemBarWidth = \
            PriceBarChartSettings.\
                defaultPriceRetracementGraphicsItemBarWidth 
 
        # X scaling of the text.
        self.priceRetracementTextXScaling = \
            PriceBarChartSettings.\
                defaultPriceRetracementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.priceRetracementTextYScaling = \
            PriceBarChartSettings.\
                defaultPriceRetracementGraphicsItemTextYScaling 

        # Font.
        self.priceRetracementTextFont = QFont()
        self.priceRetracementTextFont.fromString(\
            PriceBarChartSettings.\
            defaultPriceRetracementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.priceRetracementGraphicsItemTextColor = \
            PriceBarChartSettings.\
            defaultPriceRetracementGraphicsItemDefaultTextColor

        # Color of the item.
        self.priceRetracementGraphicsItemColor = \
            PriceBarChartSettings.\
            defaultPriceRetracementGraphicsItemDefaultColor

        # PriceRetracementGraphicsItem showFullLinesFlag (bool).
        self.showFullLinesFlag = \
            PriceBarChartSettings.\
            defaultPriceRetracementGraphicsItemShowFullLinesFlag
    
        # PriceRetracementGraphicsItem showPriceTextFlag (bool).
        self.showPriceTextFlag = \
            PriceBarChartSettings.\
            defaultPriceRetracementGraphicsItemShowPriceTextFlag
    
        # PriceRetracementGraphicsItem showPercentTextFlag (bool).
        self.showPercentTextFlag = \
            PriceBarChartSettings.\
            defaultPriceRetracementGraphicsItemShowPercentTextFlag
    
        # PriceRetracementGraphicsItem ratios (bool).
        self.ratios = \
            copy.deepcopy(PriceBarChartSettings.\
                          defaultPriceRetracementGraphicsItemRatios)
    
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartPriceRetracementArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.priceRetracementPenWidth = 0.0
        self.priceRetracementPen = QPen()
        self.priceRetracementPen.\
            setColor(self.priceRetracementGraphicsItemColor)
        self.priceRetracementPen.\
            setWidthF(self.priceRetracementPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Degrees of text rotation.
        self.rotationDegrees = 0.0
        
        # Holds the QGraphicsSimpleTextItems for the texts associated
        # with the ratios.
        self.priceRetracementRatioPriceTexts = []
        self.priceRetracementRatioPercentTexts = []

        # Holds all the above text items, so that settings may be
        # applied more easily.
        self.textItems = []

        # Create the text items and put them in the above lists.
        self._recreateRatioTextItems()
        
        # Flag that indicates that horizontal dotted lines should be drawn.
        self.drawHorizontalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def _recreateRatioTextItems(self):
        """Re-creates the text items related to the Ratios in
        self.ratios.  This includes making sure there are the correct
        number of them, and making sure their settings are correct, as
        expected.
        """

        # Disable and remove the old text items.
        for textItem in self.textItems:
            textItem.setEnabled(False)
            textItem.setVisible(False)

            if self.scene() != None:
                self.scene().removeItem(textItem)
                
        # Clear out the arrays holding the text items.
        self.textItems = []
        self.priceRetracementRatioPriceTexts = []
        self.priceRetracementRatioPercentTexts = []

        # Recreate the text items for all the ratios.  We recreate
        # them to make sure we have enough items.
        for ratio in self.ratios:
            priceTextItem = QGraphicsSimpleTextItem("", self)
            self.priceRetracementRatioPriceTexts.append(priceTextItem)
            self.textItems.append(priceTextItem)
            
            percentTextItem = QGraphicsSimpleTextItem("", self)
            self.priceRetracementRatioPercentTexts.append(percentTextItem)
            self.textItems.append(percentTextItem)

        # Apply location, and various other settings to the text items.
        for textItem in self.textItems:
            textItem.setPos(self.endPointF)
        
            # Set the font of the text.
            textItem.setFont(self.priceRetracementTextFont)
        
            # Set the pen color of the text.
            self.priceRetracementTextPen = textItem.pen()
            self.priceRetracementTextPen.\
                setColor(self.priceRetracementGraphicsItemTextColor)
            
            textItem.setPen(self.priceRetracementTextPen)

            # Set the brush color of the text.
            self.priceRetracementTextBrush = textItem.brush()
            self.priceRetracementTextBrush.\
                setColor(self.priceRetracementGraphicsItemTextColor)
            
            textItem.setBrush(self.priceRetracementTextBrush)

            # Apply some size scaling to the text.
            textTransform = QTransform()
            textTransform.scale(self.priceRetracementTextXScaling, \
                                self.priceRetracementTextYScaling)
            textTransform.rotate(self.rotationDegrees)
            textItem.setTransform(textTransform)

    def setDrawHorizontalDottedLinesFlag(self, flag):
        """If flag is set to true, then the horizontal dotted lines are drawn.
        """

        self.drawHorizontalDottedLinesFlag = flag

        # Need to call this because the bounding box is updated with
        # all the extra horizontal lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Width of the horizontal bar drawn.
        self.priceRetracementGraphicsItemBarWidth = \
            priceBarChartSettings.\
                priceRetracementGraphicsItemBarWidth 
 
        # X scaling of the text.
        self.priceRetracementTextXScaling = \
            priceBarChartSettings.\
                priceRetracementGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.priceRetracementTextYScaling = \
            priceBarChartSettings.\
                priceRetracementGraphicsItemTextYScaling 

        # Font.
        self.priceRetracementTextFont = QFont()
        self.priceRetracementTextFont.fromString(\
            priceBarChartSettings.\
            priceRetracementGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.priceRetracementGraphicsItemTextColor = \
            priceBarChartSettings.\
            priceRetracementGraphicsItemDefaultTextColor

        # Color of the item.
        self.priceRetracementGraphicsItemColor = \
            priceBarChartSettings.\
            priceRetracementGraphicsItemDefaultColor

        # PriceRetracementGraphicsItem showFullLinesFlag (bool).
        self.showFullLinesFlag = \
            priceBarChartSettings.\
            priceRetracementGraphicsItemShowFullLinesFlag
    
        # PriceRetracementGraphicsItem showPriceTextFlag (bool).
        self.showPriceTextFlag = \
            priceBarChartSettings.\
            priceRetracementGraphicsItemShowPriceTextFlag
    
        # PriceRetracementGraphicsItem showPercentTextFlag (bool).
        self.showPercentTextFlag = \
            priceBarChartSettings.\
            priceRetracementGraphicsItemShowPercentTextFlag
    
        # PriceRetracementGraphicsItem ratios (bool).
        self.ratios = \
            copy.deepcopy(priceBarChartSettings.\
                          priceRetracementGraphicsItemRatios)
        
        ####################################################################

        # Set the new color of the pen for drawing the bar.
        self.priceRetracementPen.\
            setColor(self.priceRetracementGraphicsItemColor)
        
        # Recreate the text items for the ratios.  This will also
        # apply the new scaling and font, etc. as needed.
        self._recreateRatioTextItems()
        
        # Set the text items as enabled or disabled, visible or
        # invisible, depending on whether the show flag is set.
        for textItem in self.priceRetracementRatioPriceTexts:
            textItem.setEnabled(self.showPriceTextFlag)
            textItem.setVisible(self.showPriceTextFlag)
            
        for textItem in self.priceRetracementRatioPercentTexts:
            textItem.setEnabled(self.showPercentTextFlag)
            textItem.setVisible(self.showPercentTextFlag)

        # Go through all the Ratio objects and disable texts if the
        # Ratios are not enabled.  This will be a second pass-through
        # of settings the text items, but this time, we do not enable
        # them, we only disable them if the corresponding Ratio is disabled.
        for i in range(len(self.ratios)):
            ratio = self.ratios[i]
            
            if not ratio.isEnabled():
                self.priceRetracementRatioPriceTexts[i].setEnabled(False)
                self.priceRetracementRatioPriceTexts[i].setVisible(False)

                self.priceRetracementRatioPercentTexts[i].setEnabled(False)
                self.priceRetracementRatioPercentTexts[i].setVisible(False)

        # Update the priceRetracement text item position.
        self._updateTextItemPositions()
            
        # Need to recalculate the priceRetracement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the price retracements will be zero, since it
        # can't look up PriceBarGraphicsItems in the scene.
        self.recalculatePriceRetracement()

        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculatePriceRetracement()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosY = event.scenePos().y()
            self.log.debug("DEBUG: scenePosY={}".format(scenePosY))
            
            startingPointY = self.startPointF.y()
            self.log.debug("DEBUG: startingPointY={}".format(startingPointY))
            endingPointY = self.endPointF.y()
            self.log.debug("DEBUG: endingPointY={}".format(endingPointY))
            
            diff = endingPointY - startingPointY
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointY + (diff * (1.0 / 5))
            endThreshold = endingPointY - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointY <= scenePosY <= startThreshold or \
                   startingPointY >= scenePosY >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointY <= scenePosY <= endThreshold or \
                   endingPointY >= scenePosY >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(self.startPointF.x(),
                                                event.scenePos().y()))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              event.scenePos().y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)

                    # Update calculation/text for the retracement.
                    self.recalculatePriceRetracement()
        
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)
            
                    # Update calculation/text for the retracement.
                    self.recalculatePriceRetracement()
        
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def _updateTextItemPositions(self):
        """Updates the location of the internal text items based on
        where the start and end points are.
        """
        
        # Update the priceRetracement label position.
        
        # Y range.  Used in calculations for the Y coordinate of the text items.
        deltaY = self.endPointF.y() - self.startPointF.y()

        for i in range(len(self.ratios)):
            ratio = self.ratios[i]

            priceTextItem = self.priceRetracementRatioPriceTexts[i]
            percentTextItem = self.priceRetracementRatioPercentTexts[i]

            x = 0
            y = deltaY * ratio.getRatio()
            
            priceTextItem.setPos(QPointF(x, y))

            offset = self.priceRetracementTextFont.pointSizeF() * 1.4
            y = y - offset

            percentTextItem.setPos(QPointF(x, y))


    def setStartPointF(self, pointF):
        """Sets the starting point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            # Update the priceRetracement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the priceretracement.
                self.recalculatePriceRetracement()
                self.prepareGeometryChange()
                
    def setEndPointF(self, pointF):
        """Sets the ending point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            # Update the priceRetracement text item position.
            self._updateTextItemPositions()
            
            if self.scene() != None:
                # Re-calculate the priceretracement.
                self.recalculatePriceRetracement()
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Does not do anything since normalization is not applicable
        to this graphics item.
        """

        # Do don't anything.
        pass

    def recalculatePriceRetracement(self):
        """Recalculates the priceRetracement and sets the text items'
        text accordingly.
        """

        scene = self.scene()

        # Y range.  Used in calculations for the Y coordinate of
        # the text items.
        deltaY = self.endPointF.y() - self.startPointF.y()
        
        if scene != None:
            # Update the text of the internal items.

            for i in range(len(self.ratios)):
                ratio = self.ratios[i]

                priceTextItem = self.priceRetracementRatioPriceTexts[i]
                percentTextItem = self.priceRetracementRatioPercentTexts[i]

                sceneYPos = self.startPointF.y() + (deltaY * ratio.getRatio())
                price = self.scene().sceneYPosToPrice(sceneYPos)

                # Set texts.
                priceText = "{}".format(price)
                percentText = "{:.2f} %".format(ratio.getRatio() * 100)
                
                priceTextItem.setText(priceText)
                percentTextItem.setText(percentText)
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartPriceRetracementArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartPriceRetracementArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartPriceRetracementArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartPriceRetracementArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.priceRetracementTextXScaling = self.artifact.getTextXScaling()
        self.priceRetracementTextYScaling = self.artifact.getTextYScaling()
        self.priceRetracementTextFont = self.artifact.getFont()
        self.priceRetracementGraphicsItemTextColor = \
            self.artifact.getTextColor()
        self.priceRetracementPen.setColor(self.artifact.getColor())
        
        self.showFullLinesFlag = self.artifact.getShowFullLinesFlag()
        self.showPriceTextFlag = self.artifact.getShowPriceTextFlag()
        self.showPercentTextFlag = self.artifact.getShowPercentTextFlag()

        self.ratios = self.artifact.getRatios()

        #############

        # Recreate the text items for the ratios.  This will also
        # apply the new scaling and font, etc. as needed.
        self._recreateRatioTextItems()
        
        # Set the text items as enabled or disabled, visible or
        # invisible, depending on whether the show flag is set.
        for textItem in self.priceRetracementRatioPriceTexts:
            textItem.setEnabled(self.showPriceTextFlag)
            textItem.setVisible(self.showPriceTextFlag)
            
        for textItem in self.priceRetracementRatioPercentTexts:
            textItem.setEnabled(self.showPercentTextFlag)
            textItem.setVisible(self.showPercentTextFlag)

        # Go through all the Ratio objects and disable texts if the
        # Ratios are not enabled.  This will be a second pass-through
        # of settings the text items, but this time, we do not enable
        # them, we only disable them if the corresponding Ratio is disabled.
        for i in range(len(self.ratios)):
            ratio = self.ratios[i]
            
            if not ratio.isEnabled():
                self.priceRetracementRatioPriceTexts[i].setEnabled(False)
                self.priceRetracementRatioPriceTexts[i].setVisible(False)

                self.priceRetracementRatioPercentTexts[i].setEnabled(False)
                self.priceRetracementRatioPercentTexts[i].setVisible(False)

        # Need to recalculate the priceRetracement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the price retracements will be zero, since it
        # can't look up PriceBarGraphicsItems in the scene.
        self.recalculatePriceRetracement()

        # Update the priceRetracement text item position.
        self._updateTextItemPositions()
            
        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartPriceRetracementArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartPriceRetracementArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        self.artifact.setTextXScaling(self.priceRetracementTextXScaling)
        self.artifact.setTextYScaling(self.priceRetracementTextYScaling)
        self.artifact.setFont(self.priceRetracementTextFont)
        self.artifact.setTextColor(self.priceRetracementGraphicsItemTextColor)
        self.artifact.setColor(self.priceRetracementPen.color())
        
        self.artifact.setShowFullLinesFlag(self.showFullLinesFlag)
        self.artifact.setShowPriceTextFlag(self.showPriceTextFlag)
        self.artifact.setShowPercentTextFlag(self.showPercentTextFlag)

        self.artifact.setRatios(self.ratios)
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of the
        # horizontal bar that is at startPointF.  If the user created
        # the widget with the startPointF to the right of the
        # endPointF, then the startPointF will have a higher X value
        # than endPointF.

        # The QRectF returned is relative to this (0, 0) point.

        # Bounding box here is the whole area that is painted.  That
        # means we need to take into account whether or not the full
        # lines are painted for the enabled ratios (for the X width
        # value).  We always include the endPointF, which is the 100%
        # 'retracement'.

        # Get the QRectF with just the lines.

        # Keep track of x and y values so we can get the largest and
        # smallest x and y values.
        xValues = []
        yValues = []
        
        # The bottom horizontal bar part.
        x1 = 1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
        y1 = 0.0
        x2 = -1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
        y2 = 0.0

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # The top horizontal bar part.
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
        y1 = 0.0 + yDelta
        x2 = -1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
        y2 = 0.0 + yDelta

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # The horizontal lines for all the enabled ratios.
        if self.drawHorizontalDottedLinesFlag or \
               self.isSelected() or \
               self.showFullLinesFlag == True:

            # Get the earliest and latest PriceBar timestamp in local
            # coordinates.
            earliestPriceBar = self.scene().getEarliestPriceBar()
            if earliestPriceBar != None:
                smallestPriceBarX = \
                    self.scene().\
                    datetimeToSceneXPos(earliestPriceBar.timestamp)
                localSmallestPriceBarX = \
                    self.mapFromScene(QPointF(smallestPriceBarX, 0.0)).x()
                xValues.append(localSmallestPriceBarX)
            
            latestPriceBar = self.scene().getLatestPriceBar()
            if latestPriceBar != None:
                largestPriceBarX = \
                    self.scene().\
                    datetimeToSceneXPos(latestPriceBar.timestamp)
                localLargestPriceBarX = \
                    self.mapFromScene(QPointF(largestPriceBarX, 0.0)).x()
                xValues.append(localLargestPriceBarX)

        # Go through the ratios and track the y values for the enabled ratios.
        for ratio in self.ratios:
            if ratio.isEnabled():
                # Calculate the y in local coordinates.
                localY = yDelta * ratio.getRatio()
                yValues.append(localY)
        
        # We have all x and y values now, so sort them to get the
        # low and high.
        xValues.sort()
        yValues.sort()

        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Get the QRectF with just the lines.
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        topLeft = \
            QPointF(-1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5),
                    0.0)
        
        
        bottomRight = \
            QPointF(1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5),
                    yDelta)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.priceRetracementPen is set to what we want for the
        drawing style.
        """

        if painter.pen() != self.priceRetracementPen:
            painter.setPen(self.priceRetracementPen)
        
        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the bottom horizontal bar part.
        x1 = 1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
        y1 = 0.0
        x2 = -1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
        y2 = 0.0
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the top horizontal bar part.
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
        y1 = 0.0 + yDelta
        x2 = -1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
        y2 = 0.0 + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the horizontal lines for all the enabled ratios.
        for ratio in self.ratios:
            if ratio.isEnabled():
                localY = yDelta * ratio.getRatio()

                x1 = 1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
                y1 = localY
                x2 = -1.0 * (self.priceRetracementGraphicsItemBarWidth * 0.5)
                y2 = localY
        
                painter.drawLine(QLineF(x1, y1, x2, y2))

                xValues.append(x1)
                xValues.append(x2)
                yValues.append(y1)
                yValues.append(y2)

                # If the full lines flag is enabled, then draw the
                # full length fo the line, from the 0 Y coordinate
                # location to the self.endPointF.y() location, in
                # local coordinates.
                if self.showFullLinesFlag == True:
                    x1 = 0
                    y1 = localY
                    x2 = self.mapFromScene(QPointF(self.endPointF.x(), 0.0)).x()
                    y2 = localY
        
                    painter.drawLine(QLineF(x1, y1, x2, y2))

                    xValues.append(x1)
                    xValues.append(x2)
                    yValues.append(y1)
                    yValues.append(y2)

        # Draw the middle horizontal line.
        yValues.sort()
        smallestY = yValues[0]
        largestY = yValues[-1]
        
        x1 = 0.0
        y1 = smallestY
        x2 = 0.0
        y2 = largestY
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)

        # Draw horizontal dotted lines at each enabled tick area if the
        # flag is set to do so, or if it is selected.
        if self.drawHorizontalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.priceRetracementPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the earliest and latest PriceBar timestamp in local
                # coordinates.
                earliestPriceBar = self.scene().getEarliestPriceBar()
                if earliestPriceBar != None:
                    smallestPriceBarX = \
                        self.scene().\
                        datetimeToSceneXPos(earliestPriceBar.timestamp)
                    localSmallestPriceBarX = \
                        self.mapFromScene(QPointF(smallestPriceBarX, 0.0)).x()
                    xValues.append(localSmallestPriceBarX)
            
                latestPriceBar = self.scene().getLatestPriceBar()
                if latestPriceBar != None:
                    largestPriceBarX = \
                        self.scene().\
                        datetimeToSceneXPos(latestPriceBar.timestamp)
                    localLargestPriceBarX = \
                        self.mapFromScene(QPointF(largestPriceBarX, 0.0)).x()
                    xValues.append(localLargestPriceBarX)

                # We have all x values now, so sort them to get the
                # low and high.
                xValues.sort()
                smallestX = xValues[0]
                largestX = xValues[-1]

                # Draw the horizontal lines for all the enabled ratios.
                yDelta = self.endPointF.y() - self.startPointF.y()
                for ratio in self.ratios:
                    if ratio.isEnabled():
                        y = yDelta * ratio.getRatio()

                        x1 = largestX
                        y1 = y
                        x2 = smallestX
                        y2 = y

                        xValues.append(x1)
                        xValues.append(x2)
                        yValues.append(y1)
                        yValues.append(y2)
                    
                        startPoint = QPointF(x1, y1)
                        endPoint = QPointF(x2, y2)

                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
        
        # Draw the shape if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.priceRetracementPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PriceRetracementGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        PriceRetracementGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceRetracementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceRetracementArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the PriceRetracementGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the PriceRetracementGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the PriceRetracementGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        PriceRetracementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        PriceRetracementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the PriceRetracementGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the PriceRetracementGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the PriceRetracementGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        PriceRetracementGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        PriceRetracementGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        

class PriceTimeVectorGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a price retracement in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point width bar, on the start point (bottom part) of the bar ruler.

    That means when a user creates a new PriceTimeVectorGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger(\
            "pricebarchart.PriceTimeVectorGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.
        
        # Width of the vertical bar drawn.
        self.priceTimeVectorGraphicsItemBarWidth = \
            PriceBarChartSettings.\
                defaultPriceTimeVectorGraphicsItemBarWidth 
 
        # X scaling of the text.
        self.priceTimeVectorTextXScaling = \
            PriceBarChartSettings.\
                defaultPriceTimeVectorGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.priceTimeVectorTextYScaling = \
            PriceBarChartSettings.\
                defaultPriceTimeVectorGraphicsItemTextYScaling 

        # Font.
        self.priceTimeVectorTextFont = QFont()
        self.priceTimeVectorTextFont.fromString(\
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.priceTimeVectorGraphicsItemTextColor = \
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemTextColor

        # Color of the item.
        self.priceTimeVectorGraphicsItemColor = \
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemColor

        # PriceTimeVectorGraphicsItem showDistanceTextFlag (bool).
        self.showDistanceTextFlag = \
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemShowDistanceTextFlag
    
        # PriceTimeVectorGraphicsItem showSqrtDistanceTextFlag (bool).
        self.showSqrtDistanceTextFlag = \
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemShowSqrtDistanceTextFlag
    
        # PriceTimeVectorGraphicsItem showDistanceScaledValueTextFlag (bool).
        self.showDistanceScaledValueTextFlag = \
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemShowDistanceScaledValueTextFlag
    
        # PriceTimeVectorGraphicsItem
        # showSqrtDistanceScaledValueTextFlag (bool).
        self.showSqrtDistanceScaledValueTextFlag = \
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemShowSqrtDistanceScaledValueTextFlag
    
        # PriceTimeVectorGraphicsItem tiltedTextFlag (bool).
        self.tiltedTextFlag = \
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemTiltedTextFlag
    
        # PriceTimeVectorGraphicsItem angleTextFlag (bool).
        self.angleTextFlag = \
            PriceBarChartSettings.\
            defaultPriceTimeVectorGraphicsItemAngleTextFlag
    
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartPriceTimeVectorArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.priceTimeVectorPenWidth = 0.0
        self.priceTimeVectorPen = QPen()
        self.priceTimeVectorPen.\
            setColor(self.priceTimeVectorGraphicsItemColor)
        self.priceTimeVectorPen.\
            setWidthF(self.priceTimeVectorPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Degrees of text rotation.
        self.rotationDegrees = 0.0

        # Variable holding the distance measurement.
        self.distance = 0.0
        self.sqrtDistance = 0.0
        self.distanceScaledValue = 0.0
        self.sqrtDistanceScaledValue = 0.0
        
        # Internal text item.
        self.textItem = QGraphicsSimpleTextItem("", self)
        self.textItem.setPos(self.endPointF)

        # Transform object applied to the text item.
        self.textTransform = QTransform()

        # Set the text item with the properties we want it to have.
        self.reApplyTextItemAttributes(self.textItem)
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False

        # Working variables for clicking and draging.
        self.clickScenePointF = None
        self.origStartPointF = None

    def reApplyTextItemAttributes(self, textItem):
        """Takes the given text item and reapplies the pen, brush,
        transform, etc. that should be set for the text item.
        """
        
        # Set properties of the text item.
        
        # Set the font of the text.
        textItem.setFont(self.priceTimeVectorTextFont)
        
        # Set the pen color of the text.
        self.priceTimeVectorTextPen = textItem.pen()
        self.priceTimeVectorTextPen.\
            setColor(self.priceTimeVectorGraphicsItemTextColor)
        textItem.setPen(self.priceTimeVectorTextPen)

        # Set the brush color of the text.
        self.priceTimeVectorTextBrush = textItem.brush()
        self.priceTimeVectorTextBrush.\
            setColor(self.priceTimeVectorGraphicsItemTextColor)
        textItem.setBrush(self.priceTimeVectorTextBrush)

        # Apply some size scaling to the text.
        self.textTransform = QTransform()
        self.textTransform.scale(self.priceTimeVectorTextXScaling, \
                                 self.priceTimeVectorTextYScaling)
        textItem.setTransform(self.textTransform)

        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Width of the horizontal bar drawn.
        self.priceTimeVectorGraphicsItemBarWidth = \
            priceBarChartSettings.\
                priceTimeVectorGraphicsItemBarWidth 
 
        # X scaling of the text.
        self.priceTimeVectorTextXScaling = \
            priceBarChartSettings.\
                priceTimeVectorGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.priceTimeVectorTextYScaling = \
            priceBarChartSettings.\
                priceTimeVectorGraphicsItemTextYScaling 

        # Font.
        self.priceTimeVectorTextFont = QFont()
        self.priceTimeVectorTextFont.fromString(\
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.priceTimeVectorGraphicsItemTextColor = \
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemTextColor

        # Color of the item.
        self.priceTimeVectorGraphicsItemColor = \
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemColor

        # PriceTimeVectorGraphicsItem showDistanceTextFlag (bool).
        self.showDistanceTextFlag = \
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemShowDistanceTextFlag
    
        # PriceTimeVectorGraphicsItem showSqrtDistanceTextFlag (bool).
        self.showSqrtDistanceTextFlag = \
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemShowSqrtDistanceTextFlag
    
        # PriceTimeVectorGraphicsItem showDistanceScaledValueTextFlag (bool).
        self.showDistanceScaledValueTextFlag = \
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemShowDistanceScaledValueTextFlag
    
        # PriceTimeVectorGraphicsItem
        # showSqrtDistanceScaledValueTextFlag (bool).
        self.showSqrtDistanceScaledValueTextFlag = \
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemShowSqrtDistanceScaledValueTextFlag
    
        # PriceTimeVectorGraphicsItem tiltedTextFlag (bool).
        self.tiltedTextFlag = \
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemTiltedTextFlag

        # PriceTimeVectorGraphicsItem angleTextFlag (bool).
        self.angleTextFlag = \
            priceBarChartSettings.\
            priceTimeVectorGraphicsItemAngleTextFlag

        ####################################################################

        # Set the new color of the pen for drawing the bar.
        self.priceTimeVectorPen.\
            setColor(self.priceTimeVectorGraphicsItemColor)

        # Set the text item with the properties we want it to have.
        self.reApplyTextItemAttributes(self.textItem)
        
        # Need to recalculate the priceTimeVector, since the scaling
        # or start/end points could have changed.  Note, if no scene
        # has been set for the QGraphicsView, then the price
        # retracements will be zero, since it can't look up
        # PriceBarGraphicsItems in the scene.
        self.recalculatePriceTimeVector()

        # Update the priceTimeVector text item position.
        self._updateTextItemPositions()
        
        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculatePriceTimeVector()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosY = event.scenePos().y()
            self.log.debug("DEBUG: scenePosY={}".format(scenePosY))
            
            startingPointY = self.startPointF.y()
            self.log.debug("DEBUG: startingPointY={}".format(startingPointY))
            endingPointY = self.endPointF.y()
            self.log.debug("DEBUG: endingPointY={}".format(endingPointY))
            
            diff = endingPointY - startingPointY
            self.log.debug("DEBUG: diff={}".format(diff))

            startThresholdY = startingPointY + (diff * (1.0 / 5))
            endThresholdY = endingPointY - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThresholdY={}".format(startThresholdY))
            self.log.debug("DEBUG: endThresholdY={}".format(endThresholdY))


            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThresholdX = startingPointX + (diff * (1.0 / 5))
            endThresholdX = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThresholdX={}".format(startThresholdX))
            self.log.debug("DEBUG: endThresholdX={}".format(endThresholdX))


            if startingPointY <= scenePosY <= startThresholdY or \
                   startingPointY >= scenePosY >= startThresholdY or \
                   startingPointX <= scenePosX <= startThresholdX or \
                   startingPointX >= scenePosX >= startThresholdX:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointY <= scenePosY <= endThresholdY or \
                     endingPointY >= scenePosY >= endThresholdY or \
                     endingPointX <= scenePosX <= endThresholdX or \
                     endingPointX >= scenePosX >= endThresholdX:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                self.origStartPointF = QPointF(self.startPointF)
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                event.scenePos().y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              event.scenePos().y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)

                    # For some reason, setPos() is not getting called
                    # until after the user releases the mouse button
                    # after dragging.  So here we will calculate the
                    # change ourselves and call setPos ourselves so
                    # that the item is drawn correctly.
                    delta = event.scenePos() - self.clickScenePointF
                    if delta.x() != 0.0 and delta.y() != 0.0:
                        newPos = self.origStartPointF + delta
                        self.setPos(newPos)
                    
                    # Calculate Update calculation/text for the
                    # retracement.
                    self.recalculatePriceTimeVector()

                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.origStartPointF + delta
                    self.setPos(newPos)
            
                    # Update calculation/text.
                    self.recalculatePriceTimeVector()
        
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshItem(self):
        """Refreshes the item by recalculating and updating the text
        position/rotation.
        """

        self.recalculatePriceTimeVector()
        
        self._updateTextItemPositions()
        
    def _updateTextItemPositions(self):
        """Updates the location of the internal text items based on
        where the start and end points are.
        """
        
        # Update the priceTimeVector label position.
        
        # X and Y range.  Used in calculations for the Y coordinate of
        # the text items.
        deltaY = self.endPointF.y() - self.startPointF.y()
        deltaX = self.endPointF.x() - self.startPointF.x()

        self.log.debug("deltaY = {}".format(deltaY))
        self.log.debug("deltaX = {}".format(deltaX))
        
        # Get bounding rectangles of text items.
        boundingRect = self.textItem.boundingRect()

        # Find largest text height and width.
        largestTextHeight = boundingRect.height()
        largestTextWidth = boundingRect.width()

        # Now replace the above with the scaled version of it. 
        largestTextHeight = largestTextHeight * self.textTransform.m22()
        largestTextWidth = largestTextWidth * self.textTransform.m11()

        self.log.debug("largestTextHeight = {}".format(largestTextHeight))
        self.log.debug("largestTextWidth = {}".format(largestTextWidth))
        
        # Get the x and y of the point to place the text, referenced
        # on the line from start point to end point, but offset by a
        # certain amount such that the largest text would be centered
        # on the line.
        midX = self.mapFromScene(\
            QPointF(self.startPointF.x() + (deltaX * 0.5), 0.0)).x()
        midY = self.mapFromScene(\
            QPointF(0.0, self.startPointF.y() + (deltaY * 0.5))).y()

        self.log.debug("midX={}, midY={}".format(midX, midY))
                       
        if self.tiltedTextFlag == True:
            # Utilize scaling of the graphics view for angle
            # calculations (if available).
            scaling = PriceBarChartScaling()
            if self.scene() != None:
                scaling = self.scene().getScaling()

            viewScaledStartPoint = \
                QPointF(self.startPointF.x() * scaling.getViewScalingX(),
                        self.startPointF.y() * scaling.getViewScalingY())
            viewScaledEndPoint = \
                QPointF(self.endPointF.x() * scaling.getViewScalingX(),
                        self.endPointF.y() * scaling.getViewScalingY())
            
            angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
            self.log.debug("angleDeg={}".format(angleDeg))

            # Normalize the angle so that the text is always upright.
            self.rotationDegrees = angleDeg
            if 90 <= self.rotationDegrees <= 270:
                self.rotationDegrees += 180
            self.rotationDegrees = \
                Util.toNormalizedAngle(self.rotationDegrees)

            # Fudge factor since for some reason the text item doesn't
            # exactly line up with the PTV line.
            fudge = 0.0
            if 0 < self.rotationDegrees <= 90:
                self.log.debug("0 to 90")
                removed = 45 - abs(45 - self.rotationDegrees)
                fudge = removed * 0.19
                self.rotationDegrees -= fudge
            elif 90 < self.rotationDegrees <= 180:
                self.log.debug("90 to 180")
                removed = 45 - abs(135 - self.rotationDegrees)
                fudge = removed * 0.12
                self.rotationDegrees += fudge
            elif 180 < self.rotationDegrees <= 270:
                self.log.debug("180 to 270")
                removed = 45 - abs(225 - self.rotationDegrees)
                fudge = removed * 0.19
                self.rotationDegrees -= fudge
            elif 270 < self.rotationDegrees <= 360:
                self.log.debug("270 to 360")
                removed = 45 - abs(315 - self.rotationDegrees)
                fudge = removed * 0.12
                self.rotationDegrees += fudge
            
            self.rotationDegrees = -1.0 * self.rotationDegrees
            self.log.debug("rotationDegrees={}".format(self.rotationDegrees))

            startX = midX
            startY = midY

            self.log.debug("startX={}, startY={}".format(startX, startY))
            
            self.textItem.setPos(QPointF(startX, startY))
            self.textItem.setRotation(self.rotationDegrees)
        else:
            startX = midX
            startY = midY

            # Amount to mutiply to get a largest offset from startY.
            offsetY = largestTextHeight

            x = startX
            y = startY - offsetY
            
            self.textItem.setPos(QPointF(x, y))


    def setStartPointF(self, pointF):
        """Sets the starting point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            if self.scene() != None:
                # Re-calculate the priceretracement.
                self.recalculatePriceTimeVector()
                self.prepareGeometryChange()
                
            # Update the priceTimeVector text item position.
            self._updateTextItemPositions()
            
    def setEndPointF(self, pointF):
        """Sets the ending point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            if self.scene() != None:
                # Re-calculate the priceretracement.
                self.recalculatePriceTimeVector()
                self.prepareGeometryChange()

            # Update the priceTimeVector text item position.
            self._updateTextItemPositions()
            
    def normalizeStartAndEnd(self):
        """Does not do anything since normalization is not applicable
        to this graphics item.
        """

        # Do don't anything.
        pass

    def recalculatePriceTimeVector(self):
        """Recalculates the priceTimeVector and sets the text items'
        text accordingly.
        """

        scene = self.scene()

        # X and Y range.
        deltaY = self.endPointF.y() - self.startPointF.y()
        deltaX = self.endPointF.x() - self.startPointF.x()

        # Text to set in the text item.
        text = ""
        
        if scene != None:
            # Calculate the values for the PriceTimeVector.
            line = QLineF(self.startPointF, self.endPointF)
            self.distance = abs(line.length())
            self.sqrtDistance = math.pow(self.distance, 0.5)

            scaledValueLine = \
                QLineF(scene.convertScenePointToScaledPoint(self.startPointF),
                       scene.convertScenePointToScaledPoint(self.endPointF))
            self.distanceScaledValue = abs(scaledValueLine.length())
            self.sqrtDistanceScaledValue = \
                math.pow(self.distanceScaledValue, 0.5)
            
            # Append text.
            if self.showDistanceTextFlag == True:
                text += "d={:.3f}".\
                    format(self.distance) + os.linesep
            if self.showSqrtDistanceTextFlag == True:
                text += "sqrt(d)={:.3f}".\
                    format(self.sqrtDistance) + os.linesep
            if self.showDistanceScaledValueTextFlag == True:
                text += "d_u={:.3f}".\
                    format(self.distanceScaledValue) + os.linesep
            if self.showSqrtDistanceScaledValueTextFlag == True:
                text += "sqrt(d_u)={:.3f}".\
                    format(self.sqrtDistanceScaledValue) + os.linesep
            if self.angleTextFlag == True:
                # Subtract from 30 since the angle given is in the
                # opposite rotational direction from what we want to
                # display it as.
                angle = 360.0 - scaledValueLine.angle()

                # Show downward angles as negative instead of from 270 to 360.
                if 270.0 <= angle < 360.0:
                    angle -= 360.0

                # Text as the scaled angle.
                text += "{:.3f} deg".format(angle) + os.linesep
        else:
            # No scene, so keep text empty.
            text = ""

        text = text.rstrip()
        self.textItem.setText(text)
        self.prepareGeometryChange()
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartPriceTimeVectorArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartPriceTimeVectorArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartPriceTimeVectorArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartPriceTimeVectorArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.priceTimeVectorTextXScaling = self.artifact.getTextXScaling()
        self.priceTimeVectorTextYScaling = self.artifact.getTextYScaling()
        self.priceTimeVectorTextFont = self.artifact.getFont()
        self.priceTimeVectorGraphicsItemTextColor = \
            self.artifact.getTextColor()
        self.priceTimeVectorPen.setColor(self.artifact.getColor())
        
        self.showDistanceTextFlag = \
            self.artifact.getShowDistanceTextFlag()
        self.showSqrtDistanceTextFlag = \
            self.artifact.getShowSqrtDistanceTextFlag()
        self.showDistanceScaledValueTextFlag = \
            self.artifact.getShowDistanceScaledValueTextFlag()
        self.showSqrtDistanceScaledValueTextFlag = \
            self.artifact.getShowSqrtDistanceScaledValueTextFlag()
        self.tiltedTextFlag = self.artifact.getTiltedTextFlag()
        self.angleTextFlag = self.artifact.getAngleTextFlag()

        #############

        # Set the position.
        self.textItem.setPos(self.endPointF)

        # Apply current attributes like color, brush, etc.
        self.reApplyTextItemAttributes(self.textItem)

        # Need to recalculate the priceTimeVector, since the scaling
        # or start/end points may have changed.  Note, if no scene has
        # been set for the QGraphicsView, then the price retracements
        # will be zero, since it can't look up PriceBarGraphicsItems
        # in the scene.
        self.recalculatePriceTimeVector()

        # Update the priceTimeVector text item position.
        self._updateTextItemPositions()
        
        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartPriceTimeVectorArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartPriceTimeVectorArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)

        self.artifact.setTextXScaling(self.priceTimeVectorTextXScaling)
        self.artifact.setTextYScaling(self.priceTimeVectorTextYScaling)
        self.artifact.setFont(self.priceTimeVectorTextFont)
        self.artifact.setTextColor(self.priceTimeVectorGraphicsItemTextColor)
        self.artifact.setColor(self.priceTimeVectorPen.color())
        
        self.artifact.setShowDistanceTextFlag(self.showDistanceTextFlag)
        self.artifact.setShowSqrtDistanceTextFlag(self.showSqrtDistanceTextFlag)
        self.artifact.setShowDistanceScaledValueTextFlag(\
            self.showDistanceScaledValueTextFlag)
        self.artifact.setShowSqrtDistanceScaledValueTextFlag(\
            self.showSqrtDistanceScaledValueTextFlag)
        self.artifact.setTiltedTextFlag(self.tiltedTextFlag)
        self.artifact.setAngleTextFlag(self.angleTextFlag)

        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the startPointF.
        # If the user created the widget with the startPointF to the
        # right of the endPointF, then the startPointF will have a
        # higher X value than endPointF.

        # The QRectF returned is relative to this (0, 0) point.

        textItemRectTopLeft = \
            self.textItem.mapToParent(\
            self.textItem.boundingRect().topLeft())
        textItemRectBottomRight = \
            self.textItem.mapToParent(\
            self.textItem.boundingRect().bottomRight())
        
        rv = self.shape().boundingRect() | \
             QRectF(textItemRectTopLeft, textItemRectBottomRight)
        
        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Calculate the points that would be the selection box area
        # around the line.

        # Start and end points in local coordinates.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)

        # Utilize scaling from the scene if it is available.
        scaling = PriceBarChartScaling()
        if self.scene() != None:
            scaling = self.scene().getScaling()
            
        viewScaledStartPoint = \
            QPointF(self.startPointF.x() * scaling.getViewScalingX(),
                    self.startPointF.y() * scaling.getViewScalingY())
        viewScaledEndPoint = \
            QPointF(self.endPointF.x() * scaling.getViewScalingX(),
                    self.endPointF.y() * scaling.getViewScalingY())

        # Here we are calculating the angle of the text and the line
        # as the user would see it.  Actual angle is different if we
        # are calculating it from a scene perspective.
        angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
        angleRad = math.radians(angleDeg)

        shiftX = math.sin(angleRad) * \
                     (0.5 * self.priceTimeVectorGraphicsItemBarWidth) / \
                     scaling.getViewScalingX()
        
        shiftY = math.cos(angleRad) * \
                     (0.5 * self.priceTimeVectorGraphicsItemBarWidth) / \
                     scaling.getViewScalingY()

        self.log.debug("shiftX={}, shiftY={}".format(shiftX, shiftY))
        
        # Create new points.
        p1 = \
            QPointF(localStartPointF.x() - shiftX,
                    localStartPointF.y() - shiftY)
        p2 = \
            QPointF(localStartPointF.x() + shiftX,
                    localStartPointF.y() + shiftY)
        p3 = \
            QPointF(localEndPointF.x() - shiftX,
                    localEndPointF.y() - shiftY)
        p4 = \
            QPointF(localEndPointF.x() + shiftX,
                    localEndPointF.y() + shiftY)
        
        points = [p2, p1, p3, p4, p2]
        polygon = QPolygonF(points)

        painterPath = QPainterPath()
        painterPath.addPolygon(polygon)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.priceTimeVectorPen is set to what we want for the drawing
        style.
        """

        self.log.debug("PriceTimeVectorGraphicsItem.paint()")
        
        if painter.pen() != self.priceTimeVectorPen:
            painter.setPen(self.priceTimeVectorPen)
        
        # Draw the line.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)
        painter.drawLine(QLineF(localStartPointF, localEndPointF))
        
        # Draw the shape if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.priceTimeVectorPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PriceTimeVectorGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        PriceTimeVectorGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceTimeVectorArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPriceTimeVectorArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the PriceTimeVectorGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the PriceTimeVectorGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the PriceTimeVectorGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        PriceTimeVectorGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        PriceTimeVectorGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the PriceTimeVectorGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the PriceTimeVectorGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the PriceTimeVectorGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        PriceTimeVectorGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        PriceTimeVectorGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        

class LineSegmentGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a line segment in the GraphicsView.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger(\
            "pricebarchart.LineSegmentGraphicsItem")
        
        self.log.debug("Entered __init__().")

        # Constant value for the multiple amount to extend the start
        # or end points.  This feature shows up as an option in the
        # right-click context menu option.
        self.extendMultiple = 1.6
        
        ############################################################
        # Set default values for preferences/settings.
        
        # Width of the vertical bar drawn.
        self.lineSegmentGraphicsItemBarWidth = \
            PriceBarChartSettings.\
                defaultLineSegmentGraphicsItemBarWidth 
 
        # X scaling of the text.
        self.lineSegmentTextXScaling = \
            PriceBarChartSettings.\
                defaultLineSegmentGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.lineSegmentTextYScaling = \
            PriceBarChartSettings.\
                defaultLineSegmentGraphicsItemTextYScaling 

        # Font.
        self.lineSegmentTextFont = QFont()
        self.lineSegmentTextFont.fromString(\
            PriceBarChartSettings.\
            defaultLineSegmentGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.lineSegmentGraphicsItemTextColor = \
            PriceBarChartSettings.\
            defaultLineSegmentGraphicsItemTextColor

        # Color of the item.
        self.lineSegmentGraphicsItemColor = \
            PriceBarChartSettings.\
            defaultLineSegmentGraphicsItemColor

        # LineSegmentGraphicsItem tiltedTextFlag (bool).
        self.tiltedTextFlag = \
            PriceBarChartSettings.\
            defaultLineSegmentGraphicsItemTiltedTextFlag
    
        # LineSegmentGraphicsItem angleTextFlag (bool).
        self.angleTextFlag = \
            PriceBarChartSettings.\
            defaultLineSegmentGraphicsItemAngleTextFlag
    
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartLineSegmentArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.lineSegmentPenWidth = 0.0
        self.lineSegmentPen = QPen()
        self.lineSegmentPen.\
            setColor(self.lineSegmentGraphicsItemColor)
        self.lineSegmentPen.\
            setWidthF(self.lineSegmentPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Degrees of text rotation.
        self.rotationDegrees = 0.0

        # Internal text item.
        self.textItem = QGraphicsSimpleTextItem("", self)
        self.textItem.setPos(self.endPointF)

        # Transform object applied to the text item.
        self.textTransform = QTransform()

        # Set the text item with the properties we want it to have.
        self.reApplyTextItemAttributes(self.textItem)

        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        
        # Working variables for clicking and draging.
        self.clickScenePointF = None
        self.origStartPointF = None

    def reApplyTextItemAttributes(self, textItem):
        """Takes the given text item and reapplies the pen, brush,
        transform, etc. that should be set for the text item.
        """
        
        # Set properties of the text item.
        
        # Set the font of the text.
        textItem.setFont(self.lineSegmentTextFont)
        
        # Set the pen color of the text.
        self.lineSegmentTextPen = textItem.pen()
        self.lineSegmentTextPen.\
            setColor(self.lineSegmentGraphicsItemTextColor)
        textItem.setPen(self.lineSegmentTextPen)

        # Set the brush color of the text.
        self.lineSegmentTextBrush = textItem.brush()
        self.lineSegmentTextBrush.\
            setColor(self.lineSegmentGraphicsItemTextColor)
        textItem.setBrush(self.lineSegmentTextBrush)

        # Apply some size scaling to the text.
        self.textTransform = QTransform()
        self.textTransform.scale(self.lineSegmentTextXScaling, \
                                 self.lineSegmentTextYScaling)
        textItem.setTransform(self.textTransform)

    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings,
                                              lineSegmentNumberType=1):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.

        Parameters:
        
        priceBarChartSettings - PriceBarChartSettings object from which
                                to pull settings information from.
        
        lineSegmentNumberType - int value that is either 1 or 2,
                                depending on the tool mode being used
                                to create the LineSegmentGraphicsItem.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        if lineSegmentNumberType == 1:
            
            # Width of the horizontal bar drawn.
            self.lineSegmentGraphicsItemBarWidth = \
                priceBarChartSettings.\
                    lineSegment1GraphicsItemBarWidth 
     
            # X scaling of the text.
            self.lineSegmentTextXScaling = \
                priceBarChartSettings.\
                    lineSegment1GraphicsItemTextXScaling 
    
            # Y scaling of the text.
            self.lineSegmentTextYScaling = \
                priceBarChartSettings.\
                    lineSegment1GraphicsItemTextYScaling 
    
            # Font.
            self.lineSegmentTextFont = QFont()
            self.lineSegmentTextFont.fromString(\
                priceBarChartSettings.\
                lineSegment1GraphicsItemDefaultFontDescription)
            
            # Color of the text that is associated with the graphicsitem.
            self.lineSegmentGraphicsItemTextColor = \
                priceBarChartSettings.\
                lineSegment1GraphicsItemTextColor
    
            # Color of the item.
            self.lineSegmentGraphicsItemColor = \
                priceBarChartSettings.\
                lineSegment1GraphicsItemColor
    
            # LineSegmentGraphicsItem tiltedTextFlag (bool).
            self.tiltedTextFlag = \
                priceBarChartSettings.\
                lineSegment1GraphicsItemTiltedTextFlag
    
            # LineSegmentGraphicsItem angleTextFlag (bool).
            self.angleTextFlag = \
                priceBarChartSettings.\
                lineSegment1GraphicsItemAngleTextFlag
    
        elif lineSegmentNumberType == 2:
            
            # Width of the horizontal bar drawn.
            self.lineSegmentGraphicsItemBarWidth = \
                priceBarChartSettings.\
                    lineSegment2GraphicsItemBarWidth 
     
            # X scaling of the text.
            self.lineSegmentTextXScaling = \
                priceBarChartSettings.\
                    lineSegment2GraphicsItemTextXScaling 
    
            # Y scaling of the text.
            self.lineSegmentTextYScaling = \
                priceBarChartSettings.\
                    lineSegment2GraphicsItemTextYScaling 
    
            # Font.
            self.lineSegmentTextFont = QFont()
            self.lineSegmentTextFont.fromString(\
                priceBarChartSettings.\
                lineSegment2GraphicsItemDefaultFontDescription)
            
            # Color of the text that is associated with the graphicsitem.
            self.lineSegmentGraphicsItemTextColor = \
                priceBarChartSettings.\
                lineSegment2GraphicsItemTextColor
    
            # Color of the item.
            self.lineSegmentGraphicsItemColor = \
                priceBarChartSettings.\
                lineSegment2GraphicsItemColor
    
            # LineSegmentGraphicsItem tiltedTextFlag (bool).
            self.tiltedTextFlag = \
                priceBarChartSettings.\
                lineSegment2GraphicsItemTiltedTextFlag
    
            # LineSegmentGraphicsItem angleTextFlag (bool).
            self.angleTextFlag = \
                priceBarChartSettings.\
                lineSegment2GraphicsItemAngleTextFlag
    
        else:
            
            self.log.error("Unknown or invalid lineSegmentNumberType.  " + \
                           "No PriceBarChartSettings were loaded.")
            
        ####################################################################

        # Set the new color of the pen for drawing the bar.
        self.lineSegmentPen.\
            setColor(self.lineSegmentGraphicsItemColor)

        # Set the text item with the properties we want it to have.
        self.reApplyTextItemAttributes(self.textItem)
        
        # Need to recalculate the lineSegment, since the scaling
        # or start/end points could have changed.  Note, if no scene
        # has been set for the QGraphicsView, then the price
        # retracements will be zero, since it can't look up
        # PriceBarGraphicsItems in the scene.
        self.recalculateLineSegment()

        # Update the lineSegment text item position.
        self._updateTextItemPositions()
        
        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculateLineSegment()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosY = event.scenePos().y()
            self.log.debug("DEBUG: scenePosY={}".format(scenePosY))
            
            startingPointY = self.startPointF.y()
            self.log.debug("DEBUG: startingPointY={}".format(startingPointY))
            endingPointY = self.endPointF.y()
            self.log.debug("DEBUG: endingPointY={}".format(endingPointY))
            
            diff = endingPointY - startingPointY
            self.log.debug("DEBUG: diff={}".format(diff))

            startThresholdY = startingPointY + (diff * (1.0 / 5))
            endThresholdY = endingPointY - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThresholdY={}".format(startThresholdY))
            self.log.debug("DEBUG: endThresholdY={}".format(endThresholdY))


            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThresholdX = startingPointX + (diff * (1.0 / 5))
            endThresholdX = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThresholdX={}".format(startThresholdX))
            self.log.debug("DEBUG: endThresholdX={}".format(endThresholdX))


            if startingPointY <= scenePosY <= startThresholdY or \
                   startingPointY >= scenePosY >= startThresholdY or \
                   startingPointX <= scenePosX <= startThresholdX or \
                   startingPointX >= scenePosX >= startThresholdX:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointY <= scenePosY <= endThresholdY or \
                     endingPointY >= scenePosY >= endThresholdY or \
                     endingPointX <= scenePosX <= endThresholdX or \
                     endingPointX >= scenePosX >= endThresholdX:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                self.origStartPointF = QPointF(self.startPointF)
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                event.scenePos().y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              event.scenePos().y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)

                    # For some reason, setPos() is not getting called
                    # until after the user releases the mouse button
                    # after dragging.  So here we will calculate the
                    # change ourselves and call setPos ourselves so
                    # that the item is drawn correctly.
                    delta = event.scenePos() - self.clickScenePointF
                    if delta.x() != 0.0 and delta.y() != 0.0:
                        newPos = self.origStartPointF + delta
                        self.setPos(newPos)
                    
                    # Calculate Update calculation/text for the
                    # retracement.
                    self.recalculateLineSegment()

                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.origStartPointF + delta
                    self.setPos(newPos)
            
                    # Update calculation/text.
                    self.recalculateLineSegment()
        
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshItem(self):
        """Refreshes the item by recalculating and updating the text
        position/rotation.
        """

        self.recalculateLineSegment()
        
        self._updateTextItemPositions()
        
    def _updateTextItemPositions(self):
        """Updates the location of the internal text items based on
        where the start and end points are.
        """
        
        # Update the lineSegment label position.
        
        # X and Y range.  Used in calculations for the Y coordinate of
        # the text items.
        deltaY = self.endPointF.y() - self.startPointF.y()
        deltaX = self.endPointF.x() - self.startPointF.x()

        self.log.debug("deltaY = {}".format(deltaY))
        self.log.debug("deltaX = {}".format(deltaX))
        
        # Get bounding rectangles of text items.
        boundingRect = self.textItem.boundingRect()

        # Find largest text height and width.
        largestTextHeight = boundingRect.height()
        largestTextWidth = boundingRect.width()

        # Now replace the above with the scaled version of it. 
        largestTextHeight = largestTextHeight * self.textTransform.m22()
        largestTextWidth = largestTextWidth * self.textTransform.m11()

        self.log.debug("largestTextHeight = {}".format(largestTextHeight))
        self.log.debug("largestTextWidth = {}".format(largestTextWidth))
        
        # Get the x and y of the point to place the text, referenced
        # on the line from start point to end point, but offset by a
        # certain amount such that the largest text would be centered
        # on the line.
        midX = self.mapFromScene(\
            QPointF(self.startPointF.x() + (deltaX * 0.5), 0.0)).x()
        midY = self.mapFromScene(\
            QPointF(0.0, self.startPointF.y() + (deltaY * 0.5))).y()

        self.log.debug("midX={}, midY={}".format(midX, midY))
                       
        if self.tiltedTextFlag == True:
            # Utilize scaling of the graphics view for angle
            # calculations (if available).
            scaling = PriceBarChartScaling()
            if self.scene() != None:
                scaling = self.scene().getScaling()

            viewScaledStartPoint = \
                QPointF(self.startPointF.x() * scaling.getViewScalingX(),
                        self.startPointF.y() * scaling.getViewScalingY())
            viewScaledEndPoint = \
                QPointF(self.endPointF.x() * scaling.getViewScalingX(),
                        self.endPointF.y() * scaling.getViewScalingY())
            
            angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
            self.log.debug("angleDeg={}".format(angleDeg))

            # Normalize the angle so that the text is always upright.
            self.rotationDegrees = angleDeg
            if 90 <= self.rotationDegrees <= 270:
                self.rotationDegrees += 180
            self.rotationDegrees = \
                Util.toNormalizedAngle(self.rotationDegrees)

            # Fudge factor since for some reason the text item doesn't
            # exactly line up with the PTV line.
            fudge = 0.0
            if 0 < self.rotationDegrees <= 90:
                self.log.debug("0 to 90")
                removed = 45 - abs(45 - self.rotationDegrees)
                fudge = removed * 0.19
                self.rotationDegrees -= fudge
            elif 90 < self.rotationDegrees <= 180:
                self.log.debug("90 to 180")
                removed = 45 - abs(135 - self.rotationDegrees)
                fudge = removed * 0.12
                self.rotationDegrees += fudge
            elif 180 < self.rotationDegrees <= 270:
                self.log.debug("180 to 270")
                removed = 45 - abs(225 - self.rotationDegrees)
                fudge = removed * 0.19
                self.rotationDegrees -= fudge
            elif 270 < self.rotationDegrees <= 360:
                self.log.debug("270 to 360")
                removed = 45 - abs(315 - self.rotationDegrees)
                fudge = removed * 0.12
                self.rotationDegrees += fudge
            
            self.rotationDegrees = -1.0 * self.rotationDegrees
            self.log.debug("rotationDegrees={}".format(self.rotationDegrees))

            startX = midX
            startY = midY

            self.log.debug("startX={}, startY={}".format(startX, startY))
            
            self.textItem.setPos(QPointF(startX, startY))
            self.textItem.setRotation(self.rotationDegrees)
        else:
            startX = midX
            startY = midY

            # Amount to mutiply to get a largest offset from startY.
            offsetY = largestTextHeight

            x = startX
            y = startY - offsetY
            
            self.textItem.setPos(QPointF(x, y))


    def setStartPointF(self, pointF):
        """Sets the starting point of the LineSegmentGraphicsItem.  
        The value passed in is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            if self.scene() != None:
                # Re-calculate the priceretracement.
                self.recalculateLineSegment()
                self.prepareGeometryChange()
                
            # Update the lineSegment text item position.
            self._updateTextItemPositions()
            
    def setEndPointF(self, pointF):
        """Sets the ending point of the LineSegmentGraphicsItem.  
        The value passed in is the mouse location in scene coordinates.
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            if self.scene() != None:
                # Re-calculate the priceretracement.
                self.recalculateLineSegment()
                self.prepareGeometryChange()

            # Update the lineSegment text item position.
            self._updateTextItemPositions()
            
    def normalizeStartAndEnd(self):
        """Does not do anything since normalization is not applicable
        to this graphics item.
        """

        # Do don't anything.
        pass

    def recalculateLineSegment(self):
        """Recalculates the lineSegment and sets the text items'
        text accordingly.
        """

        scene = self.scene()

        # X and Y range.
        deltaY = self.endPointF.y() - self.startPointF.y()
        deltaX = self.endPointF.x() - self.startPointF.x()

        # Text to set in the text item.
        text = ""
        
        if scene != None:
            # Calculate the angle for the scaled LineSegment.
            scaledValueLine = \
                QLineF(scene.convertScenePointToScaledPoint(self.startPointF),
                       scene.convertScenePointToScaledPoint(self.endPointF))
            
            # Set the text.
            if self.angleTextFlag == True:
                # Subtract from 30 since the angle given is in the
                # opposite rotational direction from what we want to
                # display it as.
                angle = 360.0 - scaledValueLine.angle()

                # Show downward angles as negative instead of from 270 to 360.
                if 270.0 <= angle < 360.0:
                    angle -= 360.0

                # Text as the scaled angle.
                text += "{:.4f} deg".format(angle) + os.linesep
        else:
            # No scene, so keep text empty.
            text = ""

        text = text.rstrip()
        self.textItem.setText(text)
        self.prepareGeometryChange()
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartLineSegmentArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartLineSegmentArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartLineSegmentArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartLineSegmentArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.lineSegmentTextXScaling = self.artifact.getTextXScaling()
        self.lineSegmentTextYScaling = self.artifact.getTextYScaling()
        self.lineSegmentTextFont = self.artifact.getFont()
        self.lineSegmentGraphicsItemTextColor = \
            self.artifact.getTextColor()
        self.lineSegmentPen.setColor(self.artifact.getColor())
        
        self.tiltedTextFlag = self.artifact.getTiltedTextFlag()
        self.angleTextFlag = self.artifact.getAngleTextFlag()

        #############

        # Set the position.
        self.textItem.setPos(self.endPointF)

        # Apply current attributes like color, brush, etc.
        self.reApplyTextItemAttributes(self.textItem)

        # Need to recalculate the lineSegment, since the scaling
        # or start/end points may have changed.  Note, if no scene has
        # been set for the QGraphicsView, then the price retracements
        # will be zero, since it can't look up PriceBarGraphicsItems
        # in the scene.
        self.recalculateLineSegment()

        # Update the lineSegment text item position.
        self._updateTextItemPositions()
        
        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartLineSegmentArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartLineSegmentArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)

        self.artifact.setTextXScaling(self.lineSegmentTextXScaling)
        self.artifact.setTextYScaling(self.lineSegmentTextYScaling)
        self.artifact.setFont(self.lineSegmentTextFont)
        self.artifact.setTextColor(self.lineSegmentGraphicsItemTextColor)
        self.artifact.setColor(self.lineSegmentPen.color())
        
        self.artifact.setTiltedTextFlag(self.tiltedTextFlag)
        self.artifact.setAngleTextFlag(self.angleTextFlag)

        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the startPointF.
        # If the user created the widget with the startPointF to the
        # right of the endPointF, then the startPointF will have a
        # higher X value than endPointF.

        # The QRectF returned is relative to this (0, 0) point.

        textItemRectTopLeft = \
            self.textItem.mapToParent(\
            self.textItem.boundingRect().topLeft())
        textItemRectBottomRight = \
            self.textItem.mapToParent(\
            self.textItem.boundingRect().bottomRight())
                                
        rv = self.shape().boundingRect() | \
             QRectF(textItemRectTopLeft, textItemRectBottomRight)

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Calculate the points that would be the selection box area
        # around the line.

        # Start and end points in local coordinates.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)

        # Utilize scaling from the scene if it is available.
        scaling = PriceBarChartScaling()
        if self.scene() != None:
            scaling = self.scene().getScaling()
            
        viewScaledStartPoint = \
            QPointF(self.startPointF.x() * scaling.getViewScalingX(),
                    self.startPointF.y() * scaling.getViewScalingY())
        viewScaledEndPoint = \
            QPointF(self.endPointF.x() * scaling.getViewScalingX(),
                    self.endPointF.y() * scaling.getViewScalingY())

        # Here we are calculating the angle of the text and the line
        # as the user would see it.  Actual angle is different if we
        # are calculating it from a scene perspective.
        angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
        angleRad = math.radians(angleDeg)
        
        shiftX = math.sin(angleRad) * \
                     (0.5 * self.lineSegmentGraphicsItemBarWidth) / \
                     scaling.getViewScalingX()
        
        shiftY = math.cos(angleRad) * \
                     (0.5 * self.lineSegmentGraphicsItemBarWidth) / \
                     scaling.getViewScalingY()

        # Create new points.
        p1 = \
            QPointF(localStartPointF.x() - shiftX,
                    localStartPointF.y() - shiftY)
        p2 = \
            QPointF(localStartPointF.x() + shiftX,
                    localStartPointF.y() + shiftY)
        p3 = \
            QPointF(localEndPointF.x() - shiftX,
                    localEndPointF.y() - shiftY)
        p4 = \
            QPointF(localEndPointF.x() + shiftX,
                    localEndPointF.y() + shiftY)

        points = [p2, p1, p3, p4, p2]
        polygon = QPolygonF(points)

        painterPath = QPainterPath()
        painterPath.addPolygon(polygon)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.lineSegmentPen is set
        to what we want for the drawing style.
        """

        self.log.debug("LineSegmentGraphicsItem.paint()")
        
        if painter.pen() != self.lineSegmentPen:
            painter.setPen(self.lineSegmentPen)
        
        # Draw the line.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)
        painter.drawLine(QLineF(localStartPointF, localEndPointF))
        
        # Draw the shape if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.lineSegmentPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this LineSegmentGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        LineSegmentGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        extendEndPointAction = \
            QAction("E&xtend end point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenEndPointAction = \
            QAction("Shor&ten end point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        extendStartPointAction = \
            QAction("Exte&nd start point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenStartPointAction = \
            QAction("S&horten start point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        extendEndPointAction.triggered.\
            connect(self._handleExtendEndPointAction)
        shortenEndPointAction.triggered.\
            connect(self._handleShortenEndPointAction)
        extendStartPointAction.triggered.\
            connect(self._handleExtendStartPointAction)
        shortenStartPointAction.triggered.\
            connect(self._handleShortenStartPointAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        extendEndPointAction.setEnabled(not readOnlyMode)
        shortenEndPointAction.setEnabled(not readOnlyMode)
        extendStartPointAction.setEnabled(not readOnlyMode)
        shortenStartPointAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(extendEndPointAction)
        menu.addAction(shortenEndPointAction)
        menu.addAction(extendStartPointAction)
        menu.addAction(shortenStartPointAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartLineSegmentArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartLineSegmentArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleExtendEndPointAction(self):
        """Updates the QGraphicsItem so that the end point is
        (self.extendMultiple) fold of the current distance away from start
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.startPointF.x() + offsetX
        newEndPointY = self.startPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setEndPointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setEndPointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenEndPointAction(self):
        """Updates the QGraphicsItem so that the end point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        start point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.startPointF.x() + offsetX
        newEndPointY = self.startPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setEndPointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setEndPointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleExtendStartPointAction(self):
        """Updates the QGraphicsItem so that the start point is
        (self.extendMultiple) fold of the current distance away from
        end point.  The artifact is edited too to correspond with this
        change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new start point X and Y values.
        newStartPointX = self.endPointF.x() - offsetX
        newStartPointY = self.endPointF.y() - offsetY

        # Update the QGraphicsItem manually.
        newStartPointF = QPointF(newStartPointX, newStartPointY)
        
        # Call the parent version for setPos(), not the self version
        # because the self version moves both the start and end
        # points.  We want to keep the end point the same.
        super().setPos(newStartPointF)
        self.startPointF = newStartPointF
        
        # Update the artifact.
        self.artifact.setPos(self.startPointF)
        self.artifact.setStartPointF(self.startPointF)

        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenStartPointAction(self):
        """Updates the QGraphicsItem so that the start point is
        (1.0 / self.extendMultiple) fold of the current distance away
        from end point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new start point X and Y values.
        newStartPointX = self.endPointF.x() - offsetX
        newStartPointY = self.endPointF.y() - offsetY

        # Update the QGraphicsItem manually.
        newStartPointF = QPointF(newStartPointX, newStartPointY)
        
        # Call the parent version for setPos(), not the self version
        # because the self version moves both the start and end
        # points.  We want to keep the end point the same.
        super().setPos(newStartPointF)
        self.startPointF = newStartPointF
        
        # Update the artifact.
        self.artifact.setPos(self.startPointF)
        self.artifact.setStartPointF(self.startPointF)

        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the LineSegmentGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the LineSegmentGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the LineSegmentGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        LineSegmentGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        LineSegmentGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the LineSegmentGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the LineSegmentGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the LineSegmentGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        LineSegmentGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        LineSegmentGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        

class VerticalLineSegmentGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a line segment in the GraphicsView.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger(\
            "pricebarchart.VerticalLineSegmentGraphicsItem")
        
        self.log.debug("Entered __init__().")

        # Constant value for the multiple amount to extend the start
        # or end points.  This feature shows up as an option in the
        # right-click context menu option.
        self.extendMultiple = 1.6
        
        ############################################################
        # Set default values for preferences/settings.
        
        # Width of the vertical bar drawn.
        self.lineSegmentGraphicsItemBarWidth = \
            PriceBarChartSettings.\
                defaultVerticalLineSegmentGraphicsItemBarWidth 
 
        # Color of the item.
        self.lineSegmentGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultVerticalLineSegmentGraphicsItemColor

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartVerticalLineSegmentArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.lineSegmentPenWidth = 0.0
        self.lineSegmentPen = QPen()
        self.lineSegmentPen.\
            setColor(self.lineSegmentGraphicsItemColor)
        self.lineSegmentPen.\
            setWidthF(self.lineSegmentPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        
        # Working variables for clicking and draging.
        self.clickScenePointF = None
        self.origStartPointF = None

    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.

        Parameters:
        
        priceBarChartSettings - PriceBarChartSettings object from which
                                to pull settings information from.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Width of the horizontal bar drawn.
        self.lineSegmentGraphicsItemBarWidth = \
            priceBarChartSettings.\
            verticalLineSegmentGraphicsItemBarWidth 
     
        # Color of the item.
        self.lineSegmentGraphicsItemColor = \
            priceBarChartSettings.\
            verticalLineSegmentGraphicsItemColor
    
        ####################################################################

        # Set the new color of the pen for drawing the bar.
        self.lineSegmentPen.\
            setColor(self.lineSegmentGraphicsItemColor)

        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculateVerticalLineSegment()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosY = event.scenePos().y()
            self.log.debug("DEBUG: scenePosY={}".format(scenePosY))
            
            startingPointY = self.startPointF.y()
            self.log.debug("DEBUG: startingPointY={}".format(startingPointY))
            endingPointY = self.endPointF.y()
            self.log.debug("DEBUG: endingPointY={}".format(endingPointY))
            
            diff = endingPointY - startingPointY
            self.log.debug("DEBUG: diff={}".format(diff))

            startThresholdY = startingPointY + (diff * (1.0 / 5))
            endThresholdY = endingPointY - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThresholdY={}".format(startThresholdY))
            self.log.debug("DEBUG: endThresholdY={}".format(endThresholdY))


            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThresholdX = startingPointX + (diff * (1.0 / 5))
            endThresholdX = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThresholdX={}".format(startThresholdX))
            self.log.debug("DEBUG: endThresholdX={}".format(endThresholdX))


            if startingPointY <= scenePosY <= startThresholdY or \
                   startingPointY >= scenePosY >= startThresholdY or \
                   startingPointX <= scenePosX <= startThresholdX or \
                   startingPointX >= scenePosX >= startThresholdX:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointY <= scenePosY <= endThresholdY or \
                     endingPointY >= scenePosY >= endThresholdY or \
                     endingPointX <= scenePosX <= endThresholdX or \
                     endingPointX >= scenePosX >= endThresholdX:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                self.origStartPointF = QPointF(self.startPointF)
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    # Maintain constraint for being vertical.
                    x = self.startPointF.x()
                    self.setStartPointF(QPointF(x,
                                                event.scenePos().y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    # Maintain constraint for being vertical.
                    x = self.endPointF.x()
                    self.setEndPointF(QPointF(x,
                                              event.scenePos().y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)

                    # For some reason, setPos() is not getting called
                    # until after the user releases the mouse button
                    # after dragging.  So here we will calculate the
                    # change ourselves and call setPos ourselves so
                    # that the item is drawn correctly.
                    delta = event.scenePos() - self.clickScenePointF
                    if delta.x() != 0.0 and delta.y() != 0.0:
                        newPos = self.origStartPointF + delta
                        self.setPos(newPos)
                    
                    # Calculate Update calculation/text for the
                    # retracement.
                    self.recalculateVerticalLineSegment()

                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.origStartPointF + delta
                    self.setPos(newPos)
            
                    # Update calculation/text.
                    self.recalculateVerticalLineSegment()
        
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshItem(self):
        """Refreshes the item by recalculating and updating the text
        position/rotation.
        """

        self.recalculateVerticalLineSegment()
        
    def setStartPointF(self, pointF):
        """Sets the starting point of the
        VerticalLineSegmentGraphicsItem.  The value passed in is the
        mouse location in scene coordinates.
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            if self.scene() != None:
                self.recalculateVerticalLineSegment()
                self.prepareGeometryChange()
                
    def setEndPointF(self, pointF):
        """Sets the ending point of the
        VerticalLineSegmentGraphicsItem.  The value passed in is the
        mouse location in scene coordinates.
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            if self.scene() != None:
                self.recalculateVerticalLineSegment()
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Does not do anything since normalization is not applicable
        to this graphics item.
        """

        # Do don't anything.
        pass

    def recalculateVerticalLineSegment(self):
        """Recalculates the lineSegment.
        """

        self.prepareGeometryChange()
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartVerticalLineSegmentArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartVerticalLineSegmentArtifact object 
                   with information about this QGraphicsItem.
        """
        
        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartVerticalLineSegmentArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartVerticalLineSegmentArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.lineSegmentPen.setColor(self.artifact.getColor())
        
        #############

        self.recalculateVerticalLineSegment()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartVerticalLineSegmentArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartVerticalLineSegmentArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)

        self.artifact.setColor(self.lineSegmentPen.color())
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the startPointF.
        # If the user created the widget with the startPointF to the
        # right of the endPointF, then the startPointF will have a
        # higher X value than endPointF.

        # The QRectF returned is relative to this (0, 0) point.

        rv = self.shape().boundingRect()

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Calculate the points that would be the selection box area
        # around the line.

        # Start and end points in local coordinates.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)

        # Utilize scaling from the scene if it is available.
        scaling = PriceBarChartScaling()
        if self.scene() != None:
            scaling = self.scene().getScaling()
            
        viewScaledStartPoint = \
            QPointF(self.startPointF.x() * scaling.getViewScalingX(),
                    self.startPointF.y() * scaling.getViewScalingY())
        viewScaledEndPoint = \
            QPointF(self.endPointF.x() * scaling.getViewScalingX(),
                    self.endPointF.y() * scaling.getViewScalingY())

        # Here we are calculating the angle of the text and the line
        # as the user would see it.  Actual angle is different if we
        # are calculating it from a scene perspective.
        angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
        angleRad = math.radians(angleDeg)
        
        shiftX = math.sin(angleRad) * \
                     (0.5 * self.lineSegmentGraphicsItemBarWidth) / \
                     scaling.getViewScalingX()
        
        shiftY = math.cos(angleRad) * \
                     (0.5 * self.lineSegmentGraphicsItemBarWidth) / \
                     scaling.getViewScalingY()

        # Create new points.
        p1 = \
            QPointF(localStartPointF.x() - shiftX,
                    localStartPointF.y() - shiftY)
        p2 = \
            QPointF(localStartPointF.x() + shiftX,
                    localStartPointF.y() + shiftY)
        p3 = \
            QPointF(localEndPointF.x() - shiftX,
                    localEndPointF.y() - shiftY)
        p4 = \
            QPointF(localEndPointF.x() + shiftX,
                    localEndPointF.y() + shiftY)

        points = [p2, p1, p3, p4, p2]
        polygon = QPolygonF(points)

        painterPath = QPainterPath()
        painterPath.addPolygon(polygon)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.lineSegmentPen is set
        to what we want for the drawing style.
        """

        self.log.debug("VerticalLineSegmentGraphicsItem.paint()")
        
        if painter.pen() != self.lineSegmentPen:
            painter.setPen(self.lineSegmentPen)
        
        # Draw the line.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)
        painter.drawLine(QLineF(localStartPointF, localEndPointF))
        
        # Draw the shape if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.lineSegmentPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this VerticalLineSegmentGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        VerticalLineSegmentGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        extendEndPointAction = \
            QAction("E&xtend end point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenEndPointAction = \
            QAction("Shor&ten end point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        extendStartPointAction = \
            QAction("Exte&nd start point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenStartPointAction = \
            QAction("S&horten start point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        extendEndPointAction.triggered.\
            connect(self._handleExtendEndPointAction)
        shortenEndPointAction.triggered.\
            connect(self._handleShortenEndPointAction)
        extendStartPointAction.triggered.\
            connect(self._handleExtendStartPointAction)
        shortenStartPointAction.triggered.\
            connect(self._handleShortenStartPointAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        extendEndPointAction.setEnabled(not readOnlyMode)
        shortenEndPointAction.setEnabled(not readOnlyMode)
        extendStartPointAction.setEnabled(not readOnlyMode)
        shortenStartPointAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(extendEndPointAction)
        menu.addAction(shortenEndPointAction)
        menu.addAction(extendStartPointAction)
        menu.addAction(shortenStartPointAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartVerticalLineSegmentArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartVerticalLineSegmentArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleExtendEndPointAction(self):
        """Updates the QGraphicsItem so that the end point is
        (self.extendMultiple) fold of the current distance away from start
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.startPointF.x() + offsetX
        newEndPointY = self.startPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setEndPointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setEndPointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenEndPointAction(self):
        """Updates the QGraphicsItem so that the end point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        start point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.startPointF.x() + offsetX
        newEndPointY = self.startPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setEndPointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setEndPointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleExtendStartPointAction(self):
        """Updates the QGraphicsItem so that the start point is
        (self.extendMultiple) fold of the current distance away from
        end point.  The artifact is edited too to correspond with this
        change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new start point X and Y values.
        newStartPointX = self.endPointF.x() - offsetX
        newStartPointY = self.endPointF.y() - offsetY

        # Update the QGraphicsItem manually.
        newStartPointF = QPointF(newStartPointX, newStartPointY)
        
        # Call the parent version for setPos(), not the self version
        # because the self version moves both the start and end
        # points.  We want to keep the end point the same.
        super().setPos(newStartPointF)
        self.startPointF = newStartPointF
        
        # Update the artifact.
        self.artifact.setPos(self.startPointF)
        self.artifact.setStartPointF(self.startPointF)

        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenStartPointAction(self):
        """Updates the QGraphicsItem so that the start point is
        (1.0 / self.extendMultiple) fold of the current distance away
        from end point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new start point X and Y values.
        newStartPointX = self.endPointF.x() - offsetX
        newStartPointY = self.endPointF.y() - offsetY

        # Update the QGraphicsItem manually.
        newStartPointF = QPointF(newStartPointX, newStartPointY)
        
        # Call the parent version for setPos(), not the self version
        # because the self version moves both the start and end
        # points.  We want to keep the end point the same.
        super().setPos(newStartPointF)
        self.startPointF = newStartPointF
        
        # Update the artifact.
        self.artifact.setPos(self.startPointF)
        self.artifact.setStartPointF(self.startPointF)

        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the VerticalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the VerticalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the VerticalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        VerticalLineSegmentGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        VerticalLineSegmentGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the VerticalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the VerticalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the VerticalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        VerticalLineSegmentGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        VerticalLineSegmentGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        

class HorizontalLineSegmentGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a line segment in the GraphicsView.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger(\
            "pricebarchart.HorizontalLineSegmentGraphicsItem")
        
        self.log.debug("Entered __init__().")

        # Constant value for the multiple amount to extend the start
        # or end points.  This feature shows up as an option in the
        # right-click context menu option.
        self.extendMultiple = 1.6
        
        ############################################################
        # Set default values for preferences/settings.
        
        # Width of the horizontal bar drawn.
        self.lineSegmentGraphicsItemBarWidth = \
            PriceBarChartSettings.\
                defaultHorizontalLineSegmentGraphicsItemBarWidth 
 
        # Color of the item.
        self.lineSegmentGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultHorizontalLineSegmentGraphicsItemColor

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartHorizontalLineSegmentArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.lineSegmentPenWidth = 0.0
        self.lineSegmentPen = QPen()
        self.lineSegmentPen.\
            setColor(self.lineSegmentGraphicsItemColor)
        self.lineSegmentPen.\
            setWidthF(self.lineSegmentPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        
        # Working variables for clicking and draging.
        self.clickScenePointF = None
        self.origStartPointF = None

    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.

        Parameters:
        
        priceBarChartSettings - PriceBarChartSettings object from which
                                to pull settings information from.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # Width of the horizontal bar drawn.
        self.lineSegmentGraphicsItemBarWidth = \
            priceBarChartSettings.\
            horizontalLineSegmentGraphicsItemBarWidth 
     
        # Color of the item.
        self.lineSegmentGraphicsItemColor = \
            priceBarChartSettings.\
            horizontalLineSegmentGraphicsItemColor
    
        ####################################################################

        # Set the new color of the pen for drawing the bar.
        self.lineSegmentPen.\
            setColor(self.lineSegmentGraphicsItemColor)

        # Schedule an update.
        self.prepareGeometryChange()

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculateHorizontalLineSegment()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosY = event.scenePos().y()
            self.log.debug("DEBUG: scenePosY={}".format(scenePosY))
            
            startingPointY = self.startPointF.y()
            self.log.debug("DEBUG: startingPointY={}".format(startingPointY))
            endingPointY = self.endPointF.y()
            self.log.debug("DEBUG: endingPointY={}".format(endingPointY))
            
            diff = endingPointY - startingPointY
            self.log.debug("DEBUG: diff={}".format(diff))

            startThresholdY = startingPointY + (diff * (1.0 / 5))
            endThresholdY = endingPointY - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThresholdY={}".format(startThresholdY))
            self.log.debug("DEBUG: endThresholdY={}".format(endThresholdY))


            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThresholdX = startingPointX + (diff * (1.0 / 5))
            endThresholdX = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThresholdX={}".format(startThresholdX))
            self.log.debug("DEBUG: endThresholdX={}".format(endThresholdX))


            if startingPointY <= scenePosY <= startThresholdY or \
                   startingPointY >= scenePosY >= startThresholdY or \
                   startingPointX <= scenePosX <= startThresholdX or \
                   startingPointX >= scenePosX >= startThresholdX:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointY <= scenePosY <= endThresholdY or \
                     endingPointY >= scenePosY >= endThresholdY or \
                     endingPointX <= scenePosX <= endThresholdX or \
                     endingPointX >= scenePosX >= endThresholdX:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                self.origStartPointF = QPointF(self.startPointF)
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    # Maintain constraint for being horizontal.
                    y = self.startPointF.y()
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                y))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    # Maintain constraint for being horizontal.
                    y = self.endPointF.y()
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              y))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)

                    # For some reason, setPos() is not getting called
                    # until after the user releases the mouse button
                    # after dragging.  So here we will calculate the
                    # change ourselves and call setPos ourselves so
                    # that the item is drawn correctly.
                    delta = event.scenePos() - self.clickScenePointF
                    if delta.x() != 0.0 and delta.y() != 0.0:
                        newPos = self.origStartPointF + delta
                        self.setPos(newPos)
                    
                    # Calculate Update calculation/text for the
                    # retracement.
                    self.recalculateHorizontalLineSegment()

                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.origStartPointF + delta
                    self.setPos(newPos)
            
                    # Update calculation/text.
                    self.recalculateHorizontalLineSegment()
        
            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshItem(self):
        """Refreshes the item by recalculating and updating the text
        position/rotation.
        """

        self.recalculateHorizontalLineSegment()
        
    def setStartPointF(self, pointF):
        """Sets the starting point of the
        HorizontalLineSegmentGraphicsItem.  The value passed in is the
        mouse location in scene coordinates.
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            if self.scene() != None:
                self.recalculateHorizontalLineSegment()
                self.prepareGeometryChange()
                
    def setEndPointF(self, pointF):
        """Sets the ending point of the
        HorizontalLineSegmentGraphicsItem.  The value passed in is the
        mouse location in scene coordinates.
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            if self.scene() != None:
                self.recalculateHorizontalLineSegment()
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Does not do anything since normalization is not applicable
        to this graphics item.
        """

        # Do don't anything.
        pass

    def recalculateHorizontalLineSegment(self):
        """Recalculates the lineSegment.
        """

        self.prepareGeometryChange()
        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartHorizontalLineSegmentArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartHorizontalLineSegmentArtifact object 
                   with information about this QGraphicsItem.
        """
        
        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartHorizontalLineSegmentArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartHorizontalLineSegmentArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.lineSegmentPen.setColor(self.artifact.getColor())
        
        #############

        self.recalculateHorizontalLineSegment()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartHorizontalLineSegmentArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        self.log.debug("Entered getArtifact()")
        
        # Update the internal self.priceBarChartHorizontalLineSegmentArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)

        self.artifact.setColor(self.lineSegmentPen.color())
        
        self.log.debug("Exiting getArtifact()")
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the startPointF.
        # If the user created the widget with the startPointF to the
        # right of the endPointF, then the startPointF will have a
        # higher X value than endPointF.

        # The QRectF returned is relative to this (0, 0) point.

        rv = self.shape().boundingRect()

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Calculate the points that would be the selection box area
        # around the line.

        # Start and end points in local coordinates.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)

        # Utilize scaling from the scene if it is available.
        scaling = PriceBarChartScaling()
        if self.scene() != None:
            scaling = self.scene().getScaling()
            
        viewScaledStartPoint = \
            QPointF(self.startPointF.x() * scaling.getViewScalingX(),
                    self.startPointF.y() * scaling.getViewScalingY())
        viewScaledEndPoint = \
            QPointF(self.endPointF.x() * scaling.getViewScalingX(),
                    self.endPointF.y() * scaling.getViewScalingY())

        # Here we are calculating the angle of the text and the line
        # as the user would see it.  Actual angle is different if we
        # are calculating it from a scene perspective.
        angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
        angleRad = math.radians(angleDeg)
        
        shiftX = math.sin(angleRad) * \
                     (0.5 * self.lineSegmentGraphicsItemBarWidth) / \
                     scaling.getViewScalingX()
        
        shiftY = math.cos(angleRad) * \
                     (0.5 * self.lineSegmentGraphicsItemBarWidth) / \
                     scaling.getViewScalingY()

        # Create new points.
        p1 = \
            QPointF(localStartPointF.x() - shiftX,
                    localStartPointF.y() - shiftY)
        p2 = \
            QPointF(localStartPointF.x() + shiftX,
                    localStartPointF.y() + shiftY)
        p3 = \
            QPointF(localEndPointF.x() - shiftX,
                    localEndPointF.y() - shiftY)
        p4 = \
            QPointF(localEndPointF.x() + shiftX,
                    localEndPointF.y() + shiftY)

        points = [p2, p1, p3, p4, p2]
        polygon = QPolygonF(points)

        painterPath = QPainterPath()
        painterPath.addPolygon(polygon)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.lineSegmentPen is set
        to what we want for the drawing style.
        """

        self.log.debug("HorizontalLineSegmentGraphicsItem.paint()")
        
        if painter.pen() != self.lineSegmentPen:
            painter.setPen(self.lineSegmentPen)
        
        # Draw the line.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)
        painter.drawLine(QLineF(localStartPointF, localEndPointF))
        
        # Draw the shape if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.lineSegmentPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this HorizontalLineSegmentGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        HorizontalLineSegmentGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        extendEndPointAction = \
            QAction("E&xtend end point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenEndPointAction = \
            QAction("Shor&ten end point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        extendStartPointAction = \
            QAction("Exte&nd start point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenStartPointAction = \
            QAction("S&horten start point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        extendEndPointAction.triggered.\
            connect(self._handleExtendEndPointAction)
        shortenEndPointAction.triggered.\
            connect(self._handleShortenEndPointAction)
        extendStartPointAction.triggered.\
            connect(self._handleExtendStartPointAction)
        shortenStartPointAction.triggered.\
            connect(self._handleShortenStartPointAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        extendEndPointAction.setEnabled(not readOnlyMode)
        shortenEndPointAction.setEnabled(not readOnlyMode)
        extendStartPointAction.setEnabled(not readOnlyMode)
        shortenStartPointAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(extendEndPointAction)
        menu.addAction(shortenEndPointAction)
        menu.addAction(extendStartPointAction)
        menu.addAction(shortenStartPointAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartHorizontalLineSegmentArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartHorizontalLineSegmentArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then the underlying artifact
            # object was modified.  Set the artifact to this
            # PriceBarChartArtifactGraphicsItem, which will cause it to be
            # reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleExtendEndPointAction(self):
        """Updates the QGraphicsItem so that the end point is
        (self.extendMultiple) fold of the current distance away from start
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.startPointF.x() + offsetX
        newEndPointY = self.startPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setEndPointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setEndPointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenEndPointAction(self):
        """Updates the QGraphicsItem so that the end point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        start point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.startPointF.x() + offsetX
        newEndPointY = self.startPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setEndPointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setEndPointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleExtendStartPointAction(self):
        """Updates the QGraphicsItem so that the start point is
        (self.extendMultiple) fold of the current distance away from
        end point.  The artifact is edited too to correspond with this
        change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new start point X and Y values.
        newStartPointX = self.endPointF.x() - offsetX
        newStartPointY = self.endPointF.y() - offsetY

        # Update the QGraphicsItem manually.
        newStartPointF = QPointF(newStartPointX, newStartPointY)
        
        # Call the parent version for setPos(), not the self version
        # because the self version moves both the start and end
        # points.  We want to keep the end point the same.
        super().setPos(newStartPointF)
        self.startPointF = newStartPointF
        
        # Update the artifact.
        self.artifact.setPos(self.startPointF)
        self.artifact.setStartPointF(self.startPointF)

        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenStartPointAction(self):
        """Updates the QGraphicsItem so that the start point is
        (1.0 / self.extendMultiple) fold of the current distance away
        from end point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.endPointF.x() - self.startPointF.x()
        deltaY = self.endPointF.y() - self.startPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new start point X and Y values.
        newStartPointX = self.endPointF.x() - offsetX
        newStartPointY = self.endPointF.y() - offsetY

        # Update the QGraphicsItem manually.
        newStartPointF = QPointF(newStartPointX, newStartPointY)
        
        # Call the parent version for setPos(), not the self version
        # because the self version moves both the start and end
        # points.  We want to keep the end point the same.
        super().setPos(newStartPointF)
        self.startPointF = newStartPointF
        
        # Update the artifact.
        self.artifact.setPos(self.startPointF)
        self.artifact.setStartPointF(self.startPointF)

        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the HorizontalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the HorizontalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the HorizontalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        HorizontalLineSegmentGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        HorizontalLineSegmentGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the HorizontalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the HorizontalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the HorizontalLineSegmentGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        HorizontalLineSegmentGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        HorizontalLineSegmentGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        

class OctaveFanGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    origin point.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.OctaveFanGraphicsItem")
        
        self.log.debug("Entered __init__().")

        # Constant value for the multiple amount to extend the
        # leg1PointF or leg2PointF points.  This feature shows up as
        # an option in the right-click context menu option.
        self.extendMultiple = 1.6
        
        ############################################################
        # Set default values for preferences/settings.

        # Bar height.
        self.octaveFanBarHeight = \
            PriceBarChartSettings.\
                defaultOctaveFanGraphicsItemBarHeight
                                
        # Color of the graphicsitem bar.
        self.octaveFanGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultOctaveFanGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.octaveFanGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultOctaveFanGraphicsItemTextColor

        # X scaling of the text.
        self.octaveFanTextXScaling = \
            PriceBarChartSettings.\
                defaultOctaveFanGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.octaveFanTextYScaling = \
            PriceBarChartSettings.\
                defaultOctaveFanGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartOctaveFanArtifact()

        # Convert object.
        self.convertObj = None
        
        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.octaveFanPenWidth = 0.0
        self.octaveFanPen = QPen()
        self.octaveFanPen.setColor(self.octaveFanGraphicsItemColor)
        self.octaveFanPen.setWidthF(self.octaveFanPenWidth)
        
        # Origin point, in scene coordinates.
        self.originPointF = QPointF(0, 0)

        # Leg1 point, in scene coordinates.
        self.leg1PointF = QPointF(0, 0)

        # Leg2 point, in scene coordinates.
        self.leg2PointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.octaveFanTextFont = QFont("Sans Serif")
        self.octaveFanTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.octaveFanTextPen = self.dummyItem.pen()
        self.octaveFanTextPen.\
            setColor(self.octaveFanGraphicsItemTextColor)

        # Set the brush color of the text.
        self.octaveFanTextBrush = self.dummyItem.brush()
        self.octaveFanTextBrush.\
            setColor(self.octaveFanGraphicsItemTextColor)

        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.octaveFanTextXScaling, \
                            self.octaveFanTextYScaling)
        textTransform.rotate(0.0)
        
        # Below is a list of QGraphicsSimpleTextItems, for each of the
        # MusicalRatios in the PriceBarChartOctaveFanArtifact.  The
        # text contains the musical interval fraction, and the angle
        # of the line.
        #
        self.musicalRatioTextItems = []

        # Initialize to blank and set at the leg1 point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            
            fractionTextItem = QGraphicsSimpleTextItem("", self)
            fractionTextItem.setPos(self.leg1PointF)
            fractionTextItem.setFont(self.octaveFanTextFont)
            fractionTextItem.setPen(self.octaveFanTextPen)
            fractionTextItem.setBrush(self.octaveFanTextBrush)
            fractionTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append(fractionTextItem)

        # Flags that indicate that the user is dragging either the
        # origin, leg1 or leg2 points of the QGraphicsItem.
        self.draggingOriginPointFlag = False
        self.draggingLeg1PointFlag = False
        self.draggingLeg2PointFlag = False
        self.clickScenePointF = None

    def setConvertObj(self, convertObj):
        """Object for doing conversions from x and datetime and y to
        price.  This should be the graphics scene.  This is used for
        doing conversions from a scene point to price or datetime.  It
        is also used so we can convert price or datetime to a scaled
        value.
        """

        self.log.debug("Entered setConvertObj()")
        
        self.convertObj = convertObj
        
        self.log.debug("Exiting setConvertObj()")
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          octaveFanGraphicsItemMusicalRatios)
        
        # Bar height.
        self.octaveFanBarHeight = \
            priceBarChartSettings.\
            defaultOctaveFanGraphicsItemBarHeight
        
        # OctaveFanGraphicsItem bar color (QColor).
        self.octaveFanGraphicsItemColor = \
            priceBarChartSettings.octaveFanGraphicsItemBarColor

        # OctaveFanGraphicsItem text color (QColor).
        self.octaveFanGraphicsItemTextColor = \
            priceBarChartSettings.octaveFanGraphicsItemTextColor
        
        # X scaling of the text.
        self.octaveFanTextXScaling = \
            priceBarChartSettings.\
                octaveFanGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.octaveFanTextYScaling = \
            priceBarChartSettings.\
                octaveFanGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            octaveFanGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.octaveFanGraphicsItemColor)
        self.artifact.setTextColor(self.octaveFanGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.originPointF,
        self.leg1PointF, and self.leg2PointF

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.originPointF

        # Update the start, leg1 and leg2 points accordingly. 
        self.originPointF = self.originPointF + posDelta
        self.leg1PointF = self.leg1PointF + posDelta
        self.leg2PointF = self.leg2PointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # origin or leg points, then the user is trying to adjust
            # the origin or leg points.

            # Get the click point in scene coordinates.
            clickScenePos = event.scenePos()
            clickScenePosX = clickScenePos.x()
            clickScenePosY = clickScenePos.y()
            
            self.log.debug("DEBUG: clickScenePosX={}".format(clickScenePosX))
            self.log.debug("DEBUG: clickScenePosY={}".format(clickScenePosY))


            # Get the shape of the line segments of the legs.  The
            # returned QPainterPath is in scene coordinates.
            shapeOfOriginToLeg1Point = \
                self.getShapeOfLineSegment(self.originPointF, self.leg1PointF)
            shapeOfOriginToLeg2Point = \
                self.getShapeOfLineSegment(self.originPointF, self.leg2PointF)

            # Flags that hold whether the click was inside the leg1
            # line segment or leg2 line segment.
            insideLeg1LineSegment = False
            insideLeg2LineSegment = False

            if shapeOfOriginToLeg1Point.contains(clickScenePos) == True:
                self.log.debug("Click point is within the line segment from " +
                               "origin point to leg1 point.")

                insideLeg1LineSegment = True

            elif shapeOfOriginToLeg2Point.contains(clickScenePos) == True:
                self.log.debug("Click point is within the line segment from " +
                               "origin point to leg2 point.")

                insideLeg2LineSegment = True

            
            self.log.debug("insideLeg1LineSegment={}".\
                           format(insideLeg1LineSegment))
            
            self.log.debug("insideLeg2LineSegment={}".\
                           format(insideLeg2LineSegment))

                
            # Handle the case that the click was inside a line segment
            # that makes up the outter edge of this fan.
            if insideLeg1LineSegment == True:
                
                startingPointX = self.originPointF.x()
                startingPointY = self.originPointF.y()

                endingPointX = self.leg1PointF.x()
                endingPointY = self.leg1PointF.y()
                
                self.log.debug("DEBUG: startingPointX={}, startingPointY={}".\
                               format(startingPointX, startingPointY))
                self.log.debug("DEBUG: endingPointX={}, endingPointY={}".\
                               format(endingPointX, endingPointY))

                startThresholdX = startingPointX + \
                                  ((endingPointX - startingPointX) * (1.0 / 5))
                endThresholdX = endingPointX - \
                                  ((endingPointX - startingPointX) * (1.0 / 5))

                startThresholdY = startingPointY + \
                                  ((endingPointY - startingPointY) * (1.0 / 5))
                endThresholdY = endingPointY - \
                                  ((endingPointY - startingPointY) * (1.0 / 5))

                self.log.debug("DEBUG: startThresholdX={}".\
                               format(startThresholdX))
                self.log.debug("DEBUG: endThresholdX={}".\
                               format(endThresholdX))

                self.log.debug("DEBUG: startThresholdY={}".\
                               format(startThresholdY))
                self.log.debug("DEBUG: endThresholdY={}".\
                               format(endThresholdY))

                startingPointRect = \
                    QRectF(QPointF(startingPointX, startingPointY),
                           QPointF(startThresholdX, startThresholdY))

                endingPointRect = \
                    QRectF(QPointF(endThresholdX, endThresholdY),
                           QPointF(endingPointX, endingPointY))

                if startingPointRect.contains(clickScenePos):

                    self.draggingOriginPointFlag = True
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))

                elif endingPointRect.contains(clickScenePos):

                    self.draggingLeg1PointFlag = True
                    self.log.debug("DEBUG: self.draggingLeg1PointFlag={}".
                                   format(self.draggingLeg1PointFlag))

                else:
                    self.log.debug("Not-endpoints part of the " +
                                   "line segment clicked.")
            
            elif insideLeg2LineSegment == True:
                
                startingPointX = self.originPointF.x()
                startingPointY = self.originPointF.y()

                endingPointX = self.leg2PointF.x()
                endingPointY = self.leg2PointF.y()
                
                self.log.debug("DEBUG: startingPointX={}, startingPointY={}".\
                               format(startingPointX, startingPointY))
                self.log.debug("DEBUG: endingPointX={}, endingPointY={}".\
                               format(endingPointX, endingPointY))

                startThresholdX = startingPointX + \
                                  ((endingPointX - startingPointX) * (1.0 / 5))
                endThresholdX = endingPointX - \
                                  ((endingPointX - startingPointX) * (1.0 / 5))

                startThresholdY = startingPointY + \
                                  ((endingPointY - startingPointY) * (1.0 / 5))
                endThresholdY = endingPointY - \
                                  ((endingPointY - startingPointY) * (1.0 / 5))

                self.log.debug("DEBUG: startThresholdX={}".\
                               format(startThresholdX))
                self.log.debug("DEBUG: endThresholdX={}".\
                               format(endThresholdX))

                self.log.debug("DEBUG: startThresholdY={}".\
                               format(startThresholdY))
                self.log.debug("DEBUG: endThresholdY={}".\
                               format(endThresholdY))

                startingPointRect = \
                    QRectF(QPointF(startingPointX, startingPointY),
                           QPointF(startThresholdX, startThresholdY))

                endingPointRect = \
                    QRectF(QPointF(endThresholdX, endThresholdY),
                           QPointF(endingPointX, endingPointY))

                if startingPointRect.contains(clickScenePos):

                    self.draggingOriginPointFlag = True
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))

                elif endingPointRect.contains(clickScenePos):

                    self.draggingLeg2PointFlag = True
                    self.log.debug("DEBUG: self.draggingLeg2PointFlag={}".
                                   format(self.draggingLeg2PointFlag))
            
                else:
                    self.log.debug("Not-endpoints part of the " +
                                   "line segment clicked.")
                    
            else:
                self.log.debug("Middle area of the line segment clicked.")


            # If none of the drag point flags are set, then the user
            # has clicked somewhere in teh middle part of the
            # QGraphicsItem (somewhere not close to an endpoint).
            if self.draggingOriginPointFlag == False and \
                self.draggingLeg1PointFlag == False and \
                self.draggingLeg2PointFlag == False:

                # Pass the event to the parent, because the user wants
                # to either select or drag-move the position of the
                # QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()

                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                
                if self.draggingOriginPointFlag == True:
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))
                    self.setOriginPointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()
                    
                elif self.draggingLeg1PointFlag == True:
                    self.log.debug("DEBUG: self.draggingLeg1PointFlag={}".
                                   format(self.draggingLeg1PointFlag))
                    self.setLeg1PointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()

                elif self.draggingLeg2PointFlag == True:
                    self.log.debug("DEBUG: self.draggingLeg2PointFlag={}".
                                   format(self.draggingLeg2PointFlag))
                    self.setLeg2PointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()
                    
                else:
                    # This means that the user is dragging the whole
                    # item.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingOriginPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "originPoint.")
            
            self.draggingOriginPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingLeg1PointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "leg1Point.")
            
            self.draggingLeg1PointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingLeg2PointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "leg2Point.")
            
            self.draggingLeg2PointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.originPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingOriginPointFlag = False
            self.draggingLeg1PointFlag = False
            self.draggingLeg2PointFlag = False

    def refreshItem(self):
        """Refreshes the item by recalculating and updating the text
        position/rotation.
        """

        self.recalculateOctaveFan()
        
        self.refreshTextItems()
        
    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        # Update the octaveFan label text item texts.
        if self.scene() != None and self.convertObj != None:
            self.recalculateOctaveFan()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateOctaveFan() call above.

                # Get the unscaled originPointF, leg1PointF, and leg2PointF.
                unscaledOriginPointF = artifact.getOriginPointF()
                unscaledLeg1PointF = artifact.getLeg1PointF()
                unscaledLeg2PointF = artifact.getLeg2PointF()

                #self.log.debug("unscaledOriginPointF is: ({}, {})".
                #               format(unscaledOriginPointF.x(),
                #                      unscaledOriginPointF.y()))
                #self.log.debug("unscaledLeg1PointF is: ({}, {})".
                #               format(unscaledLeg1PointF.x(),
                #                      unscaledLeg1PointF.y()))
                #self.log.debug("unscaledLeg2PointF is: ({}, {})".
                #               format(unscaledLeg2PointF.x(),
                #                      unscaledLeg2PointF.y()))

                # Calculate scaled originPointF, leg1PointF and
                # leg2PointF points.
                scaledOriginPointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getOriginPointF())
                scaledLeg1PointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getLeg1PointF())
                scaledLeg2PointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getLeg2PointF())
        
                #self.log.debug("scaledOriginPointF is: ({}, {})".
                #               format(scaledOriginPointF.x(),
                #                      scaledOriginPointF.y()))
                #self.log.debug("scaledLeg1PointF is: ({}, {})".
                #               format(scaledLeg1PointF.x(),
                #              scaledLeg1PointF.y()))
                #self.log.debug("scaledLeg2PointF is: ({}, {})".
                #               format(scaledLeg2PointF.x(),
                #                      scaledLeg2PointF.y()))

                # Get the x and y position that will be the new
                # position of the text item.  This function returns
                # the x and y in scaled coordinates so we must
                # remember to convert those values afterwards.
                (x, y) = \
                    artifact.getXYForMusicalRatio(i,
                                                  scaledOriginPointF,
                                                  scaledLeg1PointF,
                                                  scaledLeg2PointF)
                
                # Map those x and y to local coordinates.
                scenePointF = \
                    self.convertObj.convertScaledPointToScenePoint(\
                    QPointF(x, y))
                localPointF = self.mapFromScene(scenePointF)
                
                # Get the number of degrees to rotate the text by,
                # utilizing scaling.
                rotationDegrees = \
                    self.calculateTextRotationDegrees(self.originPointF,
                                                      scenePointF)
                
                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.octaveFanTextXScaling, \
                                    self.octaveFanTextYScaling)
                textTransform.rotate(rotationDegrees)

                # Get the text item for this point on the scale.
                textItem = self.musicalRatioTextItems[i]

                # Set the position and other attributes.
                textItem.setPos(localPointF)
                textItem.setFont(self.octaveFanTextFont)
                textItem.setPen(self.octaveFanTextPen)
                textItem.setBrush(self.octaveFanTextBrush)
                textItem.setTransform(textTransform)


            
    def setOriginPointF(self, pointF):
        """Sets the origin point of the octaveFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.originPointF != pointF: 
            self.originPointF = pointF

            self.setPos(self.originPointF)
            
            # Update the octaveFan label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setLeg1PointF(self, pointF):
        """Sets the leg1ing point of the octaveFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.leg1PointF != pointF:
            self.leg1PointF = pointF

            self.log.debug("OctaveFanGraphicsItem." +
                           "setLeg1PointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the octaveFan label text item positions.
            self.refreshTextItems()
            
            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setLeg2PointF(self, pointF):
        """Sets the leg2ing point of the octaveFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.leg2PointF != pointF:
            self.leg2PointF = pointF

            self.log.debug("OctaveFanGraphicsItem." +
                           "setLeg2PointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the octaveFan label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Does nothing since we do not normalize points for this class."""

        pass

    def recalculateOctaveFan(self):
        """Updates the text items that tell about the fann lines on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of angle.
        """

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        # Now recalculate if we have a convertObj to use for scaling
        # conversion calculation.
        if self.convertObj != None:
        
            # Get the origin point in scene, scaled, and local coordinates.
            sceneOriginPointF = self.originPointF
            scaledOriginPointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.originPointF)
            localOriginPointF = QPointF(0.0, 0.0)
    
            # Get the leg1 point in scene, scaled, and local coordinates.
            sceneLeg1PointF = self.leg1PointF
            scaledLeg1PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg1PointF)
            localLeg1PointF = QPointF(0.0, 0.0) + \
                              (self.leg1PointF - self.originPointF)
            
            # Get the leg2 point in scene, scaled, and local coordinates.
            sceneLeg2PointF = self.leg2PointF
            scaledLeg2PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg2PointF)
            localLeg2PointF = QPointF(0.0, 0.0) + \
                              (self.leg2PointF - self.originPointF)


            # Go through each musical ratio.
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Get the x and y position that will be the end point.
                    # This function returns the x and y in scaled
                    # coordinates so we must remember to convert those
                    # values afterwards.
                    (x, y) = \
                        artifact.getXYForMusicalRatio(i,
                                                      scaledOriginPointF,
                                                      scaledLeg1PointF,
                                                      scaledLeg2PointF)
            
                    # Map those x and y to local coordinates.
                    sceneEndPointF = \
                        self.convertObj.convertScaledPointToScenePoint(\
                        QPointF(x, y))
                    
                    # Do conversion to local coordinates.
                    localEndPointF = sceneEndPointF - sceneOriginPointF

                    # Enable and make visible.

                    # Get the text item for this point on the scale.
                    textItem = self.musicalRatioTextItems[i]
                    
                    # Make the text visible if it is enabled.
                    textEnabled = artifact.isTextEnabled()
                    textItem.setEnabled(textEnabled)
                    textItem.setVisible(textEnabled)

                    # If text isn't enabled, there's no need to
                    # set the text for it.  Go to the next text item.
                    if textEnabled == False:
                        continue

                    # Text to set in the text item.
                    text = ""

                    # Append the text for the fraction of the musical note.
                    numerator = musicalRatio.getNumerator()
                    denominator = musicalRatio.getDenominator()

                    if numerator != None and denominator != None:
                        text += \
                            "{}/{}".format(numerator, denominator) + os.linesep

                    # Append the text for the angle of the line.
                    # Uncomment below to re-add the scaled angle to the text.
                    #scaledAngleDegrees = \
                    #    self.calculateScaledAngleDegrees(self.originPointF,
                    #                                     sceneEndPointF)
                    #text += "{:.4f} deg".format(scaledAngleDegrees) + \
                    #        os.linesep


                    # Set the text to the text item.
                    text = text.rstrip()
                    textItem.setText(text)
                    
                else:
                    # Disable and make not visable.
                    
                    # Get the text item for this point on the scale.
                    textItem = self.musicalRatioTextItems[i]
                    
                    textItem.setVisible(False)
                    textItem.setEnabled(False)
                
                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartOctaveFanArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartOctaveFanArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartOctaveFanArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartOctaveFanArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        originPointF = self.artifact.getOriginPointF()
        leg1PointF = self.artifact.getLeg1PointF()
        leg2PointF = self.artifact.getLeg2PointF()
        self.setOriginPointF(originPointF)
        self.setLeg1PointF(leg1PointF)
        self.setLeg2PointF(leg2PointF)

        self.octaveFanTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.octaveFanPen.\
            setColor(self.artifact.getColor())
        self.octaveFanTextPen.\
            setColor(self.artifact.getTextColor())
        self.octaveFanTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the angles, since the origin, leg1 and leg2
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements may not be valid.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartOctaveFanArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartOctaveFanArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setOriginPointF(self.originPointF)
        self.artifact.setLeg1PointF(self.leg1PointF)
        self.artifact.setLeg2PointF(self.leg2PointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def getShapeOfLineSegment(self, startPointF, endPointF):
        """Returns the shape as a QPainterPath of the line segment
        constructed via the two input QPointFs.  The shape is
        constructed by a rectangle around the start and end points.
        The rectangle is tilted based on the angle of the start and
        end points in view-scaled coordinates.  The bar height used is
        whatever is returned by self.octaveFanBarHeight.

        Arguments:
        
        startPointF - QPointF representing the start point of the line
                      segment in either scene or local coordinates.
        endPointF   - QPointF representing the end point of the line segment
                      in either scene or local scene coordinates.

        Returns:
        QPainterPath object holding the shape of the rectangle around
        the line segment.  If the start and end points are given in
        local coordinates, then the QPainterPath returned will also be
        in local coordinates, otherwise the QPainterPath returned will
        be in scene coordinates.
        """

        self.log.debug("Entered getShapeOfLineSegment()")
        
        #self.log.debug("startPointF is: ({}, {})".\
        #               format(startPointF.x(),
        #                      startPointF.y()))
        #self.log.debug("endPointF is: ({}, {})".\
        #               format(endPointF.x(),
        #                      endPointF.y()))

        #tempRect = QRectF(startPointF, endPointF)
        #self.log.debug("Bounding rect of the two points beforehand is: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(tempRect.x(),
        #                      tempRect.y(),
        #                      tempRect.width(),
        #                      tempRect.height()))
        
        # Utilize scaling from the scene if it is available.
        scaling = PriceBarChartScaling()
        if self.scene() != None:
            scaling = self.scene().getScaling()
            
        viewScaledStartPoint = \
            QPointF(startPointF.x() * scaling.getViewScalingX(),
                    startPointF.y() * scaling.getViewScalingY())
        viewScaledEndPoint = \
            QPointF(endPointF.x() * scaling.getViewScalingX(),
                    endPointF.y() * scaling.getViewScalingY())

        angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
        angleRad = math.radians(angleDeg)

        #self.log.debug("angleDeg is: {}".format(angleDeg))
        #self.log.debug("angleRad is: {}".format(angleRad))

        
        shiftX = math.sin(angleRad) * \
                     (0.5 * self.octaveFanBarHeight) / \
                     scaling.getViewScalingX()
                     
        shiftY = math.cos(angleRad) * \
                     (0.5 * self.octaveFanBarHeight) / \
                     scaling.getViewScalingY()
        
        #self.log.debug("shiftX is: {}".format(shiftX))
        #self.log.debug("shiftY is: {}".format(shiftY))

        
        # Create new points.
        p1 = \
            QPointF(startPointF.x() - shiftX,
                    startPointF.y() - shiftY)
        p2 = \
            QPointF(startPointF.x() + shiftX,
                    startPointF.y() + shiftY)
        p3 = \
            QPointF(endPointF.x() - shiftX,
                    endPointF.y() - shiftY)
        p4 = \
            QPointF(endPointF.x() + shiftX,
                    endPointF.y() + shiftY)

        #self.log.debug("p1 is: ({}, {})".format(p1.x(), p1.y()))
        #self.log.debug("p2 is: ({}, {})".format(p2.x(), p2.y()))
        #self.log.debug("p3 is: ({}, {})".format(p3.x(), p3.y()))
        #self.log.debug("p4 is: ({}, {})".format(p4.x(), p4.y()))

        points = [p2, p1, p3, p4, p2]
        polygon = QPolygonF(points)

        painterPath = QPainterPath()
        painterPath.addPolygon(polygon)


        #tempRect = painterPath.boundingRect()
        #self.log.debug("Bounding rect of polygon afterwards is: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(tempRect.x(),
        #                      tempRect.y(),
        #                      tempRect.width(),
        #                      tempRect.height()))
        
        return painterPath

    def calculateTextRotationDegrees(self, startPointF, endPointF):
        """Calculates the number of degrees that a
        QGraphicsSimpleTextItem should be rotated so that it is
        parallel to the line constructed by the 'startPointF' and
        'endPointF' parameters.  ViewScaling is utilized to determine the angle.

        Arguments:
        startPointF - start point of the line segment to align the
                      text's angle with.
        endPointF   - start point of the line segment to align the
                      text's angle with.

        Returns:
        float value holding angle that the text needs to be rotated, in degrees.
        """

        # Return value.
        angleDeg = 0.0
        
        # Determine the number of degrees to rotate the text by,
        # utilizing scaling.
        if self.scene() != None:
            scaling = self.scene().getScaling()

            viewScaledStartPoint = \
                QPointF(startPointF.x() * scaling.getViewScalingX(),
                        startPointF.y() * scaling.getViewScalingY())
            viewScaledEndPoint = \
                QPointF(endPointF.x() * scaling.getViewScalingX(),
                        endPointF.y() * scaling.getViewScalingY())
            
            angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
            self.log.debug("Scaled angleDeg before normalizing and fudge, " +
                           "angleDeg={}".format(angleDeg))
        else:
            # No scaling is available, so just do the unscaled angle.
            angleDeg = QLineF(startPointF, endPointF).angle()
            self.log.debug("Unscaled angleDeg before normalizing and fudge, " +
                           "angleDeg={}".format(angleDeg))
            
        # Normalize the angle so that the text is always upright.
        if 90 <= angleDeg <= 270:
            angleDeg += 180
        angleDeg = Util.toNormalizedAngle(angleDeg)

        self.log.debug("Before fudge, angleDeg={}".format(angleDeg))
        
        # Fudge factor since for some reason the text item doesn't
        # exactly line up with the line.
        fudge = 0.0
        if 0 < angleDeg <= 90:
            self.log.debug("0 to 90")
            removed = 45 - abs(45 - angleDeg)
            fudge = removed * 0.19
            angleDeg -= fudge
        elif 90 < angleDeg <= 180:
            self.log.debug("90 to 180")
            removed = 45 - abs(135 - angleDeg)
            fudge = removed * 0.12
            angleDeg += fudge
        elif 180 < angleDeg <= 270:
            self.log.debug("180 to 270")
            removed = 45 - abs(225 - angleDeg)
            fudge = removed * 0.19
            angleDeg -= fudge
        elif 270 < angleDeg <= 360:
            self.log.debug("270 to 360")
            removed = 45 - abs(315 - angleDeg)
            fudge = removed * 0.12
            angleDeg += fudge
            
        angleDeg = -1.0 * angleDeg
        self.log.debug("angleDeg={}".format(angleDeg))

        return angleDeg
    
    def calculateScaledAngleDegrees(self, startPointF, endPointF):
        """Calculates the number of degrees of angle between
        'startPointF' and 'endPointF'.  This angle is calculated
        utilizing scaling conversion from self.convertObj.

        Arguments:
        startPointF - start point of the line segment, in scene coordinates.
        endPointF   - start point of the line segment, in scene coordinates.

        Returns:
        float value holding the scaled angle, in degrees.
        """

        angleDeg = 0.0

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        if self.convertObj != None:
            startScaledPoint = \
                self.convertObj.convertScenePointToScaledPoint(startPointF)
            endScaledPoint = \
                self.convertObj.convertScenePointToScaledPoint(endPointF)
        
            angleDeg = QLineF(startScaledPoint, endScaledPoint).angle()
        else:
            # Convert object is not set, so don't apply scaling, and
            # just return the angle with unscaled points.
            angleDeg = QLineF(startPointF, endPointF).angle()
            
        return angleDeg
        
    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is origin point.
        
        rv = self.shape().boundingRect()

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem,
        in local item coordinates.
        """

        #self.log.debug("Entered shape().")

        # Return value.
        # Holds the QPainterPath of the whole item (in local coordinates).
        painterPath = QPainterPath()

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but " +
                               "self.scene() is not None, so we're " +
                               "going to set self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        if scene != None and self.convertObj != None:
            # Scene exists and we can do scaling conversions.
            # Continue to calculate the painterPath.
            
            # Get the origin point in scene, scaled, and local coordinates.
            sceneOriginPointF = self.originPointF
            scaledOriginPointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.originPointF)
            localOriginPointF = QPointF(0.0, 0.0)

            #self.log.debug("sceneOriginPointF is: ({}, {})".\
            #               format(sceneOriginPointF.x(),
            #                      sceneOriginPointF.y()))
            #self.log.debug("scaledOriginPointF is: ({}, {})".\
            #               format(scaledOriginPointF.x(),
            #                      scaledOriginPointF.y()))
            #self.log.debug("localOriginPointF is: ({}, {})".\
            #               format(localOriginPointF.x(),
            #                      localOriginPointF.y()))
                           
            # Get the leg1 point in scene, scaled, and local coordinates.
            sceneLeg1PointF = self.leg1PointF
            scaledLeg1PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg1PointF)
            localLeg1PointF = QPointF(0.0, 0.0) + \
                              (self.leg1PointF - self.originPointF)
            
            #self.log.debug("sceneLeg1PointF is: ({}, {})".\
            #               format(sceneLeg1PointF.x(),
            #                      sceneLeg1PointF.y()))
            #self.log.debug("scaledLeg1PointF is: ({}, {})".\
            #               format(scaledLeg1PointF.x(),
            #                      scaledLeg1PointF.y()))
            #self.log.debug("localLeg1PointF is: ({}, {})".\
            #               format(localLeg1PointF.x(),
            #                      localLeg1PointF.y()))
            
            # Get the leg2 point in scene, scaled, and local coordinates.
            sceneLeg2PointF = self.leg2PointF
            scaledLeg2PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg2PointF)
            localLeg2PointF = QPointF(0.0, 0.0) + \
                              (self.leg2PointF - self.originPointF)
    
            #self.log.debug("sceneLeg2PointF is: ({}, {})".\
            #               format(sceneLeg2PointF.x(),
            #                      sceneLeg2PointF.y()))
            #self.log.debug("scaledLeg2PointF is: ({}, {})".\
            #               format(scaledLeg2PointF.x(),
            #                      scaledLeg2PointF.y()))
            #self.log.debug("localLeg2PointF is: ({}, {})".\
            #               format(localLeg2PointF.x(),
            #                      localLeg2PointF.y()))

            
            #tempRect = painterPath.boundingRect()
            #self.log.debug("Before adding paths, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))
                           
            # Add the path for the shape of the line segment created by
            # points self.originPointF to self.leg1PointF.  
            leg1PainterPath = \
                self.getShapeOfLineSegment(localOriginPointF, localLeg1PointF)
            painterPath.addPath(leg1PainterPath)


            #tempRect = painterPath.boundingRect()
            #self.log.debug("After adding leg1PainterPath, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))
            
            
            # Add the path for the shape of the line segment created by
            # points self.originPointF to self.leg2PointF.
            leg2PainterPath = \
                self.getShapeOfLineSegment(localOriginPointF, localLeg2PointF)
            painterPath.addPath(leg2PainterPath)


            #tempRect = painterPath.boundingRect()
            #self.log.debug("After adding leg2PainterPath, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))

            
            # Go through each line of each enabled musical ratio, getting
            # the shape of the line segment and add that path to
            # 'painterPath'.
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]
    
                # Only add the path if the musical ratio is enabled.
                if musicalRatio.isEnabled():
                    # Get the x and y position that will be the end point.
                    # This function returns the x and y in scaled
                    # coordinates so we must remember to convert those
                    # values afterwards.
                    (x, y) = \
                        artifact.getXYForMusicalRatio(i,
                                                      scaledOriginPointF,
                                                      scaledLeg1PointF,
                                                      scaledLeg2PointF)

                    #self.log.debug("Musical ratio point X and Y for index " +
                    #               "{} in scaled coordinates is: ".format(i) +
                    #               "({}, {})".format(x, y))
                    
                    # Map those x and y to local coordinates.
                    sceneEndPointF = \
                        self.convertObj.convertScaledPointToScenePoint(\
                        QPointF(x, y))

                    #self.log.debug("Mapping that point to scene coords is " + 
                    #               "({}, {})".format(sceneEndPointF.x(),
                    #                                 sceneEndPointF.y()))
                
                    # Do conversion to local coordinates.
                    localEndPointF = sceneEndPointF - sceneOriginPointF
    
                    #self.log.debug("Mapping that point to local coords is " + 
                    #               "({}, {})".format(localEndPointF.x(),
                    #                                 localEndPointF.y()))
                
                    # Get the painter path.
                    endPointPainterPath = \
                        self.getShapeOfLineSegment(localOriginPointF,
                                                   localEndPointF)

                    #tempRect = painterPath.boundingRect()
                    #self.log.debug("Path for " +
                    #               "index {} ".format(i) +
                    #               "has bounding rect: " +
                    #               "x={}, y={}, w={}, h={}".\
                    #               format(tempRect.x(),
                    #                      tempRect.y(),
                    #                      tempRect.width(),
                    #                      tempRect.height()))
    
                    # Add the path to 'painterPath'.
                    painterPath.addPath(endPointPainterPath)


                    #tempRect = painterPath.boundingRect()
                    #self.log.debug("After adding path for " +
                    #               "index {}, ".format(i) +
                    #               "bounding rect of " +
                    #               "PainterPath is: " +
                    #               "x={}, y={}, w={}, h={}".\
                    #               format(tempRect.x(),
                    #                      tempRect.y(),
                    #                      tempRect.width(),
                    #                      tempRect.height()))
    
        else:
            # Scene doesn't exist or we can't scaling conversions.
            # No calculations to do since it won't get plotted anyways.
            self.log.debug("Tried to get shape scene isn't set.")
            pass
            

        rect = painterPath.boundingRect()
        
        #self.log.debug("Exiting shape(). " +
        #               "PainterPath being returned has a bounding rect of: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(rect.x(), rect.y(), rect.width(), rect.height()))

        # The 'painterPath' should now have all the paths for the tilted
        # rectangles that make up the whole item.
        return painterPath

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.octaveFanPen is set
        to what we want for the drawing style.
        """

        #self.log.debug("Entered OctaveFanGraphicsItem.paint().  " +
        #               "pos is: ({}, {})".\
        #               format(self.pos().x(), self.pos().y()) +
        #               os.linesep +
        #               "self.originPointF == ({}, {})".\
        #               format(self.originPointF.x(), self.originPointF.y()) +
        #               os.linesep +
        #               "self.leg1PointF == ({}, {})".\
        #               format(self.leg1PointF.x(), self.leg1PointF.y()) +
        #               os.linesep +
        #               "self.leg2PointF == ({}, {})".\
        #               format(self.leg2PointF.x(), self.leg2PointF.y()))
        
        if painter.pen() != self.octaveFanPen:
            painter.setPen(self.octaveFanPen)

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")
                # No scene, so don't paint anything.
                self.log.debug("There's no scene so we won't paint anything.")
                return

        # Get the origin point in scene, scaled, and local coordinates.
        sceneOriginPointF = self.originPointF
        scaledOriginPointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.originPointF)
        localOriginPointF = QPointF(0.0, 0.0)

        # Get the leg1 point in scene, scaled, and local coordinates.
        sceneLeg1PointF = self.leg1PointF
        scaledLeg1PointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.leg1PointF)
        localLeg1PointF = self.leg1PointF - self.originPointF
        
        # Get the leg2 point in scene, scaled, and local coordinates.
        sceneLeg2PointF = self.leg2PointF
        scaledLeg2PointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.leg2PointF)
        localLeg2PointF = self.leg2PointF - self.originPointF

        
        # Always draw the line from origin point to leg1 point.
        painter.drawLine(localOriginPointF, localLeg1PointF)
        
        # Always draw the line from origin point to leg2 point.
        painter.drawLine(localOriginPointF, localLeg2PointF)

        # For each musical ratio that is enabled, draw it as a line
        # segment from the origin point to the end point of that
        # musical ratio.
        artifact = self.getArtifact()
        musicalRatios = artifact.getMusicalRatios()
        for i in range(len(musicalRatios)):
            musicalRatio = musicalRatios[i]

            # Only add the path if the musical ratio is enabled.
            if musicalRatio.isEnabled():
                # Get the x and y position that will be the end point.
                # This function returns the x and y in scaled
                # coordinates so we must remember to convert those
                # values afterwards.
                (x, y) = \
                    artifact.getXYForMusicalRatio(i,
                                                  scaledOriginPointF,
                                                  scaledLeg1PointF,
                                                  scaledLeg2PointF)
        
                # Map those x and y to local coordinates.
                sceneEndPointF = \
                    self.convertObj.convertScaledPointToScenePoint(\
                    QPointF(x, y))
            
                # Do conversion to local coordinates.
                localEndPointF = sceneEndPointF - sceneOriginPointF

                # Draw the line segment for this musical ratio.
                painter.drawLine(localOriginPointF, localEndPointF)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.octaveFanPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
        self.log.debug("Exiting OctaveFanGraphicsItem.paint().")

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this OctaveFanGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        OctaveFanGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        extendLeg1PointAction = \
            QAction("E&xtend leg1 point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenLeg1PointAction = \
            QAction("Shor&ten leg1 point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        extendLeg2PointAction = \
            QAction("Exte&nd leg2 point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenLeg2PointAction = \
            QAction("S&horten leg2 point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        
        setOriginOnAstro1Action = \
            QAction("Set origin timestamp on Astro Chart &1", parent)
        setOriginOnAstro2Action = \
            QAction("Set origin timestamp on Astro Chart &2", parent)
        setOriginOnAstro3Action = \
            QAction("Set origin timestamp on Astro Chart &3", parent)
        openOriginInJHoraAction = \
            QAction("Open JHor&a with origin timestamp", parent)
        openOriginInAstrologAction = \
            QAction("Open Astrolog with origin timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        extendLeg1PointAction.triggered.\
            connect(self._handleExtendLeg1PointAction)
        shortenLeg1PointAction.triggered.\
            connect(self._handleShortenLeg1PointAction)
        extendLeg2PointAction.triggered.\
            connect(self._handleExtendLeg2PointAction)
        shortenLeg2PointAction.triggered.\
            connect(self._handleShortenLeg2PointAction)
        setOriginOnAstro1Action.triggered.\
            connect(self._handleSetOriginOnAstro1Action)
        setOriginOnAstro2Action.triggered.\
            connect(self._handleSetOriginOnAstro2Action)
        setOriginOnAstro3Action.triggered.\
            connect(self._handleSetOriginOnAstro3Action)
        openOriginInJHoraAction.triggered.\
            connect(self._handleOpenOriginInJHoraAction)
        openOriginInAstrologAction.triggered.\
            connect(self._handleOpenOriginInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        extendLeg1PointAction.setEnabled(not readOnlyMode)
        shortenLeg1PointAction.setEnabled(not readOnlyMode)
        extendLeg2PointAction.setEnabled(not readOnlyMode)
        shortenLeg2PointAction.setEnabled(not readOnlyMode)
        setOriginOnAstro1Action.setEnabled(True)
        setOriginOnAstro2Action.setEnabled(True)
        setOriginOnAstro3Action.setEnabled(True)
        openOriginInJHoraAction.setEnabled(True)
        openOriginInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(extendLeg1PointAction)
        menu.addAction(shortenLeg1PointAction)
        menu.addAction(extendLeg2PointAction)
        menu.addAction(shortenLeg2PointAction)
        menu.addSeparator()
        menu.addAction(setOriginOnAstro1Action)
        menu.addAction(setOriginOnAstro2Action)
        menu.addAction(setOriginOnAstro3Action)
        menu.addAction(openOriginInJHoraAction)
        menu.addAction(openOriginInAstrologAction)

    def rotateDown(self):
        """Causes the OctaveFanGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the OctaveFanGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the OctaveFanGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartOctaveFanArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartOctaveFanArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the OctaveFanGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
        
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the OctaveFanGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
        
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the OctaveFanGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleExtendLeg1PointAction(self):
        """Updates the QGraphicsItem so that the leg1 point is
        (self.extendMultiple) fold of the current distance away from origin
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg1PointF.x() - self.originPointF.x()
        deltaY = self.leg1PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg1PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg1PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenLeg1PointAction(self):
        """Updates the QGraphicsItem so that the leg1 point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        origin point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg1PointF.x() - self.originPointF.x()
        deltaY = self.leg1PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg1PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg1PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleExtendLeg2PointAction(self):
        """Updates the QGraphicsItem so that the leg2 point is
        (self.extendMultiple) fold of the current distance away from origin
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg2PointF.x() - self.originPointF.x()
        deltaY = self.leg2PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg2PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg2PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenLeg2PointAction(self):
        """Updates the QGraphicsItem so that the leg2 point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        origin point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg2PointF.x() - self.originPointF.x()
        deltaY = self.leg2PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg2PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg2PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetOriginOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the origin the OctaveFanGraphicsItem.
        """

        self.scene().setAstroChart1(self.originPointF.x())
        
    def _handleSetOriginOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the origin the OctaveFanGraphicsItem.
        """

        self.scene().setAstroChart2(self.originPointF.x())
        
    def _handleSetOriginOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the origin the OctaveFanGraphicsItem.
        """

        self.scene().setAstroChart3(self.originPointF.x())
        
    def _handleOpenOriginInJHoraAction(self):
        """Causes the the timestamp of the origin the
        OctaveFanGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.originPointF.x())
        
    def _handleOpenOriginInAstrologAction(self):
        """Causes the the timestamp of the origin the
        OctaveFanGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.originPointF.x())
        
        
class FibFanGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a fibonacci retracement fan in
    the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    origin point.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.FibFanGraphicsItem")
        
        self.log.debug("Entered __init__().")

        # Constant value for the multiple amount to extend the
        # leg1PointF or leg2PointF points.  This feature shows up as
        # an option in the right-click context menu option.
        self.extendMultiple = 1.6
        
        ############################################################
        # Set default values for preferences/settings.

        # Height of the vertical bar drawn.
        self.fibFanBarHeight = \
            PriceBarChartSettings.\
                defaultFibFanGraphicsItemBarHeight 
 
        # Font.
        self.fibFanTextFont = QFont()
        self.fibFanTextFont.fromString(\
            PriceBarChartSettings.\
            defaultFibFanGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.fibFanGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultFibFanGraphicsItemDefaultTextColor

        # Color of the graphicsitem.
        self.fibFanGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultFibFanGraphicsItemDefaultColor

        # X scaling of the text.
        self.fibFanTextXScaling = \
            PriceBarChartSettings.\
                defaultFibFanGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.fibFanTextYScaling = \
            PriceBarChartSettings.\
                defaultFibFanGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        self.textEnabledFlag = \
            PriceBarChartSettings.\
            defaultFibFanGraphicsItemTextEnabledFlag
    
        # Ratios (bool).
        self.ratios = \
            copy.deepcopy(PriceBarChartSettings.\
                          defaultFibFanGraphicsItemRatios)
    
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartFibFanArtifact()

        # Convert object.
        self.convertObj = None
        
        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.fibFanPenWidth = 0.0
        self.fibFanPen = QPen()
        self.fibFanPen.setColor(self.fibFanGraphicsItemColor)
        self.fibFanPen.setWidthF(self.fibFanPenWidth)
        
        # Origin point, in scene coordinates.
        self.originPointF = QPointF(0, 0)

        # Leg1 point, in scene coordinates.
        self.leg1PointF = QPointF(0, 0)

        # Leg2 point, in scene coordinates.
        self.leg2PointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the pen color of the text.
        self.fibFanTextPen = self.dummyItem.pen()
        self.fibFanTextPen.\
            setColor(self.fibFanGraphicsItemTextColor)

        # Set the brush color of the text.
        self.fibFanTextBrush = self.dummyItem.brush()
        self.fibFanTextBrush.\
            setColor(self.fibFanGraphicsItemTextColor)

        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.fibFanTextXScaling, \
                            self.fibFanTextYScaling)
        textTransform.rotate(0.0)
        
        # Below is a list of QGraphicsSimpleTextItems, for each of the
        # Ratios in the PriceBarChartFibFanArtifact.  The
        # text contains the interval fraction, and the angle
        # of the line.
        #
        self.ratioTextItems = []

        # Initialize to blank and set at the leg1 point.
        for ratio in range(len(self.artifact.getRatios())):
            
            fractionTextItem = QGraphicsSimpleTextItem("", self)
            fractionTextItem.setPos(self.leg1PointF)
            fractionTextItem.setFont(self.fibFanTextFont)
            fractionTextItem.setPen(self.fibFanTextPen)
            fractionTextItem.setBrush(self.fibFanTextBrush)
            fractionTextItem.setTransform(textTransform)
            
            self.ratioTextItems.\
                append(fractionTextItem)

        # Flags that indicate that the user is dragging either the
        # origin, leg1 or leg2 points of the QGraphicsItem.
        self.draggingOriginPointFlag = False
        self.draggingLeg1PointFlag = False
        self.draggingLeg2PointFlag = False
        self.clickScenePointF = None

    def setConvertObj(self, convertObj):
        """Object for doing conversions from x and datetime and y to
        price.  This should be the graphics scene.  This is used for
        doing conversions from a scene point to price or datetime.  It
        is also used so we can convert price or datetime to a scaled
        value.
        """

        self.log.debug("Entered setConvertObj()")
        
        self.convertObj = convertObj
        
        self.log.debug("Exiting setConvertObj()")
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # Height of the vertical bar drawn.
        self.fibFanBarHeight = \
            priceBarChartSettings.\
            fibFanGraphicsItemBarHeight 
 
        # Font.
        self.fibFanTextFont = QFont()
        self.fibFanTextFont.fromString(\
            priceBarChartSettings.\
            fibFanGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.fibFanGraphicsItemTextColor = \
            priceBarChartSettings.\
            fibFanGraphicsItemDefaultTextColor

        # Color of the graphicsitem.
        self.fibFanGraphicsItemColor = \
            priceBarChartSettings.\
            fibFanGraphicsItemDefaultColor

        # X scaling of the text.
        self.fibFanTextXScaling = \
            priceBarChartSettings.\
            fibFanGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.fibFanTextYScaling = \
            priceBarChartSettings.\
            fibFanGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        self.textEnabledFlag = \
            priceBarChartSettings.\
            fibFanGraphicsItemTextEnabledFlag

        # Ratios (bool).
        self.ratios = \
            copy.deepcopy(priceBarChartSettings.\
                          fibFanGraphicsItemRatios)
        
        ########

        # Set values in the artifact.
        self.artifact.setFont(self.fibFanTextFont)
        self.artifact.setColor(self.fibFanGraphicsItemColor)
        self.artifact.setTextColor(self.fibFanGraphicsItemTextColor)
        self.artifact.setTextXScaling(self.fibFanTextXScaling)
        self.artifact.setTextYScaling(self.fibFanTextYScaling)
        self.artifact.setTextEnabled(self.textEnabledFlag)
        
        self.artifact.setRatios(self.ratios)
        
        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.originPointF,
        self.leg1PointF, and self.leg2PointF

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.originPointF

        # Update the start, leg1 and leg2 points accordingly. 
        self.originPointF = self.originPointF + posDelta
        self.leg1PointF = self.leg1PointF + posDelta
        self.leg2PointF = self.leg2PointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # origin or leg points, then the user is trying to adjust
            # the origin or leg points.

            # Get the click point in scene coordinates.
            clickScenePos = event.scenePos()
            clickScenePosX = clickScenePos.x()
            clickScenePosY = clickScenePos.y()
            
            self.log.debug("DEBUG: clickScenePosX={}".format(clickScenePosX))
            self.log.debug("DEBUG: clickScenePosY={}".format(clickScenePosY))


            # Get the shape of the line segments of the legs.  The
            # returned QPainterPath is in scene coordinates.
            shapeOfOriginToLeg1Point = \
                self.getShapeOfLineSegment(self.originPointF, self.leg1PointF)
            shapeOfOriginToLeg2Point = \
                self.getShapeOfLineSegment(self.originPointF, self.leg2PointF)

            # Flags that hold whether the click was inside the leg1
            # line segment or leg2 line segment.
            insideLeg1LineSegment = False
            insideLeg2LineSegment = False

            if shapeOfOriginToLeg1Point.contains(clickScenePos) == True:
                self.log.debug("Click point is within the line segment from " +
                               "origin point to leg1 point.")

                insideLeg1LineSegment = True

            elif shapeOfOriginToLeg2Point.contains(clickScenePos) == True:
                self.log.debug("Click point is within the line segment from " +
                               "origin point to leg2 point.")

                insideLeg2LineSegment = True


            self.log.debug("insideLeg1LineSegment={}".\
                           format(insideLeg1LineSegment))
            self.log.debug("insideLeg2LineSegment={}".\
                           format(insideLeg2LineSegment))

                
            # Handle the case that the click was inside a line segment
            # that makes up the outter edge of this fan.
            if insideLeg1LineSegment == True:
                
                startingPointX = self.originPointF.x()
                startingPointY = self.originPointF.y()

                endingPointX = self.leg1PointF.x()
                endingPointY = self.leg1PointF.y()
                
                self.log.debug("DEBUG: startingPointX={}, startingPointY={}".\
                               format(startingPointX, startingPointY))
                self.log.debug("DEBUG: endingPointX={}, endingPointY={}".\
                               format(endingPointX, endingPointY))

                startThresholdX = startingPointX + \
                                  ((endingPointX - startingPointX) * (1.0 / 5))
                endThresholdX = endingPointX - \
                                  ((endingPointX - startingPointX) * (1.0 / 5))

                startThresholdY = startingPointY + \
                                  ((endingPointY - startingPointY) * (1.0 / 5))
                endThresholdY = endingPointY - \
                                  ((endingPointY - startingPointY) * (1.0 / 5))

                self.log.debug("DEBUG: startThresholdX={}".\
                               format(startThresholdX))
                self.log.debug("DEBUG: endThresholdX={}".\
                               format(endThresholdX))

                self.log.debug("DEBUG: startThresholdY={}".\
                               format(startThresholdY))
                self.log.debug("DEBUG: endThresholdY={}".\
                               format(endThresholdY))

                startingPointRect = \
                    QRectF(QPointF(startingPointX, startingPointY),
                           QPointF(startThresholdX, startThresholdY))

                endingPointRect = \
                    QRectF(QPointF(endThresholdX, endThresholdY),
                           QPointF(endingPointX, endingPointY))

                if startingPointRect.contains(clickScenePos):

                    self.draggingOriginPointFlag = True
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))

                elif endingPointRect.contains(clickScenePos):

                    self.draggingLeg1PointFlag = True
                    self.log.debug("DEBUG: self.draggingLeg1PointFlag={}".
                                   format(self.draggingLeg1PointFlag))

                else:
                    self.log.debug("Not-endpoints part of the " +
                                   "line segment clicked.")
            
            elif insideLeg2LineSegment == True:
                
                startingPointX = self.originPointF.x()
                startingPointY = self.originPointF.y()

                endingPointX = self.leg2PointF.x()
                endingPointY = self.leg2PointF.y()
                
                self.log.debug("DEBUG: startingPointX={}, startingPointY={}".\
                               format(startingPointX, startingPointY))
                self.log.debug("DEBUG: endingPointX={}, endingPointY={}".\
                               format(endingPointX, endingPointY))

                startThresholdX = startingPointX + \
                                  ((endingPointX - startingPointX) * (1.0 / 5))
                endThresholdX = endingPointX - \
                                  ((endingPointX - startingPointX) * (1.0 / 5))

                startThresholdY = startingPointY + \
                                  ((endingPointY - startingPointY) * (1.0 / 5))
                endThresholdY = endingPointY - \
                                  ((endingPointY - startingPointY) * (1.0 / 5))

                self.log.debug("DEBUG: startThresholdX={}".\
                               format(startThresholdX))
                self.log.debug("DEBUG: endThresholdX={}".\
                               format(endThresholdX))

                self.log.debug("DEBUG: startThresholdY={}".\
                               format(startThresholdY))
                self.log.debug("DEBUG: endThresholdY={}".\
                               format(endThresholdY))

                startingPointRect = \
                    QRectF(QPointF(startingPointX, startingPointY),
                           QPointF(startThresholdX, startThresholdY))

                endingPointRect = \
                    QRectF(QPointF(endThresholdX, endThresholdY),
                           QPointF(endingPointX, endingPointY))

                if startingPointRect.contains(clickScenePos):

                    self.draggingOriginPointFlag = True
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))

                elif endingPointRect.contains(clickScenePos):

                    self.draggingLeg2PointFlag = True
                    self.log.debug("DEBUG: self.draggingLeg2PointFlag={}".
                                   format(self.draggingLeg2PointFlag))
            
                else:
                    self.log.debug("Not-endpoints part of the " +
                                   "line segment clicked.")
                    
            else:
                self.log.debug("Middle area of the line segment clicked.")


            # If none of the drag point flags are set, then the user
            # has clicked somewhere in teh middle part of the
            # QGraphicsItem (somewhere not close to an endpoint).
            if self.draggingOriginPointFlag == False and \
                self.draggingLeg1PointFlag == False and \
                self.draggingLeg2PointFlag == False:

                # Pass the event to the parent, because the user wants
                # to either select or drag-move the position of the
                # QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()

                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                
                if self.draggingOriginPointFlag == True:
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))
                    self.setOriginPointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()
                    
                elif self.draggingLeg1PointFlag == True:
                    self.log.debug("DEBUG: self.draggingLeg1PointFlag={}".
                                   format(self.draggingLeg1PointFlag))
                    self.setLeg1PointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()

                elif self.draggingLeg2PointFlag == True:
                    self.log.debug("DEBUG: self.draggingLeg2PointFlag={}".
                                   format(self.draggingLeg2PointFlag))
                    self.setLeg2PointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()
                    
                else:
                    # This means that the user is dragging the whole
                    # item.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingOriginPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "originPoint.")
            
            self.draggingOriginPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingLeg1PointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "leg1Point.")
            
            self.draggingLeg1PointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingLeg2PointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "leg2Point.")
            
            self.draggingLeg2PointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.originPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingOriginPointFlag = False
            self.draggingLeg1PointFlag = False
            self.draggingLeg2PointFlag = False

    def refreshItem(self):
        """Refreshes the item by recalculating and updating the text
        position/rotation.
        """

        self.recalculateFibFan()
        
        self.refreshTextItems()
        
    def refreshTextItems(self):
        """Sets the positions of the text items for the Ratios,
        and updates the text so that they are current.
        """

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        # Update the fibFan label text item texts.
        if self.scene() != None and self.convertObj != None:
            self.recalculateFibFan()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getRatios())):
                # Get the Ratio that corresponds to this index.
                ratio = artifact.getRatios()[i]

                # Here we always set the positions of everything.  If
                # the ratio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateFibFan() call above.

                # Get the unscaled originPointF, leg1PointF, and leg2PointF.
                unscaledOriginPointF = artifact.getOriginPointF()
                unscaledLeg1PointF = artifact.getLeg1PointF()
                unscaledLeg2PointF = artifact.getLeg2PointF()

                #self.log.debug("unscaledOriginPointF is: ({}, {})".
                #               format(unscaledOriginPointF.x(),
                #                      unscaledOriginPointF.y()))
                #self.log.debug("unscaledLeg1PointF is: ({}, {})".
                #               format(unscaledLeg1PointF.x(),
                #                      unscaledLeg1PointF.y()))
                #self.log.debug("unscaledLeg2PointF is: ({}, {})".
                #               format(unscaledLeg2PointF.x(),
                #                      unscaledLeg2PointF.y()))

                # Calculate scaled originPointF, leg1PointF and
                # leg2PointF points.
                scaledOriginPointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getOriginPointF())
                scaledLeg1PointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getLeg1PointF())
                scaledLeg2PointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getLeg2PointF())
        
                #self.log.debug("scaledOriginPointF is: ({}, {})".
                #               format(scaledOriginPointF.x(),
                #                      scaledOriginPointF.y()))
                #self.log.debug("scaledLeg1PointF is: ({}, {})".
                #               format(scaledLeg1PointF.x(),
                #              scaledLeg1PointF.y()))
                #self.log.debug("scaledLeg2PointF is: ({}, {})".
                #               format(scaledLeg2PointF.x(),
                #                      scaledLeg2PointF.y()))

                # Get the x and y position that will be the new
                # position of the text item.  This function returns
                # the x and y in scaled coordinates so we must
                # remember to convert those values afterwards.
                (x, y) = \
                    artifact.getXYForRatio(i,
                                           scaledOriginPointF,
                                           scaledLeg1PointF,
                                           scaledLeg2PointF)
                
                # Map those x and y to local coordinates.
                scenePointF = \
                    self.convertObj.convertScaledPointToScenePoint(\
                    QPointF(x, y))
                localPointF = self.mapFromScene(scenePointF)
                
                # Get the number of degrees to rotate the text by,
                # utilizing scaling.
                rotationDegrees = \
                    self.calculateTextRotationDegrees(self.originPointF,
                                                      scenePointF)
                
                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.fibFanTextXScaling, \
                                    self.fibFanTextYScaling)
                textTransform.rotate(rotationDegrees)

                # Get the text item for this point on the scale.
                textItem = self.ratioTextItems[i]

                # Set the position and other attributes.
                textItem.setPos(localPointF)
                textItem.setFont(self.fibFanTextFont)
                textItem.setPen(self.fibFanTextPen)
                textItem.setBrush(self.fibFanTextBrush)
                textItem.setTransform(textTransform)


            
    def setOriginPointF(self, pointF):
        """Sets the origin point of the fibFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.originPointF != pointF: 
            self.originPointF = pointF

            self.setPos(self.originPointF)
            
            # Update the fibFan label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setLeg1PointF(self, pointF):
        """Sets the leg1ing point of the fibFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.leg1PointF != pointF:
            self.leg1PointF = pointF

            self.log.debug("FibFanGraphicsItem." +
                           "setLeg1PointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the fibFan label text item positions.
            self.refreshTextItems()
            
            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setLeg2PointF(self, pointF):
        """Sets the leg2ing point of the fibFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.leg2PointF != pointF:
            self.leg2PointF = pointF

            self.log.debug("FibFanGraphicsItem." +
                           "setLeg2PointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the fibFan label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Does nothing since we do not normalize points for this class."""

        pass

    def recalculateFibFan(self):
        """Updates the text items that tell about the fann lines on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of angle.
        """

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        # Now recalculate if we have a convertObj to use for scaling
        # conversion calculation.
        if self.convertObj != None:
        
            # Get the origin point in scene, scaled, and local coordinates.
            sceneOriginPointF = self.originPointF
            scaledOriginPointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.originPointF)
            localOriginPointF = QPointF(0.0, 0.0)
    
            # Get the leg1 point in scene, scaled, and local coordinates.
            sceneLeg1PointF = self.leg1PointF
            scaledLeg1PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg1PointF)
            localLeg1PointF = QPointF(0.0, 0.0) + \
                              (self.leg1PointF - self.originPointF)
            
            # Get the leg2 point in scene, scaled, and local coordinates.
            sceneLeg2PointF = self.leg2PointF
            scaledLeg2PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg2PointF)
            localLeg2PointF = QPointF(0.0, 0.0) + \
                              (self.leg2PointF - self.originPointF)


            # Go through each ratio.
            artifact = self.getArtifact()
            ratios = artifact.getRatios()
            for i in range(len(ratios)):
                ratio = ratios[i]

                if ratio.isEnabled():
                    # Get the x and y position that will be the end point.
                    # This function returns the x and y in scaled
                    # coordinates so we must remember to convert those
                    # values afterwards.
                    (x, y) = \
                        artifact.getXYForRatio(i,
                                               scaledOriginPointF,
                                               scaledLeg1PointF,
                                               scaledLeg2PointF)
            
                    # Map those x and y to local coordinates.
                    sceneEndPointF = \
                        self.convertObj.convertScaledPointToScenePoint(\
                        QPointF(x, y))
                    
                    # Do conversion to local coordinates.
                    localEndPointF = sceneEndPointF - sceneOriginPointF

                    # Enable and make visible.

                    # Get the text item for this point on the scale.
                    textItem = self.ratioTextItems[i]
                    
                    # Make the text visible if it is enabled.
                    textEnabled = artifact.isTextEnabled()
                    textItem.setEnabled(textEnabled)
                    textItem.setVisible(textEnabled)

                    # If text isn't enabled, there's no need to
                    # set the text for it.  Go to the next text item.
                    if textEnabled == False:
                        continue

                    # Text to set in the text item.
                    text = ""

                    # Append the text for the fraction of the ratio.
                    text += "{}".format(ratio.getDescription()) + os.linesep
                    
                    # Append the text for the angle of the line.
                    # Uncomment below to re-add the scaled angle to the text.
                    #scaledAngleDegrees = \
                    #    self.calculateScaledAngleDegrees(self.originPointF,
                    #                                     sceneEndPointF)
                    #text += "{:.4f} deg".format(scaledAngleDegrees) + \
                    #        os.linesep


                    # Set the text to the text item.
                    text = text.rstrip()
                    textItem.setText(text)
                    
                else:
                    # Disable and make not visable.
                    
                    # Get the text item for this point on the scale.
                    textItem = self.ratioTextItems[i]
                    
                    textItem.setVisible(False)
                    textItem.setEnabled(False)
                
                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartFibFanArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartFibFanArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartFibFanArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartFibFanArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        originPointF = self.artifact.getOriginPointF()
        leg1PointF = self.artifact.getLeg1PointF()
        leg2PointF = self.artifact.getLeg2PointF()
        self.setOriginPointF(originPointF)
        self.setLeg1PointF(leg1PointF)
        self.setLeg2PointF(leg2PointF)

        self.fibFanTextFont = self.artifact.getFont()
        
        self.fibFanPen.\
            setColor(self.artifact.getColor())
        self.fibFanTextPen.\
            setColor(self.artifact.getTextColor())
        self.fibFanTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the angles, since the origin, leg1 and leg2
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements may not be valid.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartFibFanArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartFibFanArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setOriginPointF(self.originPointF)
        self.artifact.setLeg1PointF(self.leg1PointF)
        self.artifact.setLeg2PointF(self.leg2PointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def getShapeOfLineSegment(self, startPointF, endPointF):
        """Returns the shape as a QPainterPath of the line segment
        constructed via the two input QPointFs.  The shape is
        constructed by a rectangle around the start and end points.
        The rectangle is tilted based on the angle of the start and
        end points in view-scaled coordinates.  The bar height used is
        whatever is returned by self.fibFanBarHeight.

        Arguments:
        
        startPointF - QPointF representing the start point of the line
                      segment in either scene or local coordinates.
        endPointF   - QPointF representing the end point of the line segment
                      in either scene or local scene coordinates.

        Returns:
        QPainterPath object holding the shape of the rectangle around
        the line segment.  If the start and end points are given in
        local coordinates, then the QPainterPath returned will also be
        in local coordinates, otherwise the QPainterPath returned will
        be in scene coordinates.
        """

        self.log.debug("Entered getShapeOfLineSegment()")
        
        #self.log.debug("startPointF is: ({}, {})".\
        #               format(startPointF.x(),
        #                      startPointF.y()))
        #self.log.debug("endPointF is: ({}, {})".\
        #               format(endPointF.x(),
        #                      endPointF.y()))

        #tempRect = QRectF(startPointF, endPointF)
        #self.log.debug("Bounding rect of the two points beforehand is: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(tempRect.x(),
        #                      tempRect.y(),
        #                      tempRect.width(),
        #                      tempRect.height()))
        
        # Utilize scaling from the scene if it is available.
        scaling = PriceBarChartScaling()
        if self.scene() != None:
            scaling = self.scene().getScaling()
            
        viewScaledStartPoint = \
            QPointF(startPointF.x() * scaling.getViewScalingX(),
                    startPointF.y() * scaling.getViewScalingY())
        viewScaledEndPoint = \
            QPointF(endPointF.x() * scaling.getViewScalingX(),
                    endPointF.y() * scaling.getViewScalingY())

        angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
        angleRad = math.radians(angleDeg)

        self.log.debug("angleDeg is: {}".format(angleDeg))
        self.log.debug("angleRad is: {}".format(angleRad))

        shiftX = math.sin(angleRad) * \
                     (0.5 * self.fibFanBarHeight) / \
                     scaling.getViewScalingX()
        
        shiftY = math.cos(angleRad) * \
                     (0.5 * self.fibFanBarHeight) / \
                     scaling.getViewScalingY()
        
        #self.log.debug("shiftX is: {}".format(shiftX))
        #self.log.debug("shiftY is: {}".format(shiftY))
        
        # Create new points.
        p1 = \
            QPointF(startPointF.x() - shiftX,
                    startPointF.y() - shiftY)
        p2 = \
            QPointF(startPointF.x() + shiftX,
                    startPointF.y() + shiftY)
        p3 = \
            QPointF(endPointF.x() - shiftX,
                    endPointF.y() - shiftY)
        p4 = \
            QPointF(endPointF.x() + shiftX,
                    endPointF.y() + shiftY)

        #self.log.debug("p1 is: ({}, {})".format(p1.x(), p1.y()))
        #self.log.debug("p2 is: ({}, {})".format(p2.x(), p2.y()))
        #self.log.debug("p3 is: ({}, {})".format(p3.x(), p3.y()))
        #self.log.debug("p4 is: ({}, {})".format(p4.x(), p4.y()))

        points = [p2, p1, p3, p4, p2]
        polygon = QPolygonF(points)

        painterPath = QPainterPath()
        painterPath.addPolygon(polygon)


        #tempRect = painterPath.boundingRect()
        #self.log.debug("Bounding rect of polygon afterwards is: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(tempRect.x(),
        #                      tempRect.y(),
        #                      tempRect.width(),
        #                      tempRect.height()))
        
        return painterPath

    def calculateTextRotationDegrees(self, startPointF, endPointF):
        """Calculates the number of degrees that a
        QGraphicsSimpleTextItem should be rotated so that it is
        parallel to the line constructed by the 'startPointF' and
        'endPointF' parameters.  ViewScaling is utilized to determine the angle.

        Arguments:
        startPointF - start point of the line segment to align the
                      text's angle with.
        endPointF   - start point of the line segment to align the
                      text's angle with.

        Returns:
        float value holding angle that the text needs to be rotated, in degrees.
        """

        # Return value.
        angleDeg = 0.0
        
        # Determine the number of degrees to rotate the text by,
        # utilizing scaling.
        if self.scene() != None:
            scaling = self.scene().getScaling()

            viewScaledStartPoint = \
                QPointF(startPointF.x() * scaling.getViewScalingX(),
                        startPointF.y() * scaling.getViewScalingY())
            viewScaledEndPoint = \
                QPointF(endPointF.x() * scaling.getViewScalingX(),
                        endPointF.y() * scaling.getViewScalingY())
            
            angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
            self.log.debug("Scaled angleDeg before normalizing and fudge, " +
                           "angleDeg={}".format(angleDeg))
        else:
            # No scaling is available, so just do the unscaled angle.
            angleDeg = QLineF(startPointF, endPointF).angle()
            self.log.debug("Unscaled angleDeg before normalizing and fudge, " +
                           "angleDeg={}".format(angleDeg))
            
        # Normalize the angle so that the text is always upright.
        if 90 <= angleDeg <= 270:
            angleDeg += 180
        angleDeg = Util.toNormalizedAngle(angleDeg)

        self.log.debug("Before fudge, angleDeg={}".format(angleDeg))
        
        # Fudge factor since for some reason the text item doesn't
        # exactly line up with the line.
        fudge = 0.0
        if 0 < angleDeg <= 90:
            self.log.debug("0 to 90")
            removed = 45 - abs(45 - angleDeg)
            fudge = removed * 0.19
            angleDeg -= fudge
        elif 90 < angleDeg <= 180:
            self.log.debug("90 to 180")
            removed = 45 - abs(135 - angleDeg)
            fudge = removed * 0.12
            angleDeg += fudge
        elif 180 < angleDeg <= 270:
            self.log.debug("180 to 270")
            removed = 45 - abs(225 - angleDeg)
            fudge = removed * 0.19
            angleDeg -= fudge
        elif 270 < angleDeg <= 360:
            self.log.debug("270 to 360")
            removed = 45 - abs(315 - angleDeg)
            fudge = removed * 0.12
            angleDeg += fudge
            
        angleDeg = -1.0 * angleDeg
        self.log.debug("angleDeg={}".format(angleDeg))

        return angleDeg
    
    def calculateScaledAngleDegrees(self, startPointF, endPointF):
        """Calculates the number of degrees of angle between
        'startPointF' and 'endPointF'.  This angle is calculated
        utilizing scaling conversion from self.convertObj.

        Arguments:
        startPointF - start point of the line segment, in scene coordinates.
        endPointF   - start point of the line segment, in scene coordinates.

        Returns:
        float value holding the scaled angle, in degrees.
        """

        angleDeg = 0.0

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        if self.convertObj != None:
            startScaledPoint = \
                self.convertObj.convertScenePointToScaledPoint(startPointF)
            endScaledPoint = \
                self.convertObj.convertScenePointToScaledPoint(endPointF)
        
            angleDeg = QLineF(startScaledPoint, endScaledPoint).angle()
        else:
            # Convert object is not set, so don't apply scaling, and
            # just return the angle with unscaled points.
            angleDeg = QLineF(startPointF, endPointF).angle()
            
        return angleDeg
        
    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is origin point.
        
        rv = self.shape().boundingRect()

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem,
        in local item coordinates.
        """

        #self.log.debug("Entered shape().")

        # Return value.
        # Holds the QPainterPath of the whole item (in local coordinates).
        painterPath = QPainterPath()

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        if scene != None and self.convertObj != None:
            # Scene exists and we can do scaling conversions.
            # Continue to calculate the painterPath.
            
            # Get the origin point in scene, scaled, and local coordinates.
            sceneOriginPointF = self.originPointF
            scaledOriginPointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.originPointF)
            localOriginPointF = QPointF(0.0, 0.0)

            #self.log.debug("sceneOriginPointF is: ({}, {})".\
            #               format(sceneOriginPointF.x(),
            #                      sceneOriginPointF.y()))
            #self.log.debug("scaledOriginPointF is: ({}, {})".\
            #               format(scaledOriginPointF.x(),
            #                      scaledOriginPointF.y()))
            #self.log.debug("localOriginPointF is: ({}, {})".\
            #               format(localOriginPointF.x(),
            #                      localOriginPointF.y()))
                           
            # Get the leg1 point in scene, scaled, and local coordinates.
            sceneLeg1PointF = self.leg1PointF
            scaledLeg1PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg1PointF)
            localLeg1PointF = QPointF(0.0, 0.0) + \
                              (self.leg1PointF - self.originPointF)
            
            #self.log.debug("sceneLeg1PointF is: ({}, {})".\
            #               format(sceneLeg1PointF.x(),
            #                      sceneLeg1PointF.y()))
            #self.log.debug("scaledLeg1PointF is: ({}, {})".\
            #               format(scaledLeg1PointF.x(),
            #                      scaledLeg1PointF.y()))
            #self.log.debug("localLeg1PointF is: ({}, {})".\
            #               format(localLeg1PointF.x(),
            #                      localLeg1PointF.y()))
            
            # Get the leg2 point in scene, scaled, and local coordinates.
            sceneLeg2PointF = self.leg2PointF
            scaledLeg2PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg2PointF)
            localLeg2PointF = QPointF(0.0, 0.0) + \
                              (self.leg2PointF - self.originPointF)
    
            #self.log.debug("sceneLeg2PointF is: ({}, {})".\
            #               format(sceneLeg2PointF.x(),
            #                      sceneLeg2PointF.y()))
            #self.log.debug("scaledLeg2PointF is: ({}, {})".\
            #               format(scaledLeg2PointF.x(),
            #                      scaledLeg2PointF.y()))
            #self.log.debug("localLeg2PointF is: ({}, {})".\
            #               format(localLeg2PointF.x(),
            #                      localLeg2PointF.y()))

            
            #tempRect = painterPath.boundingRect()
            #self.log.debug("Before adding paths, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))
                           
            # Add the path for the shape of the line segment created by
            # points self.originPointF to self.leg1PointF.  
            leg1PainterPath = \
                self.getShapeOfLineSegment(localOriginPointF, localLeg1PointF)
            painterPath.addPath(leg1PainterPath)


            #tempRect = painterPath.boundingRect()
            #self.log.debug("After adding leg1PainterPath, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))
            
            
            # Add the path for the shape of the line segment created by
            # points self.originPointF to self.leg2PointF.
            leg2PainterPath = \
                self.getShapeOfLineSegment(localOriginPointF, localLeg2PointF)
            painterPath.addPath(leg2PainterPath)


            #tempRect = painterPath.boundingRect()
            #self.log.debug("After adding leg2PainterPath, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))

            
            # Go through each line of each enabled ratio, getting
            # the shape of the line segment and add that path to
            # 'painterPath'.
            artifact = self.getArtifact()
            ratios = artifact.getRatios()
            for i in range(len(ratios)):
                ratio = ratios[i]
    
                # Only add the path if the ratio is enabled.
                if ratio.isEnabled():
                    # Get the x and y position that will be the end point.
                    # This function returns the x and y in scaled
                    # coordinates so we must remember to convert those
                    # values afterwards.
                    (x, y) = \
                        artifact.getXYForRatio(i,
                                               scaledOriginPointF,
                                               scaledLeg1PointF,
                                               scaledLeg2PointF)

                    #self.log.debug("Ratio point X and Y for index " +
                    #               "{} in scaled coordinates is: ".format(i) +
                    #               "({}, {})".format(x, y))
                    
                    # Map those x and y to local coordinates.
                    sceneEndPointF = \
                        self.convertObj.convertScaledPointToScenePoint(\
                        QPointF(x, y))

                    #self.log.debug("Mapping that point to scene coords is " + 
                    #               "({}, {})".format(sceneEndPointF.x(),
                    #                                 sceneEndPointF.y()))
                
                    # Do conversion to local coordinates.
                    localEndPointF = sceneEndPointF - sceneOriginPointF
    
                    #self.log.debug("Mapping that point to local coords is " + 
                    #               "({}, {})".format(localEndPointF.x(),
                    #                                 localEndPointF.y()))
                
                    # Get the painter path.
                    endPointPainterPath = \
                        self.getShapeOfLineSegment(localOriginPointF,
                                                   localEndPointF)

                    #tempRect = painterPath.boundingRect()
                    #self.log.debug("Path for " +
                    #               "index {} ".format(i) +
                    #               "has bounding rect: " +
                    #               "x={}, y={}, w={}, h={}".\
                    #               format(tempRect.x(),
                    #                      tempRect.y(),
                    #                      tempRect.width(),
                    #                      tempRect.height()))
    
                    # Add the path to 'painterPath'.
                    painterPath.addPath(endPointPainterPath)


                    #tempRect = painterPath.boundingRect()
                    #self.log.debug("After adding path for " +
                    #               "index {}, ".format(i) +
                    #               "bounding rect of " +
                    #               "PainterPath is: " +
                    #               "x={}, y={}, w={}, h={}".\
                    #               format(tempRect.x(),
                    #                      tempRect.y(),
                    #                      tempRect.width(),
                    #                      tempRect.height()))
    
        else:
            # Scene doesn't exist or we can't scaling conversions.
            # No calculations to do since it won't get plotted anyways.
            self.log.debug("Tried to get shape scene isn't set.")
            pass
            

        #self.log.debug("Exiting shape(). " +
        #               "PainterPath being returned has a bounding rect of: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(painterPath.boundingRect().x(),
        #                      painterPath.boundingRect().y(),
        #                      painterPath.boundingRect().width(),
        #                      painterPath.boundingRect().height()))

        # The 'painterPath' should now have all the paths for the tilted
        # rectangles that make up the whole item.
        return painterPath

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.fibFanPen is set
        to what we want for the drawing style.
        """

        #self.log.debug("Entered FibFanGraphicsItem.paint().  " +
        #               "pos is: ({}, {})".\
        #               format(self.pos().x(), self.pos().y()) +
        #               os.linesep +
        #               "self.originPointF == ({}, {})".\
        #               format(self.originPointF.x(), self.originPointF.y()) +
        #               os.linesep +
        #               "self.leg1PointF == ({}, {})".\
        #               format(self.leg1PointF.x(), self.leg1PointF.y()) +
        #               os.linesep +
        #               "self.leg2PointF == ({}, {})".\
        #               format(self.leg2PointF.x(), self.leg2PointF.y()))
        
        if painter.pen() != self.fibFanPen:
            painter.setPen(self.fibFanPen)

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")
                # No scene, so don't paint anything.
                self.log.debug("There's no scene so we won't paint anything.")
                return

        # Get the origin point in scene, scaled, and local coordinates.
        sceneOriginPointF = self.originPointF
        scaledOriginPointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.originPointF)
        localOriginPointF = QPointF(0.0, 0.0)

        # Get the leg1 point in scene, scaled, and local coordinates.
        sceneLeg1PointF = self.leg1PointF
        scaledLeg1PointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.leg1PointF)
        localLeg1PointF = self.leg1PointF - self.originPointF
        
        # Get the leg2 point in scene, scaled, and local coordinates.
        sceneLeg2PointF = self.leg2PointF
        scaledLeg2PointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.leg2PointF)
        localLeg2PointF = self.leg2PointF - self.originPointF

        
        # Always draw the line from origin point to leg1 point.
        painter.drawLine(localOriginPointF, localLeg1PointF)
        
        # Always draw the line from origin point to leg2 point.
        painter.drawLine(localOriginPointF, localLeg2PointF)
        
        # For each ratio that is enabled, draw it as a line
        # segment from the origin point to the end point of that
        # ratio.
        artifact = self.getArtifact()
        ratios = artifact.getRatios()
        for i in range(len(ratios)):
            ratio = ratios[i]

            # Only add the path if the ratio is enabled.
            if ratio.isEnabled():
                # Get the x and y position that will be the end point.
                # This function returns the x and y in scaled
                # coordinates so we must remember to convert those
                # values afterwards.
                (x, y) = \
                    artifact.getXYForRatio(i,
                                           scaledOriginPointF,
                                           scaledLeg1PointF,
                                           scaledLeg2PointF)
        
                # Map those x and y to local coordinates.
                sceneEndPointF = \
                    self.convertObj.convertScaledPointToScenePoint(\
                    QPointF(x, y))
            
                # Do conversion to local coordinates.
                localEndPointF = sceneEndPointF - sceneOriginPointF

                # Draw the line segment for this ratio.
                painter.drawLine(localOriginPointF, localEndPointF)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.fibFanPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
        self.log.debug("Exiting FibFanGraphicsItem.paint().")

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this FibFanGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        FibFanGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        extendLeg1PointAction = \
            QAction("E&xtend leg1 point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenLeg1PointAction = \
            QAction("Shor&ten leg1 point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        extendLeg2PointAction = \
            QAction("Exte&nd leg2 point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenLeg2PointAction = \
            QAction("S&horten leg2 point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        
        setOriginOnAstro1Action = \
            QAction("Set origin timestamp on Astro Chart &1", parent)
        setOriginOnAstro2Action = \
            QAction("Set origin timestamp on Astro Chart &2", parent)
        setOriginOnAstro3Action = \
            QAction("Set origin timestamp on Astro Chart &3", parent)
        openOriginInJHoraAction = \
            QAction("Open JHor&a with origin timestamp", parent)
        openOriginInAstrologAction = \
            QAction("Open Astrolog with origin timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        extendLeg1PointAction.triggered.\
            connect(self._handleExtendLeg1PointAction)
        shortenLeg1PointAction.triggered.\
            connect(self._handleShortenLeg1PointAction)
        extendLeg2PointAction.triggered.\
            connect(self._handleExtendLeg2PointAction)
        shortenLeg2PointAction.triggered.\
            connect(self._handleShortenLeg2PointAction)
        setOriginOnAstro1Action.triggered.\
            connect(self._handleSetOriginOnAstro1Action)
        setOriginOnAstro2Action.triggered.\
            connect(self._handleSetOriginOnAstro2Action)
        setOriginOnAstro3Action.triggered.\
            connect(self._handleSetOriginOnAstro3Action)
        openOriginInJHoraAction.triggered.\
            connect(self._handleOpenOriginInJHoraAction)
        openOriginInAstrologAction.triggered.\
            connect(self._handleOpenOriginInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        extendLeg1PointAction.setEnabled(not readOnlyMode)
        shortenLeg1PointAction.setEnabled(not readOnlyMode)
        extendLeg2PointAction.setEnabled(not readOnlyMode)
        shortenLeg2PointAction.setEnabled(not readOnlyMode)
        setOriginOnAstro1Action.setEnabled(True)
        setOriginOnAstro2Action.setEnabled(True)
        setOriginOnAstro3Action.setEnabled(True)
        openOriginInJHoraAction.setEnabled(True)
        openOriginInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(extendLeg1PointAction)
        menu.addAction(shortenLeg1PointAction)
        menu.addAction(extendLeg2PointAction)
        menu.addAction(shortenLeg2PointAction)
        menu.addSeparator()
        menu.addAction(setOriginOnAstro1Action)
        menu.addAction(setOriginOnAstro2Action)
        menu.addAction(setOriginOnAstro3Action)
        menu.addAction(openOriginInJHoraAction)
        menu.addAction(openOriginInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartFibFanArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartFibFanArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleExtendLeg1PointAction(self):
        """Updates the QGraphicsItem so that the leg1 point is
        (self.extendMultiple) fold of the current distance away from origin
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg1PointF.x() - self.originPointF.x()
        deltaY = self.leg1PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg1PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg1PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenLeg1PointAction(self):
        """Updates the QGraphicsItem so that the leg1 point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        origin point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg1PointF.x() - self.originPointF.x()
        deltaY = self.leg1PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg1PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg1PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleExtendLeg2PointAction(self):
        """Updates the QGraphicsItem so that the leg2 point is
        (self.extendMultiple) fold of the current distance away from origin
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg2PointF.x() - self.originPointF.x()
        deltaY = self.leg2PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg2PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg2PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenLeg2PointAction(self):
        """Updates the QGraphicsItem so that the leg2 point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        origin point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg2PointF.x() - self.originPointF.x()
        deltaY = self.leg2PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg2PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg2PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetOriginOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the origin the FibFanGraphicsItem.
        """

        self.scene().setAstroChart1(self.originPointF.x())
        
    def _handleSetOriginOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the origin the FibFanGraphicsItem.
        """

        self.scene().setAstroChart2(self.originPointF.x())
        
    def _handleSetOriginOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the origin the FibFanGraphicsItem.
        """

        self.scene().setAstroChart3(self.originPointF.x())
        
    def _handleOpenOriginInJHoraAction(self):
        """Causes the the timestamp of the origin the
        FibFanGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.originPointF.x())
        
    def _handleOpenOriginInAstrologAction(self):
        """Causes the the timestamp of the origin the
        FibFanGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.originPointF.x())
        
        
class GannFanGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a Gann Fan in
    the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    origin point.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.GannFanGraphicsItem")
        
        self.log.debug("Entered __init__().")

        # Constant value for the multiple amount to extend the
        # leg1PointF or leg2PointF points.  This feature shows up as
        # an option in the right-click context menu option.
        self.extendMultiple = 1.6
        
        ############################################################
        # Set default values for preferences/settings.

        # Height of the vertical bar drawn.
        self.gannFanBarHeight = \
            PriceBarChartSettings.\
                defaultGannFanGraphicsItemBarHeight 
 
        # Font.
        self.gannFanTextFont = QFont()
        self.gannFanTextFont.fromString(\
            PriceBarChartSettings.\
            defaultGannFanGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.gannFanGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultGannFanGraphicsItemDefaultTextColor

        # Color of the graphicsitem.
        self.gannFanGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultGannFanGraphicsItemDefaultColor

        # X scaling of the text.
        self.gannFanTextXScaling = \
            PriceBarChartSettings.\
                defaultGannFanGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.gannFanTextYScaling = \
            PriceBarChartSettings.\
                defaultGannFanGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        self.textEnabledFlag = \
            PriceBarChartSettings.\
            defaultGannFanGraphicsItemTextEnabledFlag
    
        # Ratios (bool).
        self.ratios = \
            copy.deepcopy(PriceBarChartSettings.\
                          defaultGannFanGraphicsItemRatios)
    
        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartGannFanArtifact()

        # Convert object.
        self.convertObj = None
        
        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.gannFanPenWidth = 0.0
        self.gannFanPen = QPen()
        self.gannFanPen.setColor(self.gannFanGraphicsItemColor)
        self.gannFanPen.setWidthF(self.gannFanPenWidth)
        
        # Origin point, in scene coordinates.
        self.originPointF = QPointF(0, 0)

        # Leg1 point, in scene coordinates.
        self.leg1PointF = QPointF(0, 0)

        # Leg2 point, in scene coordinates.
        self.leg2PointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the pen color of the text.
        self.gannFanTextPen = self.dummyItem.pen()
        self.gannFanTextPen.\
            setColor(self.gannFanGraphicsItemTextColor)

        # Set the brush color of the text.
        self.gannFanTextBrush = self.dummyItem.brush()
        self.gannFanTextBrush.\
            setColor(self.gannFanGraphicsItemTextColor)

        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.gannFanTextXScaling, \
                            self.gannFanTextYScaling)
        textTransform.rotate(0.0)
        
        # Below is a list of QGraphicsSimpleTextItems, for each of the
        # Ratios in the PriceBarChartGannFanArtifact.  The
        # text contains the interval fraction, and the angle
        # of the line.
        #
        self.ratioTextItems = []

        # Initialize to blank and set at the leg1 point.
        for ratio in range(len(self.artifact.getRatios())):
            
            fractionTextItem = QGraphicsSimpleTextItem("", self)
            fractionTextItem.setPos(self.leg1PointF)
            fractionTextItem.setFont(self.gannFanTextFont)
            fractionTextItem.setPen(self.gannFanTextPen)
            fractionTextItem.setBrush(self.gannFanTextBrush)
            fractionTextItem.setTransform(textTransform)
            
            self.ratioTextItems.\
                append(fractionTextItem)

        # Flags that indicate that the user is dragging either the
        # origin, leg1 or leg2 points of the QGraphicsItem.
        self.draggingOriginPointFlag = False
        self.draggingLeg1PointFlag = False
        self.draggingLeg2PointFlag = False
        self.clickScenePointF = None

    def setConvertObj(self, convertObj):
        """Object for doing conversions from x and datetime and y to
        price.  This should be the graphics scene.  This is used for
        doing conversions from a scene point to price or datetime.  It
        is also used so we can convert price or datetime to a scaled
        value.
        """

        self.log.debug("Entered setConvertObj()")
        
        self.convertObj = convertObj
        
        self.log.debug("Exiting setConvertObj()")
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # Height of the vertical bar drawn.
        self.gannFanBarHeight = \
            priceBarChartSettings.\
            gannFanGraphicsItemBarHeight 
 
        # Font.
        self.gannFanTextFont = QFont()
        self.gannFanTextFont.fromString(\
            priceBarChartSettings.\
            gannFanGraphicsItemDefaultFontDescription)
        
        # Color of the text that is associated with the graphicsitem.
        self.gannFanGraphicsItemTextColor = \
            priceBarChartSettings.\
            gannFanGraphicsItemDefaultTextColor

        # Color of the graphicsitem.
        self.gannFanGraphicsItemColor = \
            priceBarChartSettings.\
            gannFanGraphicsItemDefaultColor

        # X scaling of the text.
        self.gannFanTextXScaling = \
            priceBarChartSettings.\
            gannFanGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.gannFanTextYScaling = \
            priceBarChartSettings.\
            gannFanGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        self.textEnabledFlag = \
            priceBarChartSettings.\
            gannFanGraphicsItemTextEnabledFlag

        # Ratios (bool).
        self.ratios = \
            copy.deepcopy(priceBarChartSettings.\
                          gannFanGraphicsItemRatios)
        
        ########

        # Set values in the artifact.
        self.artifact.setFont(self.gannFanTextFont)
        self.artifact.setColor(self.gannFanGraphicsItemColor)
        self.artifact.setTextColor(self.gannFanGraphicsItemTextColor)
        self.artifact.setTextXScaling(self.gannFanTextXScaling)
        self.artifact.setTextYScaling(self.gannFanTextYScaling)
        self.artifact.setTextEnabled(self.textEnabledFlag)
        
        self.artifact.setRatios(self.ratios)
        
        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.originPointF,
        self.leg1PointF, and self.leg2PointF

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.originPointF

        # Update the start, leg1 and leg2 points accordingly. 
        self.originPointF = self.originPointF + posDelta
        self.leg1PointF = self.leg1PointF + posDelta
        self.leg2PointF = self.leg2PointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # origin or leg points, then the user is trying to adjust
            # the origin or leg points.

            # Get the click point in scene coordinates.
            clickScenePos = event.scenePos()
            clickScenePosX = clickScenePos.x()
            clickScenePosY = clickScenePos.y()
            
            self.log.debug("DEBUG: clickScenePosX={}".format(clickScenePosX))
            self.log.debug("DEBUG: clickScenePosY={}".format(clickScenePosY))


            # Get the shape of the line segments of the legs.  The
            # returned QPainterPath is in scene coordinates.
            shapeOfOriginToLeg1Point = \
                self.getShapeOfLineSegment(self.originPointF, self.leg1PointF)
            shapeOfOriginToLeg2Point = \
                self.getShapeOfLineSegment(self.originPointF, self.leg2PointF)

            # Flags that hold whether the click was inside the leg1
            # line segment or leg2 line segment.
            insideLeg1LineSegment = False
            insideLeg2LineSegment = False

            if shapeOfOriginToLeg1Point.contains(clickScenePos) == True:
                self.log.debug("Click point is within the line segment from " +
                               "origin point to leg1 point.")

                insideLeg1LineSegment = True

            elif shapeOfOriginToLeg2Point.contains(clickScenePos) == True:
                self.log.debug("Click point is within the line segment from " +
                               "origin point to leg2 point.")

                insideLeg2LineSegment = True


            self.log.debug("insideLeg1LineSegment={}".\
                           format(insideLeg1LineSegment))
            self.log.debug("insideLeg2LineSegment={}".\
                           format(insideLeg2LineSegment))

                
            # Handle the case that the click was inside a line segment
            # that makes up the outter edge of this fan.
            if insideLeg1LineSegment == True:
                
                startingPointX = self.originPointF.x()
                startingPointY = self.originPointF.y()

                endingPointX = self.leg1PointF.x()
                endingPointY = self.leg1PointF.y()
                
                self.log.debug("DEBUG: startingPointX={}, startingPointY={}".\
                               format(startingPointX, startingPointY))
                self.log.debug("DEBUG: endingPointX={}, endingPointY={}".\
                               format(endingPointX, endingPointY))

                startThresholdX = startingPointX + \
                                  ((endingPointX - startingPointX) * (1.0 / 5))
                endThresholdX = endingPointX - \
                                  ((endingPointX - startingPointX) * (1.0 / 5))

                startThresholdY = startingPointY + \
                                  ((endingPointY - startingPointY) * (1.0 / 5))
                endThresholdY = endingPointY - \
                                  ((endingPointY - startingPointY) * (1.0 / 5))

                self.log.debug("DEBUG: startThresholdX={}".\
                               format(startThresholdX))
                self.log.debug("DEBUG: endThresholdX={}".\
                               format(endThresholdX))

                self.log.debug("DEBUG: startThresholdY={}".\
                               format(startThresholdY))
                self.log.debug("DEBUG: endThresholdY={}".\
                               format(endThresholdY))

                startingPointRect = \
                    QRectF(QPointF(startingPointX, startingPointY),
                           QPointF(startThresholdX, startThresholdY))

                endingPointRect = \
                    QRectF(QPointF(endThresholdX, endThresholdY),
                           QPointF(endingPointX, endingPointY))

                if startingPointRect.contains(clickScenePos):

                    self.draggingOriginPointFlag = True
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))

                elif endingPointRect.contains(clickScenePos):

                    self.draggingLeg1PointFlag = True
                    self.log.debug("DEBUG: self.draggingLeg1PointFlag={}".
                                   format(self.draggingLeg1PointFlag))

                else:
                    self.log.debug("Not-endpoints part of the " +
                                   "line segment clicked.")
            
            elif insideLeg2LineSegment == True:
                
                startingPointX = self.originPointF.x()
                startingPointY = self.originPointF.y()

                endingPointX = self.leg2PointF.x()
                endingPointY = self.leg2PointF.y()
                
                self.log.debug("DEBUG: startingPointX={}, startingPointY={}".\
                               format(startingPointX, startingPointY))
                self.log.debug("DEBUG: endingPointX={}, endingPointY={}".\
                               format(endingPointX, endingPointY))

                startThresholdX = startingPointX + \
                                  ((endingPointX - startingPointX) * (1.0 / 5))
                endThresholdX = endingPointX - \
                                  ((endingPointX - startingPointX) * (1.0 / 5))

                startThresholdY = startingPointY + \
                                  ((endingPointY - startingPointY) * (1.0 / 5))
                endThresholdY = endingPointY - \
                                  ((endingPointY - startingPointY) * (1.0 / 5))

                self.log.debug("DEBUG: startThresholdX={}".\
                               format(startThresholdX))
                self.log.debug("DEBUG: endThresholdX={}".\
                               format(endThresholdX))

                self.log.debug("DEBUG: startThresholdY={}".\
                               format(startThresholdY))
                self.log.debug("DEBUG: endThresholdY={}".\
                               format(endThresholdY))

                startingPointRect = \
                    QRectF(QPointF(startingPointX, startingPointY),
                           QPointF(startThresholdX, startThresholdY))

                endingPointRect = \
                    QRectF(QPointF(endThresholdX, endThresholdY),
                           QPointF(endingPointX, endingPointY))

                if startingPointRect.contains(clickScenePos):

                    self.draggingOriginPointFlag = True
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))

                elif endingPointRect.contains(clickScenePos):

                    self.draggingLeg2PointFlag = True
                    self.log.debug("DEBUG: self.draggingLeg2PointFlag={}".
                                   format(self.draggingLeg2PointFlag))
            
                else:
                    self.log.debug("Not-endpoints part of the " +
                                   "line segment clicked.")
                    
            else:
                self.log.debug("Middle area of the line segment clicked.")


            # If none of the drag point flags are set, then the user
            # has clicked somewhere in teh middle part of the
            # QGraphicsItem (somewhere not close to an endpoint).
            if self.draggingOriginPointFlag == False and \
                self.draggingLeg1PointFlag == False and \
                self.draggingLeg2PointFlag == False:

                # Pass the event to the parent, because the user wants
                # to either select or drag-move the position of the
                # QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()

                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                
                if self.draggingOriginPointFlag == True:
                    self.log.debug("DEBUG: self.draggingOriginPointFlag={}".
                                   format(self.draggingOriginPointFlag))
                    self.setOriginPointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()
                    
                elif self.draggingLeg1PointFlag == True:
                    self.log.debug("DEBUG: self.draggingLeg1PointFlag={}".
                                   format(self.draggingLeg1PointFlag))
                    self.setLeg1PointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()

                elif self.draggingLeg2PointFlag == True:
                    self.log.debug("DEBUG: self.draggingLeg2PointFlag={}".
                                   format(self.draggingLeg2PointFlag))
                    self.setLeg2PointF(QPointF(event.scenePos()))
                    self.prepareGeometryChange()
                    
                else:
                    # This means that the user is dragging the whole
                    # item.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingOriginPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "originPoint.")
            
            self.draggingOriginPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingLeg1PointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "leg1Point.")
            
            self.draggingLeg1PointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingLeg2PointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "leg2Point.")
            
            self.draggingLeg2PointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.originPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingOriginPointFlag = False
            self.draggingLeg1PointFlag = False
            self.draggingLeg2PointFlag = False

    def refreshItem(self):
        """Refreshes the item by recalculating and updating the text
        position/rotation.
        """

        self.recalculateGannFan()
        
        self.refreshTextItems()
        
    def refreshTextItems(self):
        """Sets the positions of the text items for the Ratios,
        and updates the text so that they are current.
        """

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        # Update the gannFan label text item texts.
        if self.scene() != None and self.convertObj != None:
            self.recalculateGannFan()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getRatios())):
                # Get the Ratio that corresponds to this index.
                ratio = artifact.getRatios()[i]

                # Here we always set the positions of everything.  If
                # the ratio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateGannFan() call above.

                # Get the unscaled originPointF, leg1PointF, and leg2PointF.
                unscaledOriginPointF = artifact.getOriginPointF()
                unscaledLeg1PointF = artifact.getLeg1PointF()
                unscaledLeg2PointF = artifact.getLeg2PointF()

                #self.log.debug("unscaledOriginPointF is: ({}, {})".
                #               format(unscaledOriginPointF.x(),
                #                      unscaledOriginPointF.y()))
                #self.log.debug("unscaledLeg1PointF is: ({}, {})".
                #               format(unscaledLeg1PointF.x(),
                #                      unscaledLeg1PointF.y()))
                #self.log.debug("unscaledLeg2PointF is: ({}, {})".
                #               format(unscaledLeg2PointF.x(),
                #                      unscaledLeg2PointF.y()))

                # Calculate scaled originPointF, leg1PointF and
                # leg2PointF points.
                scaledOriginPointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getOriginPointF())
                scaledLeg1PointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getLeg1PointF())
                scaledLeg2PointF = \
                    self.convertObj.convertScenePointToScaledPoint(\
                    artifact.getLeg2PointF())
        
                #self.log.debug("scaledOriginPointF is: ({}, {})".
                #               format(scaledOriginPointF.x(),
                #                      scaledOriginPointF.y()))
                #self.log.debug("scaledLeg1PointF is: ({}, {})".
                #               format(scaledLeg1PointF.x(),
                #              scaledLeg1PointF.y()))
                #self.log.debug("scaledLeg2PointF is: ({}, {})".
                #               format(scaledLeg2PointF.x(),
                #                      scaledLeg2PointF.y()))

                # Get the x and y position that will be the new
                # position of the text item.  This function returns
                # the x and y in scaled coordinates so we must
                # remember to convert those values afterwards.
                (x, y) = \
                    artifact.getXYForRatio(i,
                                           scaledOriginPointF,
                                           scaledLeg1PointF,
                                           scaledLeg2PointF)
                
                # Map those x and y to local coordinates.
                scenePointF = \
                    self.convertObj.convertScaledPointToScenePoint(\
                    QPointF(x, y))
                localPointF = self.mapFromScene(scenePointF)
                
                # Get the number of degrees to rotate the text by,
                # utilizing scaling.
                rotationDegrees = \
                    self.calculateTextRotationDegrees(self.originPointF,
                                                      scenePointF)
                
                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.gannFanTextXScaling, \
                                    self.gannFanTextYScaling)
                textTransform.rotate(rotationDegrees)

                # Get the text item for this point on the scale.
                textItem = self.ratioTextItems[i]

                # Set the position and other attributes.
                textItem.setPos(localPointF)
                textItem.setFont(self.gannFanTextFont)
                textItem.setPen(self.gannFanTextPen)
                textItem.setBrush(self.gannFanTextBrush)
                textItem.setTransform(textTransform)


            
    def setOriginPointF(self, pointF):
        """Sets the origin point of the gannFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.originPointF != pointF: 
            self.originPointF = pointF

            self.setPos(self.originPointF)
            
            # Update the gannFan label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setLeg1PointF(self, pointF):
        """Sets the leg1ing point of the gannFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.leg1PointF != pointF:
            self.leg1PointF = pointF

            self.log.debug("GannFanGraphicsItem." +
                           "setLeg1PointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the gannFan label text item positions.
            self.refreshTextItems()
            
            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setLeg2PointF(self, pointF):
        """Sets the leg2ing point of the gannFan.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.leg2PointF != pointF:
            self.leg2PointF = pointF

            self.log.debug("GannFanGraphicsItem." +
                           "setLeg2PointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the gannFan label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Does nothing since we do not normalize points for this class."""

        pass

    def recalculateGannFan(self):
        """Updates the text items that tell about the fann lines on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of angle.
        """

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        # Now recalculate if we have a convertObj to use for scaling
        # conversion calculation.
        if self.convertObj != None:
        
            # Get the origin point in scene, scaled, and local coordinates.
            sceneOriginPointF = self.originPointF
            scaledOriginPointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.originPointF)
            localOriginPointF = QPointF(0.0, 0.0)
    
            # Get the leg1 point in scene, scaled, and local coordinates.
            sceneLeg1PointF = self.leg1PointF
            scaledLeg1PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg1PointF)
            localLeg1PointF = self.leg1PointF - self.originPointF
            
            # Get the leg2 point in scene, scaled, and local coordinates.
            sceneLeg2PointF = self.leg2PointF
            scaledLeg2PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg2PointF)
            localLeg2PointF = self.leg2PointF - self.originPointF


            # Go through each ratio.
            artifact = self.getArtifact()
            ratios = artifact.getRatios()
            for i in range(len(ratios)):
                ratio = ratios[i]

                if ratio.isEnabled():
                    # Get the x and y position that will be the end point.
                    # This function returns the x and y in scaled
                    # coordinates so we must remember to convert those
                    # values afterwards.
                    (x, y) = \
                        artifact.getXYForRatio(i,
                                               scaledOriginPointF,
                                               scaledLeg1PointF,
                                               scaledLeg2PointF)
            
                    # Map those x and y to local coordinates.
                    sceneEndPointF = \
                        self.convertObj.convertScaledPointToScenePoint(\
                        QPointF(x, y))
                    
                    # Do conversion to local coordinates.
                    localEndPointF = sceneEndPointF - sceneOriginPointF

                    # Enable and make visible.

                    # Get the text item for this point on the scale.
                    textItem = self.ratioTextItems[i]
                    
                    # Make the text visible if it is enabled.
                    textEnabled = artifact.isTextEnabled()
                    textItem.setEnabled(textEnabled)
                    textItem.setVisible(textEnabled)

                    # If text isn't enabled, there's no need to
                    # set the text for it.  Go to the next text item.
                    if textEnabled == False:
                        continue

                    # Text to set in the text item.
                    text = ""

                    # Append the text for the fraction of the ratio.
                    text += "{}".format(ratio.getDescription()) + os.linesep
                    
                    # Append the text for the angle of the line.
                    # Uncomment below to re-add the scaled angle to the text.
                    #scaledAngleDegrees = \
                    #    self.calculateScaledAngleDegrees(self.originPointF,
                    #                                     sceneEndPointF)
                    #text += "{:.4f} deg".format(scaledAngleDegrees) + \
                    #        os.linesep


                    # Set the text to the text item.
                    text = text.rstrip()
                    textItem.setText(text)
                    
                else:
                    # Disable and make not visable.
                    
                    # Get the text item for this point on the scale.
                    textItem = self.ratioTextItems[i]
                    
                    textItem.setVisible(False)
                    textItem.setEnabled(False)
                
                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartGannFanArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartGannFanArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartGannFanArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartGannFanArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        originPointF = self.artifact.getOriginPointF()
        leg1PointF = self.artifact.getLeg1PointF()
        leg2PointF = self.artifact.getLeg2PointF()
        self.setOriginPointF(originPointF)
        self.setLeg1PointF(leg1PointF)
        self.setLeg2PointF(leg2PointF)

        self.gannFanTextFont = self.artifact.getFont()
        
        self.gannFanPen.\
            setColor(self.artifact.getColor())
        self.gannFanTextPen.\
            setColor(self.artifact.getTextColor())
        self.gannFanTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the angles, since the origin, leg1 and leg2
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements may not be valid.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartGannFanArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartGannFanArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setOriginPointF(self.originPointF)
        self.artifact.setLeg1PointF(self.leg1PointF)
        self.artifact.setLeg2PointF(self.leg2PointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def getShapeOfLineSegment(self, startPointF, endPointF):
        """Returns the shape as a QPainterPath of the line segment
        constructed via the two input QPointFs.  The shape is
        constructed by a rectangle around the start and end points.
        The rectangle is tilted based on the angle of the start and
        end points in view-scaled coordinates.  The bar height used is
        whatever is returned by self.gannFanBarHeight.

        Arguments:
        
        startPointF - QPointF representing the start point of the line
                      segment in either scene or local coordinates.
        endPointF   - QPointF representing the end point of the line segment
                      in either scene or local scene coordinates.

        Returns:
        QPainterPath object holding the shape of the rectangle around
        the line segment.  If the start and end points are given in
        local coordinates, then the QPainterPath returned will also be
        in local coordinates, otherwise the QPainterPath returned will
        be in scene coordinates.
        """

        self.log.debug("Entered getShapeOfLineSegment()")
        
        #self.log.debug("startPointF is: ({}, {})".\
        #               format(startPointF.x(),
        #                      startPointF.y()))
        #self.log.debug("endPointF is: ({}, {})".\
        #               format(endPointF.x(),
        #                      endPointF.y()))

        #tempRect = QRectF(startPointF, endPointF)
        #self.log.debug("Bounding rect of the two points beforehand is: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(tempRect.x(),
        #                      tempRect.y(),
        #                      tempRect.width(),
        #                      tempRect.height()))
        
        # Utilize scaling from the scene if it is available.
        scaling = PriceBarChartScaling()
        if self.scene() != None:
            scaling = self.scene().getScaling()
            
        viewScaledStartPoint = \
            QPointF(startPointF.x() * scaling.getViewScalingX(),
                    startPointF.y() * scaling.getViewScalingY())
        viewScaledEndPoint = \
            QPointF(endPointF.x() * scaling.getViewScalingX(),
                    endPointF.y() * scaling.getViewScalingY())

        angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
        angleRad = math.radians(angleDeg)

        #self.log.debug("angleDeg is: {}".format(angleDeg))
        #self.log.debug("angleRad is: {}".format(angleRad))

        shiftX = math.sin(angleRad) * \
                     (0.5 * self.gannFanBarHeight) / \
                     scaling.getViewScalingX()
        
        shiftY = math.cos(angleRad) * \
                     (0.5 * self.gannFanBarHeight) / \
                     scaling.getViewScalingY()
        
        #self.log.debug("shiftX is: {}".format(shiftX))
        #self.log.debug("shiftY is: {}".format(shiftY))

        
        # Create new points.
        p1 = \
            QPointF(startPointF.x() - shiftX,
                    startPointF.y() - shiftY)
        p2 = \
            QPointF(startPointF.x() + shiftX,
                    startPointF.y() + shiftY)
        p3 = \
            QPointF(endPointF.x() - shiftX,
                    endPointF.y() - shiftY)
        p4 = \
            QPointF(endPointF.x() + shiftX,
                    endPointF.y() + shiftY)

        #self.log.debug("p1 is: ({}, {})".format(p1.x(), p1.y()))
        #self.log.debug("p2 is: ({}, {})".format(p2.x(), p2.y()))
        #self.log.debug("p3 is: ({}, {})".format(p3.x(), p3.y()))
        #self.log.debug("p4 is: ({}, {})".format(p4.x(), p4.y()))

        points = [p2, p1, p3, p4, p2]
        polygon = QPolygonF(points)

        painterPath = QPainterPath()
        painterPath.addPolygon(polygon)


        #tempRect = painterPath.boundingRect()
        #self.log.debug("Bounding rect of polygon afterwards is: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(tempRect.x(),
        #                      tempRect.y(),
        #                      tempRect.width(),
        #                      tempRect.height()))
        
        return painterPath

    def calculateTextRotationDegrees(self, startPointF, endPointF):
        """Calculates the number of degrees that a
        QGraphicsSimpleTextItem should be rotated so that it is
        parallel to the line constructed by the 'startPointF' and
        'endPointF' parameters.  ViewScaling is utilized to determine the angle.

        Arguments:
        startPointF - start point of the line segment to align the
                      text's angle with.
        endPointF   - start point of the line segment to align the
                      text's angle with.

        Returns:
        float value holding angle that the text needs to be rotated, in degrees.
        """

        # Return value.
        angleDeg = 0.0
        
        # Determine the number of degrees to rotate the text by,
        # utilizing scaling.
        if self.scene() != None:
            scaling = self.scene().getScaling()

            viewScaledStartPoint = \
                QPointF(startPointF.x() * scaling.getViewScalingX(),
                        startPointF.y() * scaling.getViewScalingY())
            viewScaledEndPoint = \
                QPointF(endPointF.x() * scaling.getViewScalingX(),
                        endPointF.y() * scaling.getViewScalingY())
            
            angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
            self.log.debug("Scaled angleDeg before normalizing and fudge, " +
                           "angleDeg={}".format(angleDeg))
        else:
            # No scaling is available, so just do the unscaled angle.
            angleDeg = QLineF(startPointF, endPointF).angle()
            self.log.debug("Unscaled angleDeg before normalizing and fudge, " +
                           "angleDeg={}".format(angleDeg))
            
        # Normalize the angle so that the text is always upright.
        if 90 <= angleDeg <= 270:
            angleDeg += 180
        angleDeg = Util.toNormalizedAngle(angleDeg)

        self.log.debug("Before fudge, angleDeg={}".format(angleDeg))
        
        # Fudge factor since for some reason the text item doesn't
        # exactly line up with the line.
        fudge = 0.0
        if 0 < angleDeg <= 90:
            self.log.debug("0 to 90")
            removed = 45 - abs(45 - angleDeg)
            fudge = removed * 0.19
            angleDeg -= fudge
        elif 90 < angleDeg <= 180:
            self.log.debug("90 to 180")
            removed = 45 - abs(135 - angleDeg)
            fudge = removed * 0.12
            angleDeg += fudge
        elif 180 < angleDeg <= 270:
            self.log.debug("180 to 270")
            removed = 45 - abs(225 - angleDeg)
            fudge = removed * 0.19
            angleDeg -= fudge
        elif 270 < angleDeg <= 360:
            self.log.debug("270 to 360")
            removed = 45 - abs(315 - angleDeg)
            fudge = removed * 0.12
            angleDeg += fudge
            
        angleDeg = -1.0 * angleDeg
        self.log.debug("angleDeg={}".format(angleDeg))

        return angleDeg
    
    def calculateScaledAngleDegrees(self, startPointF, endPointF):
        """Calculates the number of degrees of angle between
        'startPointF' and 'endPointF'.  This angle is calculated
        utilizing scaling conversion from self.convertObj.

        Arguments:
        startPointF - start point of the line segment, in scene coordinates.
        endPointF   - start point of the line segment, in scene coordinates.

        Returns:
        float value holding the scaled angle, in degrees.
        """

        angleDeg = 0.0

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        if self.convertObj != None:
            startScaledPoint = \
                self.convertObj.convertScenePointToScaledPoint(startPointF)
            endScaledPoint = \
                self.convertObj.convertScenePointToScaledPoint(endPointF)
        
            angleDeg = QLineF(startScaledPoint, endScaledPoint).angle()
        else:
            # Convert object is not set, so don't apply scaling, and
            # just return the angle with unscaled points.
            angleDeg = QLineF(startPointF, endPointF).angle()
            
        return angleDeg
        
    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is origin point.
        
        rv = self.shape().boundingRect()

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem,
        in local item coordinates.
        """

        #self.log.debug("Entered shape().")

        # Return value.
        # Holds the QPainterPath of the whole item (in local coordinates).
        painterPath = QPainterPath()

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")

        if scene != None and self.convertObj != None:
            # Scene exists and we can do scaling conversions.
            # Continue to calculate the painterPath.
            
            # Get the origin point in scene, scaled, and local coordinates.
            sceneOriginPointF = self.originPointF
            scaledOriginPointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.originPointF)
            localOriginPointF = QPointF(0.0, 0.0)

            #self.log.debug("sceneOriginPointF is: ({}, {})".\
            #               format(sceneOriginPointF.x(),
            #                      sceneOriginPointF.y()))
            #self.log.debug("scaledOriginPointF is: ({}, {})".\
            #               format(scaledOriginPointF.x(),
            #                      scaledOriginPointF.y()))
            #self.log.debug("localOriginPointF is: ({}, {})".\
            #               format(localOriginPointF.x(),
            #                      localOriginPointF.y()))
                           
            # Get the leg1 point in scene, scaled, and local coordinates.
            sceneLeg1PointF = self.leg1PointF
            scaledLeg1PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg1PointF)
            localLeg1PointF = QPointF(0.0, 0.0) + \
                              (self.leg1PointF - self.originPointF)
            
            #self.log.debug("sceneLeg1PointF is: ({}, {})".\
            #               format(sceneLeg1PointF.x(),
            #                      sceneLeg1PointF.y()))
            #self.log.debug("scaledLeg1PointF is: ({}, {})".\
            #               format(scaledLeg1PointF.x(),
            #                      scaledLeg1PointF.y()))
            #self.log.debug("localLeg1PointF is: ({}, {})".\
            #               format(localLeg1PointF.x(),
            #                      localLeg1PointF.y()))
            
            # Get the leg2 point in scene, scaled, and local coordinates.
            sceneLeg2PointF = self.leg2PointF
            scaledLeg2PointF = \
                self.convertObj.convertScenePointToScaledPoint(\
                self.leg2PointF)
            localLeg2PointF = QPointF(0.0, 0.0) + \
                              (self.leg2PointF - self.originPointF)
    
            #self.log.debug("sceneLeg2PointF is: ({}, {})".\
            #               format(sceneLeg2PointF.x(),
            #                      sceneLeg2PointF.y()))
            #self.log.debug("scaledLeg2PointF is: ({}, {})".\
            #               format(scaledLeg2PointF.x(),
            #                      scaledLeg2PointF.y()))
            #self.log.debug("localLeg2PointF is: ({}, {})".\
            #               format(localLeg2PointF.x(),
            #                      localLeg2PointF.y()))

            
            #tempRect = painterPath.boundingRect()
            #self.log.debug("Before adding paths, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))
                           
            # Add the path for the shape of the line segment created by
            # points self.originPointF to self.leg1PointF.  
            leg1PainterPath = \
                self.getShapeOfLineSegment(localOriginPointF, localLeg1PointF)
            painterPath.addPath(leg1PainterPath)


            #tempRect = painterPath.boundingRect()
            #self.log.debug("After adding leg1PainterPath, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))
            
            
            # Add the path for the shape of the line segment created by
            # points self.originPointF to self.leg2PointF.
            leg2PainterPath = \
                self.getShapeOfLineSegment(localOriginPointF, localLeg2PointF)
            painterPath.addPath(leg2PainterPath)


            #tempRect = painterPath.boundingRect()
            #self.log.debug("After adding leg2PainterPath, bounding rect of " +
            #               "PainterPath is: " +
            #               "x={}, y={}, w={}, h={}".\
            #               format(tempRect.x(),
            #                      tempRect.y(),
            #                      tempRect.width(),
            #                      tempRect.height()))

            
            # Go through each line of each enabled ratio, getting
            # the shape of the line segment and add that path to
            # 'painterPath'.
            artifact = self.getArtifact()
            ratios = artifact.getRatios()
            for i in range(len(ratios)):
                ratio = ratios[i]
    
                # Only add the path if the ratio is enabled.
                if ratio.isEnabled():
                    # Get the x and y position that will be the end point.
                    # This function returns the x and y in scaled
                    # coordinates so we must remember to convert those
                    # values afterwards.
                    (x, y) = \
                        artifact.getXYForRatio(i,
                                               scaledOriginPointF,
                                               scaledLeg1PointF,
                                               scaledLeg2PointF)

                    #self.log.debug("Ratio point X and Y for index " +
                    #               "{} in scaled coordinates is: ".format(i) +
                    #               "({}, {})".format(x, y))
                    
                    # Map those x and y to local coordinates.
                    sceneEndPointF = \
                        self.convertObj.convertScaledPointToScenePoint(\
                        QPointF(x, y))

                    #self.log.debug("Mapping that point to scene coords is " + 
                    #               "({}, {})".format(sceneEndPointF.x(),
                    #                                 sceneEndPointF.y()))
                
                    # Do conversion to local coordinates.
                    localEndPointF = sceneEndPointF - sceneOriginPointF
    
                    #self.log.debug("Mapping that point to local coords is " + 
                    #               "({}, {})".format(localEndPointF.x(),
                    #                                 localEndPointF.y()))
                
                    # Get the painter path.
                    endPointPainterPath = \
                        self.getShapeOfLineSegment(localOriginPointF,
                                                   localEndPointF)

                    #tempRect = painterPath.boundingRect()
                    #self.log.debug("Path for " +
                    #               "index {} ".format(i) +
                    #               "has bounding rect: " +
                    #               "x={}, y={}, w={}, h={}".\
                    #               format(tempRect.x(),
                    #                      tempRect.y(),
                    #                      tempRect.width(),
                    #                      tempRect.height()))
    
                    # Add the path to 'painterPath'.
                    painterPath.addPath(endPointPainterPath)


                    #tempRect = painterPath.boundingRect()
                    #self.log.debug("After adding path for " +
                    #               "index {}, ".format(i) +
                    #               "bounding rect of " +
                    #               "PainterPath is: " +
                    #               "x={}, y={}, w={}, h={}".\
                    #               format(tempRect.x(),
                    #                      tempRect.y(),
                    #                      tempRect.width(),
                    #                      tempRect.height()))
    
        else:
            # Scene doesn't exist or we can't scaling conversions.
            # No calculations to do since it won't get plotted anyways.
            self.log.debug("Tried to get shape scene isn't set.")
            pass
            

        #self.log.debug("Exiting shape(). " +
        #               "PainterPath being returned has a bounding rect of: " + 
        #               "x={}, y={}, w={}, h={}".\
        #               format(painterPath.boundingRect().x(),
        #                      painterPath.boundingRect().y(),
        #                      painterPath.boundingRect().width(),
        #                      painterPath.boundingRect().height()))

        # The 'painterPath' should now have all the paths for the tilted
        # rectangles that make up the whole item.
        return painterPath

    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.gannFanPen is set
        to what we want for the drawing style.
        """

        #self.log.debug("Entered GannFanGraphicsItem.paint().  " +
        #               "pos is: ({}, {})".\
        #               format(self.pos().x(), self.pos().y()) +
        #               os.linesep +
        #               "self.originPointF == ({}, {})".\
        #               format(self.originPointF.x(), self.originPointF.y()) +
        #               os.linesep +
        #               "self.leg1PointF == ({}, {})".\
        #               format(self.leg1PointF.x(), self.leg1PointF.y()) +
        #               os.linesep +
        #               "self.leg2PointF == ({}, {})".\
        #               format(self.leg2PointF.x(), self.leg2PointF.y()))
        
        if painter.pen() != self.gannFanPen:
            painter.setPen(self.gannFanPen)

        # If the self.convertObj is None, then try to use the scene if the
        # scene isn't None.
        scene = self.scene()
        if self.convertObj == None:
            if scene != None:
                self.log.debug("self.convertObj wasn't set, but self.scene() " +
                               "is not None, so we're going to set " +
                               "self.convertObj to the scene")
                self.convertObj = self.scene()
            else:
                self.log.debug("Both self.convertObj and " + \
                               "self.scene() are None.")
                # No scene, so don't paint anything.
                self.log.debug("There's no scene so we won't paint anything.")
                return

        # Get the origin point in scene, scaled, and local coordinates.
        sceneOriginPointF = self.originPointF
        scaledOriginPointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.originPointF)
        localOriginPointF = QPointF(0.0, 0.0)

        # Get the leg1 point in scene, scaled, and local coordinates.
        sceneLeg1PointF = self.leg1PointF
        scaledLeg1PointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.leg1PointF)
        localLeg1PointF = self.leg1PointF - self.originPointF
        
        # Get the leg2 point in scene, scaled, and local coordinates.
        sceneLeg2PointF = self.leg2PointF
        scaledLeg2PointF = \
            self.convertObj.convertScenePointToScaledPoint(\
            self.leg2PointF)
        localLeg2PointF = self.leg2PointF - self.originPointF

        
        # Always draw the line from origin point to leg1 point.
        painter.drawLine(localOriginPointF, localLeg1PointF)
        
        # Always draw the line from origin point to leg2 point.
        painter.drawLine(localOriginPointF, localLeg2PointF)
        
        # For each ratio that is enabled, draw it as a line
        # segment from the origin point to the end point of that
        # ratio.
        artifact = self.getArtifact()
        ratios = artifact.getRatios()
        for i in range(len(ratios)):
            ratio = ratios[i]

            # Only add the path if the ratio is enabled.
            if ratio.isEnabled():
                # Get the x and y position that will be the end point.
                # This function returns the x and y in scaled
                # coordinates so we must remember to convert those
                # values afterwards.
                (x, y) = \
                    artifact.getXYForRatio(i,
                                           scaledOriginPointF,
                                           scaledLeg1PointF,
                                           scaledLeg2PointF)
        
                # Map those x and y to local coordinates.
                sceneEndPointF = \
                    self.convertObj.convertScaledPointToScenePoint(\
                    QPointF(x, y))

                self.log.debug("ratio[{}] sceneEndPointF    == ({}, {})".\
                               format(i,
                                      sceneEndPointF.x(),
                                      sceneEndPointF.y()))
                self.log.debug("ratio[{}] sceneOriginPointF == ({}, {})".\
                               format(i,
                                      sceneOriginPointF.x(),
                                      sceneOriginPointF.y()))
                
                               
                # Do conversion to local coordinates.
                localEndPointF = sceneEndPointF - sceneOriginPointF

                # Draw the line segment for this ratio.
                painter.drawLine(localOriginPointF, localEndPointF)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.gannFanPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
        self.log.debug("Exiting GannFanGraphicsItem.paint().")

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this GannFanGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        GannFanGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        extendLeg1PointAction = \
            QAction("E&xtend leg1 point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenLeg1PointAction = \
            QAction("Shor&ten leg1 point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        extendLeg2PointAction = \
            QAction("Exte&nd leg2 point to {}-fold".\
                    format(self.extendMultiple), parent)
        shortenLeg2PointAction = \
            QAction("S&horten leg2 point to {}-fold".\
                    format(1.0 / self.extendMultiple), parent)
        
        setOriginOnAstro1Action = \
            QAction("Set origin timestamp on Astro Chart &1", parent)
        setOriginOnAstro2Action = \
            QAction("Set origin timestamp on Astro Chart &2", parent)
        setOriginOnAstro3Action = \
            QAction("Set origin timestamp on Astro Chart &3", parent)
        openOriginInJHoraAction = \
            QAction("Open JHor&a with origin timestamp", parent)
        openOriginInAstrologAction = \
            QAction("Open Astrolog with origin timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        extendLeg1PointAction.triggered.\
            connect(self._handleExtendLeg1PointAction)
        shortenLeg1PointAction.triggered.\
            connect(self._handleShortenLeg1PointAction)
        extendLeg2PointAction.triggered.\
            connect(self._handleExtendLeg2PointAction)
        shortenLeg2PointAction.triggered.\
            connect(self._handleShortenLeg2PointAction)
        setOriginOnAstro1Action.triggered.\
            connect(self._handleSetOriginOnAstro1Action)
        setOriginOnAstro2Action.triggered.\
            connect(self._handleSetOriginOnAstro2Action)
        setOriginOnAstro3Action.triggered.\
            connect(self._handleSetOriginOnAstro3Action)
        openOriginInJHoraAction.triggered.\
            connect(self._handleOpenOriginInJHoraAction)
        openOriginInAstrologAction.triggered.\
            connect(self._handleOpenOriginInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        extendLeg1PointAction.setEnabled(not readOnlyMode)
        shortenLeg1PointAction.setEnabled(not readOnlyMode)
        extendLeg2PointAction.setEnabled(not readOnlyMode)
        shortenLeg2PointAction.setEnabled(not readOnlyMode)
        setOriginOnAstro1Action.setEnabled(True)
        setOriginOnAstro2Action.setEnabled(True)
        setOriginOnAstro3Action.setEnabled(True)
        openOriginInJHoraAction.setEnabled(True)
        openOriginInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addSeparator()
        menu.addAction(extendLeg1PointAction)
        menu.addAction(shortenLeg1PointAction)
        menu.addAction(extendLeg2PointAction)
        menu.addAction(shortenLeg2PointAction)
        menu.addSeparator()
        menu.addAction(setOriginOnAstro1Action)
        menu.addAction(setOriginOnAstro2Action)
        menu.addAction(setOriginOnAstro3Action)
        menu.addAction(openOriginInJHoraAction)
        menu.addAction(openOriginInAstrologAction)

    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartGannFanArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartGannFanArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleExtendLeg1PointAction(self):
        """Updates the QGraphicsItem so that the leg1 point is
        (self.extendMultiple) fold of the current distance away from origin
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg1PointF.x() - self.originPointF.x()
        deltaY = self.leg1PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg1PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg1PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenLeg1PointAction(self):
        """Updates the QGraphicsItem so that the leg1 point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        origin point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg1PointF.x() - self.originPointF.x()
        deltaY = self.leg1PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg1PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg1PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleExtendLeg2PointAction(self):
        """Updates the QGraphicsItem so that the leg2 point is
        (self.extendMultiple) fold of the current distance away from origin
        point.  The artifact is edited too to correspond with this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg2PointF.x() - self.originPointF.x()
        deltaY = self.leg2PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * self.extendMultiple
        offsetY = deltaY * self.extendMultiple

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg2PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg2PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleShortenLeg2PointAction(self):
        """Updates the QGraphicsItem so that the leg2 point is
        (1.0 / self.extendMultiple) fold of the current distance away from
        origin point.  The artifact is edited too to correspond with
        this change.
        """

        # Get the X and Y deltas between the start and end points.
        deltaX = self.leg2PointF.x() - self.originPointF.x()
        deltaY = self.leg2PointF.y() - self.originPointF.y()

        # Calculate the new offsets from the end point.
        offsetX = deltaX * (1.0 / self.extendMultiple)
        offsetY = deltaY * (1.0 / self.extendMultiple)

        # Calculate new end point X and Y values.
        newEndPointX = self.originPointF.x() + offsetX
        newEndPointY = self.originPointF.y() + offsetY

        # Update the QGraphicsItem manually.
        newEndPointF = QPointF(newEndPointX, newEndPointY)
        self.setLeg2PointF(newEndPointF)
        
        # Update the artifact.
        self.artifact.setLeg2PointF(newEndPointF)
        
        # Refresh the item so that the textItem and drawing can be updated.
        self.refreshItem()

        self.prepareGeometryChange()
        
        # Emit that the chart has changed.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetOriginOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the origin the GannFanGraphicsItem.
        """

        self.scene().setAstroChart1(self.originPointF.x())
        
    def _handleSetOriginOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the origin the GannFanGraphicsItem.
        """

        self.scene().setAstroChart2(self.originPointF.x())
        
    def _handleSetOriginOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the origin the GannFanGraphicsItem.
        """

        self.scene().setAstroChart3(self.originPointF.x())
        
    def _handleOpenOriginInJHoraAction(self):
        """Causes the the timestamp of the origin the
        GannFanGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.originPointF.x())
        
    def _handleOpenOriginInAstrologAction(self):
        """Causes the the timestamp of the origin the
        GannFanGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.originPointF.x())
        
        
class VimsottariDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new VimsottariDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.VimsottariDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.vimsottariDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultVimsottariDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.vimsottariDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultVimsottariDasaGraphicsItemTextColor

        # X scaling of the text.
        self.vimsottariDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultVimsottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.vimsottariDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultVimsottariDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartVimsottariDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.vimsottariDasaPenWidth = 0.0
        self.vimsottariDasaPen = QPen()
        self.vimsottariDasaPen.setColor(self.vimsottariDasaGraphicsItemColor)
        self.vimsottariDasaPen.setWidthF(self.vimsottariDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.vimsottariDasaTextFont = QFont("Sans Serif")
        self.vimsottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.vimsottariDasaTextPen = self.dummyItem.pen()
        self.vimsottariDasaTextPen.\
            setColor(self.vimsottariDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.vimsottariDasaTextBrush = self.dummyItem.brush()
        self.vimsottariDasaTextBrush.\
            setColor(self.vimsottariDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.vimsottariDasaTextXScaling, \
                            self.vimsottariDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartVimsottariDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.vimsottariDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.vimsottariDasaTextFont)
            dasaLordTextItem.setPen(self.vimsottariDasaTextPen)
            dasaLordTextItem.setBrush(self.vimsottariDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.vimsottariDasaTextFont)
            timestampTextItem.setPen(self.vimsottariDasaTextPen)
            timestampTextItem.setBrush(self.vimsottariDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          vimsottariDasaGraphicsItemMusicalRatios)
        
        # VimsottariDasaGraphicsItem bar color (QColor).
        self.vimsottariDasaGraphicsItemColor = \
            priceBarChartSettings.vimsottariDasaGraphicsItemBarColor

        # VimsottariDasaGraphicsItem text color (QColor).
        self.vimsottariDasaGraphicsItemTextColor = \
            priceBarChartSettings.vimsottariDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.vimsottariDasaTextXScaling = \
            priceBarChartSettings.\
                vimsottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.vimsottariDasaTextYScaling = \
            priceBarChartSettings.\
                vimsottariDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            vimsottariDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.vimsottariDasaGraphicsItemColor)
        self.artifact.setTextColor(self.vimsottariDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the vimsottariDasa label text item texts.
        if self.scene() != None:
            self.recalculateVimsottariDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateVimsottariDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.vimsottariDasaTextXScaling, \
                                    self.vimsottariDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.vimsottariDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.vimsottariDasaTextFont)
                    textItem.setPen(self.vimsottariDasaTextPen)
                    textItem.setBrush(self.vimsottariDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the vimsottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        self.log.debug("Entered setStartPointF().  pointF == {}".format(pointF))
        
        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the vimsottariDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()
                
        self.log.debug("Exiting setStartPointF().")

    def setEndPointF(self, pointF):
        """Sets the ending point of the vimsottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        self.log.debug("Entered setEndPointF().  pointF == {}".format(pointF))
        
        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("VimsottariDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the vimsottariDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

        self.log.debug("Exiting setEndPointF().")

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of VimsottariDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the vimsottariDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateVimsottariDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartVimsottariDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartVimsottariDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        self.log.debug("self.artifact.getStartPointF() == {}".\
                       format(self.artifact.getStartPointF()))
        self.log.debug("self.artifact.getEndPointF() == {}".\
                       format(self.artifact.getEndPointF()))
        self.log.debug("artifact.getStartPointF() == {}".\
                       format(artifact.getStartPointF()))
        self.log.debug("artifact.getEndPointF() == {}".\
                       format(artifact.getEndPointF()))
                       
        if isinstance(artifact, PriceBarChartVimsottariDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartVimsottariDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        self.log.debug("self.artifact.getStartPointF() == {}".\
                       format(self.artifact.getStartPointF()))
        self.log.debug("self.artifact.getEndPointF() == {}".\
                       format(self.artifact.getEndPointF()))
        self.log.debug("artifact.getStartPointF() == {}".\
                       format(artifact.getStartPointF()))
        self.log.debug("artifact.getEndPointF() == {}".\
                       format(artifact.getEndPointF()))
                       
        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)
        
        self.log.debug("self.artifact.getStartPointF() == {}".\
                       format(self.artifact.getStartPointF()))
        self.log.debug("self.artifact.getEndPointF() == {}".\
                       format(self.artifact.getEndPointF()))
        self.log.debug("artifact.getStartPointF() == {}".\
                       format(artifact.getStartPointF()))
        self.log.debug("artifact.getEndPointF() == {}".\
                       format(artifact.getEndPointF()))
                       
        self.vimsottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.vimsottariDasaPen.\
            setColor(self.artifact.getColor())
        self.vimsottariDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.vimsottariDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartVimsottariDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartVimsottariDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.vimsottariDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered VimsottariDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.vimsottariDasaPen:
            painter.setPen(self.vimsottariDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.vimsottariDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.vimsottariDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this VimsottariDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        VimsottariDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the VimsottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the VimsottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the VimsottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartVimsottariDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartVimsottariDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()

            self.log.debug("Dialog accepted.  Artifact returned is: {}".\
                           format(artifact.toString()))

            self.setArtifact(artifact)
            
            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the VimsottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the VimsottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the VimsottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the VimsottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the VimsottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the VimsottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        VimsottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        VimsottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the VimsottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the VimsottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the VimsottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        VimsottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        VimsottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class AshtottariDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new AshtottariDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.AshtottariDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.ashtottariDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultAshtottariDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.ashtottariDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultAshtottariDasaGraphicsItemTextColor

        # X scaling of the text.
        self.ashtottariDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultAshtottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.ashtottariDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultAshtottariDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartAshtottariDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.ashtottariDasaPenWidth = 0.0
        self.ashtottariDasaPen = QPen()
        self.ashtottariDasaPen.setColor(self.ashtottariDasaGraphicsItemColor)
        self.ashtottariDasaPen.setWidthF(self.ashtottariDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.ashtottariDasaTextFont = QFont("Sans Serif")
        self.ashtottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.ashtottariDasaTextPen = self.dummyItem.pen()
        self.ashtottariDasaTextPen.\
            setColor(self.ashtottariDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.ashtottariDasaTextBrush = self.dummyItem.brush()
        self.ashtottariDasaTextBrush.\
            setColor(self.ashtottariDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.ashtottariDasaTextXScaling, \
                            self.ashtottariDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartAshtottariDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.ashtottariDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.ashtottariDasaTextFont)
            dasaLordTextItem.setPen(self.ashtottariDasaTextPen)
            dasaLordTextItem.setBrush(self.ashtottariDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.ashtottariDasaTextFont)
            timestampTextItem.setPen(self.ashtottariDasaTextPen)
            timestampTextItem.setBrush(self.ashtottariDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          ashtottariDasaGraphicsItemMusicalRatios)
        
        # AshtottariDasaGraphicsItem bar color (QColor).
        self.ashtottariDasaGraphicsItemColor = \
            priceBarChartSettings.ashtottariDasaGraphicsItemBarColor

        # AshtottariDasaGraphicsItem text color (QColor).
        self.ashtottariDasaGraphicsItemTextColor = \
            priceBarChartSettings.ashtottariDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.ashtottariDasaTextXScaling = \
            priceBarChartSettings.\
                ashtottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.ashtottariDasaTextYScaling = \
            priceBarChartSettings.\
                ashtottariDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            ashtottariDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.ashtottariDasaGraphicsItemColor)
        self.artifact.setTextColor(self.ashtottariDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the ashtottariDasa label text item texts.
        if self.scene() != None:
            self.recalculateAshtottariDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateAshtottariDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.ashtottariDasaTextXScaling, \
                                    self.ashtottariDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.ashtottariDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.ashtottariDasaTextFont)
                    textItem.setPen(self.ashtottariDasaTextPen)
                    textItem.setBrush(self.ashtottariDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the ashtottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the ashtottariDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the ashtottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("AshtottariDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the ashtottariDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of AshtottariDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the ashtottariDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateAshtottariDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartAshtottariDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartAshtottariDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartAshtottariDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartAshtottariDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.ashtottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.ashtottariDasaPen.\
            setColor(self.artifact.getColor())
        self.ashtottariDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.ashtottariDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartAshtottariDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartAshtottariDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.ashtottariDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered AshtottariDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.ashtottariDasaPen:
            painter.setPen(self.ashtottariDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.ashtottariDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.ashtottariDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this AshtottariDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        AshtottariDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the AshtottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the AshtottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the AshtottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartAshtottariDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartAshtottariDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the AshtottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the AshtottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the AshtottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the AshtottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the AshtottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the AshtottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        AshtottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        AshtottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the AshtottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the AshtottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the AshtottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        AshtottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        AshtottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class YoginiDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new YoginiDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.YoginiDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.yoginiDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultYoginiDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.yoginiDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultYoginiDasaGraphicsItemTextColor

        # X scaling of the text.
        self.yoginiDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultYoginiDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.yoginiDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultYoginiDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartYoginiDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.yoginiDasaPenWidth = 0.0
        self.yoginiDasaPen = QPen()
        self.yoginiDasaPen.setColor(self.yoginiDasaGraphicsItemColor)
        self.yoginiDasaPen.setWidthF(self.yoginiDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.yoginiDasaTextFont = QFont("Sans Serif")
        self.yoginiDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.yoginiDasaTextPen = self.dummyItem.pen()
        self.yoginiDasaTextPen.\
            setColor(self.yoginiDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.yoginiDasaTextBrush = self.dummyItem.brush()
        self.yoginiDasaTextBrush.\
            setColor(self.yoginiDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.yoginiDasaTextXScaling, \
                            self.yoginiDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartYoginiDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.yoginiDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.yoginiDasaTextFont)
            dasaLordTextItem.setPen(self.yoginiDasaTextPen)
            dasaLordTextItem.setBrush(self.yoginiDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.yoginiDasaTextFont)
            timestampTextItem.setPen(self.yoginiDasaTextPen)
            timestampTextItem.setBrush(self.yoginiDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          yoginiDasaGraphicsItemMusicalRatios)
        
        # YoginiDasaGraphicsItem bar color (QColor).
        self.yoginiDasaGraphicsItemColor = \
            priceBarChartSettings.yoginiDasaGraphicsItemBarColor

        # YoginiDasaGraphicsItem text color (QColor).
        self.yoginiDasaGraphicsItemTextColor = \
            priceBarChartSettings.yoginiDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.yoginiDasaTextXScaling = \
            priceBarChartSettings.\
                yoginiDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.yoginiDasaTextYScaling = \
            priceBarChartSettings.\
                yoginiDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            yoginiDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.yoginiDasaGraphicsItemColor)
        self.artifact.setTextColor(self.yoginiDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the yoginiDasa label text item texts.
        if self.scene() != None:
            self.recalculateYoginiDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateYoginiDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.yoginiDasaTextXScaling, \
                                    self.yoginiDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.yoginiDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.yoginiDasaTextFont)
                    textItem.setPen(self.yoginiDasaTextPen)
                    textItem.setBrush(self.yoginiDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the yoginiDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the yoginiDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the yoginiDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("YoginiDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the yoginiDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of YoginiDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the yoginiDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateYoginiDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartYoginiDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartYoginiDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartYoginiDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartYoginiDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.yoginiDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.yoginiDasaPen.\
            setColor(self.artifact.getColor())
        self.yoginiDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.yoginiDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartYoginiDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartYoginiDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.yoginiDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered YoginiDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.yoginiDasaPen:
            painter.setPen(self.yoginiDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.yoginiDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.yoginiDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this YoginiDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        YoginiDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the YoginiDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the YoginiDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the YoginiDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartYoginiDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartYoginiDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the YoginiDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the YoginiDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the YoginiDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the YoginiDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the YoginiDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the YoginiDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        YoginiDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        YoginiDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the YoginiDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the YoginiDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the YoginiDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        YoginiDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        YoginiDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class DwisaptatiSamaDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new DwisaptatiSamaDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.DwisaptatiSamaDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.dwisaptatiSamaDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultDwisaptatiSamaDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.dwisaptatiSamaDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultDwisaptatiSamaDasaGraphicsItemTextColor

        # X scaling of the text.
        self.dwisaptatiSamaDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultDwisaptatiSamaDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.dwisaptatiSamaDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultDwisaptatiSamaDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartDwisaptatiSamaDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.dwisaptatiSamaDasaPenWidth = 0.0
        self.dwisaptatiSamaDasaPen = QPen()
        self.dwisaptatiSamaDasaPen.setColor(self.dwisaptatiSamaDasaGraphicsItemColor)
        self.dwisaptatiSamaDasaPen.setWidthF(self.dwisaptatiSamaDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.dwisaptatiSamaDasaTextFont = QFont("Sans Serif")
        self.dwisaptatiSamaDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.dwisaptatiSamaDasaTextPen = self.dummyItem.pen()
        self.dwisaptatiSamaDasaTextPen.\
            setColor(self.dwisaptatiSamaDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.dwisaptatiSamaDasaTextBrush = self.dummyItem.brush()
        self.dwisaptatiSamaDasaTextBrush.\
            setColor(self.dwisaptatiSamaDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.dwisaptatiSamaDasaTextXScaling, \
                            self.dwisaptatiSamaDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartDwisaptatiSamaDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.dwisaptatiSamaDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.dwisaptatiSamaDasaTextFont)
            dasaLordTextItem.setPen(self.dwisaptatiSamaDasaTextPen)
            dasaLordTextItem.setBrush(self.dwisaptatiSamaDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.dwisaptatiSamaDasaTextFont)
            timestampTextItem.setPen(self.dwisaptatiSamaDasaTextPen)
            timestampTextItem.setBrush(self.dwisaptatiSamaDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          dwisaptatiSamaDasaGraphicsItemMusicalRatios)
        
        # DwisaptatiSamaDasaGraphicsItem bar color (QColor).
        self.dwisaptatiSamaDasaGraphicsItemColor = \
            priceBarChartSettings.dwisaptatiSamaDasaGraphicsItemBarColor

        # DwisaptatiSamaDasaGraphicsItem text color (QColor).
        self.dwisaptatiSamaDasaGraphicsItemTextColor = \
            priceBarChartSettings.dwisaptatiSamaDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.dwisaptatiSamaDasaTextXScaling = \
            priceBarChartSettings.\
                dwisaptatiSamaDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.dwisaptatiSamaDasaTextYScaling = \
            priceBarChartSettings.\
                dwisaptatiSamaDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            dwisaptatiSamaDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.dwisaptatiSamaDasaGraphicsItemColor)
        self.artifact.setTextColor(self.dwisaptatiSamaDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the dwisaptatiSamaDasa label text item texts.
        if self.scene() != None:
            self.recalculateDwisaptatiSamaDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateDwisaptatiSamaDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.dwisaptatiSamaDasaTextXScaling, \
                                    self.dwisaptatiSamaDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.dwisaptatiSamaDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.dwisaptatiSamaDasaTextFont)
                    textItem.setPen(self.dwisaptatiSamaDasaTextPen)
                    textItem.setBrush(self.dwisaptatiSamaDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the dwisaptatiSamaDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the dwisaptatiSamaDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the dwisaptatiSamaDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("DwisaptatiSamaDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the dwisaptatiSamaDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of DwisaptatiSamaDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the dwisaptatiSamaDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateDwisaptatiSamaDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartDwisaptatiSamaDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartDwisaptatiSamaDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartDwisaptatiSamaDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartDwisaptatiSamaDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.dwisaptatiSamaDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.dwisaptatiSamaDasaPen.\
            setColor(self.artifact.getColor())
        self.dwisaptatiSamaDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.dwisaptatiSamaDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartDwisaptatiSamaDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartDwisaptatiSamaDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.dwisaptatiSamaDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered DwisaptatiSamaDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.dwisaptatiSamaDasaPen:
            painter.setPen(self.dwisaptatiSamaDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.dwisaptatiSamaDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.dwisaptatiSamaDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this DwisaptatiSamaDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        DwisaptatiSamaDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the DwisaptatiSamaDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the DwisaptatiSamaDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the DwisaptatiSamaDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartDwisaptatiSamaDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartDwisaptatiSamaDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the DwisaptatiSamaDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the DwisaptatiSamaDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the DwisaptatiSamaDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the DwisaptatiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the DwisaptatiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the DwisaptatiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        DwisaptatiSamaDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        DwisaptatiSamaDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the DwisaptatiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the DwisaptatiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the DwisaptatiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        DwisaptatiSamaDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        DwisaptatiSamaDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class ShattrimsaSamaDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new ShattrimsaSamaDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.ShattrimsaSamaDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.shattrimsaSamaDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultShattrimsaSamaDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.shattrimsaSamaDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultShattrimsaSamaDasaGraphicsItemTextColor

        # X scaling of the text.
        self.shattrimsaSamaDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultShattrimsaSamaDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.shattrimsaSamaDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultShattrimsaSamaDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartShattrimsaSamaDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.shattrimsaSamaDasaPenWidth = 0.0
        self.shattrimsaSamaDasaPen = QPen()
        self.shattrimsaSamaDasaPen.setColor(self.shattrimsaSamaDasaGraphicsItemColor)
        self.shattrimsaSamaDasaPen.setWidthF(self.shattrimsaSamaDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.shattrimsaSamaDasaTextFont = QFont("Sans Serif")
        self.shattrimsaSamaDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.shattrimsaSamaDasaTextPen = self.dummyItem.pen()
        self.shattrimsaSamaDasaTextPen.\
            setColor(self.shattrimsaSamaDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.shattrimsaSamaDasaTextBrush = self.dummyItem.brush()
        self.shattrimsaSamaDasaTextBrush.\
            setColor(self.shattrimsaSamaDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.shattrimsaSamaDasaTextXScaling, \
                            self.shattrimsaSamaDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartShattrimsaSamaDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.shattrimsaSamaDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.shattrimsaSamaDasaTextFont)
            dasaLordTextItem.setPen(self.shattrimsaSamaDasaTextPen)
            dasaLordTextItem.setBrush(self.shattrimsaSamaDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.shattrimsaSamaDasaTextFont)
            timestampTextItem.setPen(self.shattrimsaSamaDasaTextPen)
            timestampTextItem.setBrush(self.shattrimsaSamaDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          shattrimsaSamaDasaGraphicsItemMusicalRatios)
        
        # ShattrimsaSamaDasaGraphicsItem bar color (QColor).
        self.shattrimsaSamaDasaGraphicsItemColor = \
            priceBarChartSettings.shattrimsaSamaDasaGraphicsItemBarColor

        # ShattrimsaSamaDasaGraphicsItem text color (QColor).
        self.shattrimsaSamaDasaGraphicsItemTextColor = \
            priceBarChartSettings.shattrimsaSamaDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.shattrimsaSamaDasaTextXScaling = \
            priceBarChartSettings.\
                shattrimsaSamaDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.shattrimsaSamaDasaTextYScaling = \
            priceBarChartSettings.\
                shattrimsaSamaDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            shattrimsaSamaDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.shattrimsaSamaDasaGraphicsItemColor)
        self.artifact.setTextColor(self.shattrimsaSamaDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the shattrimsaSamaDasa label text item texts.
        if self.scene() != None:
            self.recalculateShattrimsaSamaDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateShattrimsaSamaDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.shattrimsaSamaDasaTextXScaling, \
                                    self.shattrimsaSamaDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.shattrimsaSamaDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.shattrimsaSamaDasaTextFont)
                    textItem.setPen(self.shattrimsaSamaDasaTextPen)
                    textItem.setBrush(self.shattrimsaSamaDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the shattrimsaSamaDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the shattrimsaSamaDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the shattrimsaSamaDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("ShattrimsaSamaDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the shattrimsaSamaDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of ShattrimsaSamaDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the shattrimsaSamaDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateShattrimsaSamaDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartShattrimsaSamaDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartShattrimsaSamaDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartShattrimsaSamaDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartShattrimsaSamaDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.shattrimsaSamaDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.shattrimsaSamaDasaPen.\
            setColor(self.artifact.getColor())
        self.shattrimsaSamaDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.shattrimsaSamaDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartShattrimsaSamaDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartShattrimsaSamaDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.shattrimsaSamaDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered ShattrimsaSamaDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.shattrimsaSamaDasaPen:
            painter.setPen(self.shattrimsaSamaDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.shattrimsaSamaDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.shattrimsaSamaDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this ShattrimsaSamaDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        ShattrimsaSamaDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the ShattrimsaSamaDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the ShattrimsaSamaDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the ShattrimsaSamaDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartShattrimsaSamaDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartShattrimsaSamaDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the ShattrimsaSamaDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the ShattrimsaSamaDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the ShattrimsaSamaDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the ShattrimsaSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the ShattrimsaSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the ShattrimsaSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        ShattrimsaSamaDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        ShattrimsaSamaDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the ShattrimsaSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the ShattrimsaSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the ShattrimsaSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        ShattrimsaSamaDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        ShattrimsaSamaDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class DwadasottariDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new DwadasottariDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.DwadasottariDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.dwadasottariDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultDwadasottariDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.dwadasottariDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultDwadasottariDasaGraphicsItemTextColor

        # X scaling of the text.
        self.dwadasottariDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultDwadasottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.dwadasottariDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultDwadasottariDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartDwadasottariDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.dwadasottariDasaPenWidth = 0.0
        self.dwadasottariDasaPen = QPen()
        self.dwadasottariDasaPen.setColor(self.dwadasottariDasaGraphicsItemColor)
        self.dwadasottariDasaPen.setWidthF(self.dwadasottariDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.dwadasottariDasaTextFont = QFont("Sans Serif")
        self.dwadasottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.dwadasottariDasaTextPen = self.dummyItem.pen()
        self.dwadasottariDasaTextPen.\
            setColor(self.dwadasottariDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.dwadasottariDasaTextBrush = self.dummyItem.brush()
        self.dwadasottariDasaTextBrush.\
            setColor(self.dwadasottariDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.dwadasottariDasaTextXScaling, \
                            self.dwadasottariDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartDwadasottariDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.dwadasottariDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.dwadasottariDasaTextFont)
            dasaLordTextItem.setPen(self.dwadasottariDasaTextPen)
            dasaLordTextItem.setBrush(self.dwadasottariDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.dwadasottariDasaTextFont)
            timestampTextItem.setPen(self.dwadasottariDasaTextPen)
            timestampTextItem.setBrush(self.dwadasottariDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          dwadasottariDasaGraphicsItemMusicalRatios)
        
        # DwadasottariDasaGraphicsItem bar color (QColor).
        self.dwadasottariDasaGraphicsItemColor = \
            priceBarChartSettings.dwadasottariDasaGraphicsItemBarColor

        # DwadasottariDasaGraphicsItem text color (QColor).
        self.dwadasottariDasaGraphicsItemTextColor = \
            priceBarChartSettings.dwadasottariDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.dwadasottariDasaTextXScaling = \
            priceBarChartSettings.\
                dwadasottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.dwadasottariDasaTextYScaling = \
            priceBarChartSettings.\
                dwadasottariDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            dwadasottariDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.dwadasottariDasaGraphicsItemColor)
        self.artifact.setTextColor(self.dwadasottariDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the dwadasottariDasa label text item texts.
        if self.scene() != None:
            self.recalculateDwadasottariDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateDwadasottariDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.dwadasottariDasaTextXScaling, \
                                    self.dwadasottariDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.dwadasottariDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.dwadasottariDasaTextFont)
                    textItem.setPen(self.dwadasottariDasaTextPen)
                    textItem.setBrush(self.dwadasottariDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the dwadasottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the dwadasottariDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the dwadasottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("DwadasottariDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the dwadasottariDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of DwadasottariDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the dwadasottariDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateDwadasottariDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartDwadasottariDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartDwadasottariDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartDwadasottariDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartDwadasottariDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.dwadasottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.dwadasottariDasaPen.\
            setColor(self.artifact.getColor())
        self.dwadasottariDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.dwadasottariDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartDwadasottariDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartDwadasottariDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.dwadasottariDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered DwadasottariDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.dwadasottariDasaPen:
            painter.setPen(self.dwadasottariDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.dwadasottariDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.dwadasottariDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this DwadasottariDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        DwadasottariDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the DwadasottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the DwadasottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the DwadasottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartDwadasottariDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartDwadasottariDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the DwadasottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the DwadasottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the DwadasottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the DwadasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the DwadasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the DwadasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        DwadasottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        DwadasottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the DwadasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the DwadasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the DwadasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        DwadasottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        DwadasottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class ChaturaseetiSamaDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new ChaturaseetiSamaDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.ChaturaseetiSamaDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.chaturaseetiSamaDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultChaturaseetiSamaDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.chaturaseetiSamaDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultChaturaseetiSamaDasaGraphicsItemTextColor

        # X scaling of the text.
        self.chaturaseetiSamaDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultChaturaseetiSamaDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.chaturaseetiSamaDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultChaturaseetiSamaDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartChaturaseetiSamaDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.chaturaseetiSamaDasaPenWidth = 0.0
        self.chaturaseetiSamaDasaPen = QPen()
        self.chaturaseetiSamaDasaPen.setColor(self.chaturaseetiSamaDasaGraphicsItemColor)
        self.chaturaseetiSamaDasaPen.setWidthF(self.chaturaseetiSamaDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.chaturaseetiSamaDasaTextFont = QFont("Sans Serif")
        self.chaturaseetiSamaDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.chaturaseetiSamaDasaTextPen = self.dummyItem.pen()
        self.chaturaseetiSamaDasaTextPen.\
            setColor(self.chaturaseetiSamaDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.chaturaseetiSamaDasaTextBrush = self.dummyItem.brush()
        self.chaturaseetiSamaDasaTextBrush.\
            setColor(self.chaturaseetiSamaDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.chaturaseetiSamaDasaTextXScaling, \
                            self.chaturaseetiSamaDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartChaturaseetiSamaDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.chaturaseetiSamaDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.chaturaseetiSamaDasaTextFont)
            dasaLordTextItem.setPen(self.chaturaseetiSamaDasaTextPen)
            dasaLordTextItem.setBrush(self.chaturaseetiSamaDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.chaturaseetiSamaDasaTextFont)
            timestampTextItem.setPen(self.chaturaseetiSamaDasaTextPen)
            timestampTextItem.setBrush(self.chaturaseetiSamaDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          chaturaseetiSamaDasaGraphicsItemMusicalRatios)
        
        # ChaturaseetiSamaDasaGraphicsItem bar color (QColor).
        self.chaturaseetiSamaDasaGraphicsItemColor = \
            priceBarChartSettings.chaturaseetiSamaDasaGraphicsItemBarColor

        # ChaturaseetiSamaDasaGraphicsItem text color (QColor).
        self.chaturaseetiSamaDasaGraphicsItemTextColor = \
            priceBarChartSettings.chaturaseetiSamaDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.chaturaseetiSamaDasaTextXScaling = \
            priceBarChartSettings.\
                chaturaseetiSamaDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.chaturaseetiSamaDasaTextYScaling = \
            priceBarChartSettings.\
                chaturaseetiSamaDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            chaturaseetiSamaDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.chaturaseetiSamaDasaGraphicsItemColor)
        self.artifact.setTextColor(self.chaturaseetiSamaDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the chaturaseetiSamaDasa label text item texts.
        if self.scene() != None:
            self.recalculateChaturaseetiSamaDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateChaturaseetiSamaDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.chaturaseetiSamaDasaTextXScaling, \
                                    self.chaturaseetiSamaDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.chaturaseetiSamaDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.chaturaseetiSamaDasaTextFont)
                    textItem.setPen(self.chaturaseetiSamaDasaTextPen)
                    textItem.setBrush(self.chaturaseetiSamaDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the chaturaseetiSamaDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the chaturaseetiSamaDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the chaturaseetiSamaDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("ChaturaseetiSamaDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the chaturaseetiSamaDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of ChaturaseetiSamaDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the chaturaseetiSamaDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateChaturaseetiSamaDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartChaturaseetiSamaDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartChaturaseetiSamaDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartChaturaseetiSamaDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartChaturaseetiSamaDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.chaturaseetiSamaDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.chaturaseetiSamaDasaPen.\
            setColor(self.artifact.getColor())
        self.chaturaseetiSamaDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.chaturaseetiSamaDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartChaturaseetiSamaDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartChaturaseetiSamaDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.chaturaseetiSamaDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered ChaturaseetiSamaDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.chaturaseetiSamaDasaPen:
            painter.setPen(self.chaturaseetiSamaDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.chaturaseetiSamaDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.chaturaseetiSamaDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this ChaturaseetiSamaDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        ChaturaseetiSamaDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the ChaturaseetiSamaDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the ChaturaseetiSamaDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the ChaturaseetiSamaDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartChaturaseetiSamaDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartChaturaseetiSamaDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the ChaturaseetiSamaDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the ChaturaseetiSamaDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the ChaturaseetiSamaDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the ChaturaseetiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the ChaturaseetiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the ChaturaseetiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        ChaturaseetiSamaDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        ChaturaseetiSamaDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the ChaturaseetiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the ChaturaseetiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the ChaturaseetiSamaDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        ChaturaseetiSamaDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        ChaturaseetiSamaDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class SataabdikaDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new SataabdikaDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.SataabdikaDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.sataabdikaDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultSataabdikaDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.sataabdikaDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultSataabdikaDasaGraphicsItemTextColor

        # X scaling of the text.
        self.sataabdikaDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultSataabdikaDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.sataabdikaDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultSataabdikaDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartSataabdikaDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.sataabdikaDasaPenWidth = 0.0
        self.sataabdikaDasaPen = QPen()
        self.sataabdikaDasaPen.setColor(self.sataabdikaDasaGraphicsItemColor)
        self.sataabdikaDasaPen.setWidthF(self.sataabdikaDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.sataabdikaDasaTextFont = QFont("Sans Serif")
        self.sataabdikaDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.sataabdikaDasaTextPen = self.dummyItem.pen()
        self.sataabdikaDasaTextPen.\
            setColor(self.sataabdikaDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.sataabdikaDasaTextBrush = self.dummyItem.brush()
        self.sataabdikaDasaTextBrush.\
            setColor(self.sataabdikaDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.sataabdikaDasaTextXScaling, \
                            self.sataabdikaDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartSataabdikaDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.sataabdikaDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.sataabdikaDasaTextFont)
            dasaLordTextItem.setPen(self.sataabdikaDasaTextPen)
            dasaLordTextItem.setBrush(self.sataabdikaDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.sataabdikaDasaTextFont)
            timestampTextItem.setPen(self.sataabdikaDasaTextPen)
            timestampTextItem.setBrush(self.sataabdikaDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          sataabdikaDasaGraphicsItemMusicalRatios)
        
        # SataabdikaDasaGraphicsItem bar color (QColor).
        self.sataabdikaDasaGraphicsItemColor = \
            priceBarChartSettings.sataabdikaDasaGraphicsItemBarColor

        # SataabdikaDasaGraphicsItem text color (QColor).
        self.sataabdikaDasaGraphicsItemTextColor = \
            priceBarChartSettings.sataabdikaDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.sataabdikaDasaTextXScaling = \
            priceBarChartSettings.\
                sataabdikaDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.sataabdikaDasaTextYScaling = \
            priceBarChartSettings.\
                sataabdikaDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            sataabdikaDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.sataabdikaDasaGraphicsItemColor)
        self.artifact.setTextColor(self.sataabdikaDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the sataabdikaDasa label text item texts.
        if self.scene() != None:
            self.recalculateSataabdikaDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateSataabdikaDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.sataabdikaDasaTextXScaling, \
                                    self.sataabdikaDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.sataabdikaDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.sataabdikaDasaTextFont)
                    textItem.setPen(self.sataabdikaDasaTextPen)
                    textItem.setBrush(self.sataabdikaDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the sataabdikaDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the sataabdikaDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the sataabdikaDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("SataabdikaDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the sataabdikaDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of SataabdikaDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the sataabdikaDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateSataabdikaDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartSataabdikaDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartSataabdikaDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartSataabdikaDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartSataabdikaDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.sataabdikaDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.sataabdikaDasaPen.\
            setColor(self.artifact.getColor())
        self.sataabdikaDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.sataabdikaDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartSataabdikaDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartSataabdikaDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.sataabdikaDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered SataabdikaDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.sataabdikaDasaPen:
            painter.setPen(self.sataabdikaDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.sataabdikaDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.sataabdikaDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this SataabdikaDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        SataabdikaDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the SataabdikaDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the SataabdikaDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the SataabdikaDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartSataabdikaDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartSataabdikaDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the SataabdikaDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the SataabdikaDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the SataabdikaDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the SataabdikaDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the SataabdikaDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the SataabdikaDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        SataabdikaDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        SataabdikaDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the SataabdikaDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the SataabdikaDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the SataabdikaDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        SataabdikaDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        SataabdikaDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class ShodasottariDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new ShodasottariDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.ShodasottariDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.shodasottariDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultShodasottariDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.shodasottariDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultShodasottariDasaGraphicsItemTextColor

        # X scaling of the text.
        self.shodasottariDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultShodasottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.shodasottariDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultShodasottariDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartShodasottariDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.shodasottariDasaPenWidth = 0.0
        self.shodasottariDasaPen = QPen()
        self.shodasottariDasaPen.\
            setColor(self.shodasottariDasaGraphicsItemColor)
        self.shodasottariDasaPen.\
            setWidthF(self.shodasottariDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.shodasottariDasaTextFont = QFont("Sans Serif")
        self.shodasottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.shodasottariDasaTextPen = self.dummyItem.pen()
        self.shodasottariDasaTextPen.\
            setColor(self.shodasottariDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.shodasottariDasaTextBrush = self.dummyItem.brush()
        self.shodasottariDasaTextBrush.\
            setColor(self.shodasottariDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.shodasottariDasaTextXScaling, \
                            self.shodasottariDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartShodasottariDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.shodasottariDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.shodasottariDasaTextFont)
            dasaLordTextItem.setPen(self.shodasottariDasaTextPen)
            dasaLordTextItem.setBrush(self.shodasottariDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.shodasottariDasaTextFont)
            timestampTextItem.setPen(self.shodasottariDasaTextPen)
            timestampTextItem.setBrush(self.shodasottariDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          shodasottariDasaGraphicsItemMusicalRatios)
        
        # ShodasottariDasaGraphicsItem bar color (QColor).
        self.shodasottariDasaGraphicsItemColor = \
            priceBarChartSettings.shodasottariDasaGraphicsItemBarColor

        # ShodasottariDasaGraphicsItem text color (QColor).
        self.shodasottariDasaGraphicsItemTextColor = \
            priceBarChartSettings.shodasottariDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.shodasottariDasaTextXScaling = \
            priceBarChartSettings.\
                shodasottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.shodasottariDasaTextYScaling = \
            priceBarChartSettings.\
                shodasottariDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            shodasottariDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.shodasottariDasaGraphicsItemColor)
        self.artifact.setTextColor(self.shodasottariDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the shodasottariDasa label text item texts.
        if self.scene() != None:
            self.recalculateShodasottariDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateShodasottariDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.shodasottariDasaTextXScaling, \
                                    self.shodasottariDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.shodasottariDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.shodasottariDasaTextFont)
                    textItem.setPen(self.shodasottariDasaTextPen)
                    textItem.setBrush(self.shodasottariDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the shodasottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the shodasottariDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the shodasottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("ShodasottariDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the shodasottariDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of ShodasottariDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the shodasottariDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateShodasottariDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartShodasottariDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartShodasottariDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartShodasottariDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartShodasottariDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.shodasottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.shodasottariDasaPen.\
            setColor(self.artifact.getColor())
        self.shodasottariDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.shodasottariDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartShodasottariDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartShodasottariDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.shodasottariDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered ShodasottariDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.shodasottariDasaPen:
            painter.setPen(self.shodasottariDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.shodasottariDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.shodasottariDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this ShodasottariDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        ShodasottariDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the ShodasottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the ShodasottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the ShodasottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartShodasottariDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartShodasottariDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.log.debug("Dialog accepted.  Artifact is: {}".\
                           format(artifact.toString()))
            
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the ShodasottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the ShodasottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the ShodasottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the ShodasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the ShodasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the ShodasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        ShodasottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        ShodasottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the ShodasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the ShodasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the ShodasottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        ShodasottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        ShodasottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class PanchottariDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new PanchottariDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.PanchottariDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.panchottariDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultPanchottariDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.panchottariDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultPanchottariDasaGraphicsItemTextColor

        # X scaling of the text.
        self.panchottariDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultPanchottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.panchottariDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultPanchottariDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartPanchottariDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.panchottariDasaPenWidth = 0.0
        self.panchottariDasaPen = QPen()
        self.panchottariDasaPen.setColor(self.panchottariDasaGraphicsItemColor)
        self.panchottariDasaPen.setWidthF(self.panchottariDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.panchottariDasaTextFont = QFont("Sans Serif")
        self.panchottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.panchottariDasaTextPen = self.dummyItem.pen()
        self.panchottariDasaTextPen.\
            setColor(self.panchottariDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.panchottariDasaTextBrush = self.dummyItem.brush()
        self.panchottariDasaTextBrush.\
            setColor(self.panchottariDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.panchottariDasaTextXScaling, \
                            self.panchottariDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartPanchottariDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.panchottariDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.panchottariDasaTextFont)
            dasaLordTextItem.setPen(self.panchottariDasaTextPen)
            dasaLordTextItem.setBrush(self.panchottariDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.panchottariDasaTextFont)
            timestampTextItem.setPen(self.panchottariDasaTextPen)
            timestampTextItem.setBrush(self.panchottariDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          panchottariDasaGraphicsItemMusicalRatios)
        
        # PanchottariDasaGraphicsItem bar color (QColor).
        self.panchottariDasaGraphicsItemColor = \
            priceBarChartSettings.panchottariDasaGraphicsItemBarColor

        # PanchottariDasaGraphicsItem text color (QColor).
        self.panchottariDasaGraphicsItemTextColor = \
            priceBarChartSettings.panchottariDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.panchottariDasaTextXScaling = \
            priceBarChartSettings.\
                panchottariDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.panchottariDasaTextYScaling = \
            priceBarChartSettings.\
                panchottariDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            panchottariDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.panchottariDasaGraphicsItemColor)
        self.artifact.setTextColor(self.panchottariDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the panchottariDasa label text item texts.
        if self.scene() != None:
            self.recalculatePanchottariDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculatePanchottariDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.panchottariDasaTextXScaling, \
                                    self.panchottariDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.panchottariDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.panchottariDasaTextFont)
                    textItem.setPen(self.panchottariDasaTextPen)
                    textItem.setBrush(self.panchottariDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the panchottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the panchottariDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the panchottariDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("PanchottariDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the panchottariDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of PanchottariDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the panchottariDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculatePanchottariDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartPanchottariDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartPanchottariDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartPanchottariDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartPanchottariDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.panchottariDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.panchottariDasaPen.\
            setColor(self.artifact.getColor())
        self.panchottariDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.panchottariDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartPanchottariDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartPanchottariDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.panchottariDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered PanchottariDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.panchottariDasaPen:
            painter.setPen(self.panchottariDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.panchottariDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.panchottariDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this PanchottariDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        PanchottariDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the PanchottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the PanchottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the PanchottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPanchottariDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartPanchottariDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the PanchottariDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the PanchottariDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the PanchottariDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
            
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the PanchottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the PanchottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the PanchottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        PanchottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        PanchottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the PanchottariDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the PanchottariDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the PanchottariDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        PanchottariDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        PanchottariDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        
class ShashtihayaniDasaGraphicsItem(PriceBarChartArtifactGraphicsItem):
    """QGraphicsItem that visualizes a musical scale in the GraphicsView.

    This item uses the origin point (0, 0) in item coordinates as the
    center point height bar, on the start point (left part) of the bar ruler.

    That means when a user creates a new ShashtihayaniDasaGraphicsItem
    the position and points can be consistently set.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = \
            logging.getLogger(\
            "pricebarchart.ShashtihayaniDasaGraphicsItem")
        
        self.log.debug("Entered __init__().")

        ############################################################
        # Set default values for preferences/settings.

        # Color of the graphicsitem bar.
        self.shashtihayaniDasaGraphicsItemColor = \
            PriceBarChartSettings.\
                defaultShashtihayaniDasaGraphicsItemBarColor

        # Color of the text that is associated with the graphicsitem.
        self.shashtihayaniDasaGraphicsItemTextColor = \
            PriceBarChartSettings.\
                defaultShashtihayaniDasaGraphicsItemTextColor

        # X scaling of the text.
        self.shashtihayaniDasaTextXScaling = \
            PriceBarChartSettings.\
                defaultShashtihayaniDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.shashtihayaniDasaTextYScaling = \
            PriceBarChartSettings.\
                defaultShashtihayaniDasaGraphicsItemTextYScaling 

        ############################################################

        # Internal storage object, used for loading/saving (serialization).
        self.artifact = PriceBarChartShashtihayaniDasaArtifact()

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.shashtihayaniDasaPenWidth = 0.0
        self.shashtihayaniDasaPen = QPen()
        self.shashtihayaniDasaPen.setColor(self.shashtihayaniDasaGraphicsItemColor)
        self.shashtihayaniDasaPen.setWidthF(self.shashtihayaniDasaPenWidth)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

        # Dummy item.
        self.dummyItem = QGraphicsSimpleTextItem("", self)
        
        # Set the font of the text.
        self.shashtihayaniDasaTextFont = QFont("Sans Serif")
        self.shashtihayaniDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())

        # Set the pen color of the text.
        self.shashtihayaniDasaTextPen = self.dummyItem.pen()
        self.shashtihayaniDasaTextPen.\
            setColor(self.shashtihayaniDasaGraphicsItemTextColor)

        # Set the brush color of the text.
        self.shashtihayaniDasaTextBrush = self.dummyItem.brush()
        self.shashtihayaniDasaTextBrush.\
            setColor(self.shashtihayaniDasaGraphicsItemTextColor)

        # Degrees of text rotation.
        self.rotationDegrees = 90.0
        
        # Size scaling for the text.
        textTransform = QTransform()
        textTransform.scale(self.shashtihayaniDasaTextXScaling, \
                            self.shashtihayaniDasaTextYScaling)
        textTransform.rotate(self.rotationDegrees)
        
        # Below is a 2-dimensional list of (2
        # QGraphicsSimpleTextItems), for each of the MusicalRatios in
        # the PriceBarChartShashtihayaniDasaArtifact.  The 2 texts displayed
        # for each MusicalRatio are:
        #
        # 1) Dasa lord.
        # 2) Timestamp value.
        #
        self.musicalRatioTextItems = []

        # Below is a list of VerticalTickGraphicsItems that correspond
        # to each of the musicalRatios.
        self.verticalTickItems = []
        
        # Initialize to blank and set at the end point.
        for musicalRatio in range(len(self.artifact.getMusicalRatios())):
            verticalTickItem = VerticalTickGraphicsItem(self)
            verticalTickItem.setPos(self.endPointF)
            verticalTickItem.setPen(self.shashtihayaniDasaPen)
            
            dasaLordTextItem = QGraphicsSimpleTextItem("", self)
            dasaLordTextItem.setPos(self.endPointF)
            dasaLordTextItem.setFont(self.shashtihayaniDasaTextFont)
            dasaLordTextItem.setPen(self.shashtihayaniDasaTextPen)
            dasaLordTextItem.setBrush(self.shashtihayaniDasaTextBrush)
            dasaLordTextItem.setTransform(textTransform)
            
            timestampTextItem = QGraphicsSimpleTextItem("", self)
            timestampTextItem.setPos(self.endPointF)
            timestampTextItem.setFont(self.shashtihayaniDasaTextFont)
            timestampTextItem.setPen(self.shashtihayaniDasaTextPen)
            timestampTextItem.setBrush(self.shashtihayaniDasaTextBrush)
            timestampTextItem.setTransform(textTransform)
            
            self.musicalRatioTextItems.\
                append([dasaLordTextItem, timestampTextItem])

            self.verticalTickItems.append(verticalTickItem)

        # Flag that indicates that vertical dotted lines should be drawn.
        self.drawVerticalDottedLinesFlag = False
        
        # Flags that indicate that the user is dragging either the start
        # or end point of the QGraphicsItem.
        self.draggingStartPointFlag = False
        self.draggingEndPointFlag = False
        self.clickScenePointF = None

    def setDrawVerticalDottedLinesFlag(self, flag):
        """If flag is set to true, then the vertical dotted lines are drawn.
        """

        self.drawVerticalDottedLinesFlag = flag
        
        # Need to call this because the bounding box is updated with
        # all the extra vertical lines being drawn.
        self.prepareGeometryChange()
        
    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")

        ########
        
        # List of used musical ratios.
        musicalRatios = \
            copy.deepcopy(priceBarChartSettings.\
                          shashtihayaniDasaGraphicsItemMusicalRatios)
        
        # ShashtihayaniDasaGraphicsItem bar color (QColor).
        self.shashtihayaniDasaGraphicsItemColor = \
            priceBarChartSettings.shashtihayaniDasaGraphicsItemBarColor

        # ShashtihayaniDasaGraphicsItem text color (QColor).
        self.shashtihayaniDasaGraphicsItemTextColor = \
            priceBarChartSettings.shashtihayaniDasaGraphicsItemTextColor
        
        # X scaling of the text.
        self.shashtihayaniDasaTextXScaling = \
            priceBarChartSettings.\
                shashtihayaniDasaGraphicsItemTextXScaling 

        # Y scaling of the text.
        self.shashtihayaniDasaTextYScaling = \
            priceBarChartSettings.\
                shashtihayaniDasaGraphicsItemTextYScaling 

        # textEnabledFlag (bool).
        textEnabledFlag = \
            priceBarChartSettings.\
            shashtihayaniDasaGraphicsItemTextEnabledFlag

        ########

        # Set values in the artifact.

        self.artifact.setMusicalRatios(musicalRatios)
        self.artifact.setColor(self.shashtihayaniDasaGraphicsItemColor)
        self.artifact.setTextColor(self.shashtihayaniDasaGraphicsItemTextColor)
        self.artifact.setTextEnabled(textEnabledFlag)

        self.setArtifact(self.artifact)
        
        self.refreshTextItems()
        
        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings read from app preferences.
        pass
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.refreshTextItems()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        self.log.debug("Entered mousePressEvent()")
        
        # If the item is in read-only mode, simply call the parent
        # implementation of this function.
        if self.getReadOnlyFlag() == True:
            super().mousePressEvent(event)
        else:
            # If the mouse press is within 1/5th of the bar length to the
            # beginning or end points, then the user is trying to adjust
            # the starting or ending points of the bar counter ruler.
            scenePosX = event.scenePos().x()
            self.log.debug("DEBUG: scenePosX={}".format(scenePosX))
            
            startingPointX = self.startPointF.x()
            self.log.debug("DEBUG: startingPointX={}".format(startingPointX))
            endingPointX = self.endPointF.x()
            self.log.debug("DEBUG: endingPointX={}".format(endingPointX))
            
            diff = endingPointX - startingPointX
            self.log.debug("DEBUG: diff={}".format(diff))

            startThreshold = startingPointX + (diff * (1.0 / 5))
            endThreshold = endingPointX - (diff * (1.0 / 5))

            self.log.debug("DEBUG: startThreshold={}".format(startThreshold))
            self.log.debug("DEBUG: endThreshold={}".format(endThreshold))

            if startingPointX <= scenePosX <= startThreshold or \
                   startingPointX >= scenePosX >= startThreshold:
                
                self.draggingStartPointFlag = True
                self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                               format(self.draggingStartPointFlag))
                
            elif endingPointX <= scenePosX <= endThreshold or \
                   endingPointX >= scenePosX >= endThreshold:
                
                self.draggingEndPointFlag = True
                self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                               format(self.draggingEndPointFlag))
            else:
                # The mouse has clicked the middle part of the
                # QGraphicsItem, so pass the event to the parent, because
                # the user wants to either select or drag-move the
                # position of the QGraphicsItem.
                self.log.debug("DEBUG:  Middle part clicked.  " + \
                               "Passing to super().")

                # Save the click position, so that if it is a drag, we
                # can have something to reference from for setting the
                # start and end positions when the user finally
                # releases the mouse button.
                self.clickScenePointF = event.scenePos()
                
                super().mousePressEvent(event)

        self.log.debug("Leaving mousePressEvent()")
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        if event.buttons() & Qt.LeftButton:
            if self.getReadOnlyFlag() == False:
                if self.draggingStartPointFlag == True:
                    self.log.debug("DEBUG: self.draggingStartPointFlag={}".
                                   format(self.draggingStartPointFlag))
                    self.setStartPointF(QPointF(event.scenePos().x(),
                                                self.startPointF.y()))
                    self.prepareGeometryChange()
                elif self.draggingEndPointFlag == True:
                    self.log.debug("DEBUG: self.draggingEndPointFlag={}".
                                   format(self.draggingEndPointFlag))
                    self.setEndPointF(QPointF(event.scenePos().x(),
                                              self.endPointF.y()))
                    self.prepareGeometryChange()
                else:
                    # This means that the user is dragging the whole
                    # ruler.

                    # Do the move.
                    super().mouseMoveEvent(event)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartChanged.emit()
            else:
                super().mouseMoveEvent(event)
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        self.log.debug("Entered mouseReleaseEvent()")

        if self.draggingStartPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " + \
                           "startPoint.")
            
            self.draggingStartPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()
            
            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        elif self.draggingEndPointFlag == True:
            self.log.debug("mouseReleaseEvent() when previously dragging " +
                           "endPoint.")
            
            self.draggingEndPointFlag = False

            # Make sure the starting point is to the left of the
            # ending point.
            #self.normalizeStartAndEnd()

            self.prepareGeometryChange()
            
            self.scene().priceBarChartChanged.emit()
            
        else:
            self.log.debug("mouseReleaseEvent() when NOT previously " + \
                           "dragging an end.")

            if self.getReadOnlyFlag() == False:
                # Update the start and end positions.
                self.log.debug("DEBUG: scenePos: x={}, y={}".
                               format(event.scenePos().x(),
                                      event.scenePos().y()))

                # Calculate the difference between where the user released
                # the button and where the user first clicked the item.
                delta = event.scenePos() - self.clickScenePointF

                self.log.debug("DEBUG: delta: x={}, y={}".
                               format(delta.x(), delta.y()))

                # If the delta is not zero, then update the start and
                # end points by calling setPos() on the new calculated
                # position.
                if delta.x() != 0.0 and delta.y() != 0.0:
                    newPos = self.startPointF + delta
                    self.setPos(newPos)

            super().mouseReleaseEvent(event)

        self.log.debug("Exiting mouseReleaseEvent()")

    def setReadOnlyFlag(self, flag):
        """Overwrites the PriceBarChartArtifactGraphicsItem setReadOnlyFlag()
        function.
        """

        # Call the parent's function so that the flag gets set.
        super().setReadOnlyFlag(flag)

        # Make sure the drag flags are disabled.
        if flag == True:
            self.draggingStartPointFlag = False
            self.draggingEndPointFlag = False

    def refreshTextItems(self):
        """Sets the positions of the text items for the MusicalRatios,
        and updates the text so that they are current.
        """

        # Update the shashtihayaniDasa label text item texts.
        if self.scene() != None:
            self.recalculateShashtihayaniDasa()

            # Traverse the 2-dimensional list and set the position of
            # each of the text items.
            artifact = self.getArtifact()
            for i in range(len(artifact.getMusicalRatios())):
                # Get the MusicalRatio that corresponds to this index.
                musicalRatio = artifact.getMusicalRatios()[i]

                # Here we always set the positions of everything.  If
                # the musicalRatio not enabled, then the corresponding
                # graphics items would have gotten disabled in the
                # self.recalculateShashtihayaniDasa() call above.
                
                # Get the x and y position that will be the new
                # position of the text item.
                (x, y) = artifact.getXYForMusicalRatio(i)

                # Map those x and y to local coordinates.
                pointF = self.mapFromScene(QPointF(x, y))

                # Create the text transform to use.
                textTransform = QTransform()
                textTransform.scale(self.shashtihayaniDasaTextXScaling, \
                                    self.shashtihayaniDasaTextYScaling)
                textTransform.rotate(self.rotationDegrees)
                
                # Get the text items for this point on the scale.
                listOfTextItems = self.musicalRatioTextItems[i]

                # For each text item for that point on the scale,
                # set the position.
                for j in range(len(listOfTextItems)):
                    textItem = listOfTextItems[j]
                    # The position set is not exactly at (x, y), but
                    # instead at a slight offset so that it is more
                    # visible.
                    if j == 0:
                        # Dasa lord.
                        offsetX = (textItem.boundingRect().height() * \
                                   self.shashtihayaniDasaTextXScaling)
                        textItem.setPos(QPointF(pointF.x() + offsetX,
                                                pointF.y()))
                    elif j == 1:
                        # Timestamp.
                        textItem.setPos(pointF)
                        
                    textItem.setFont(self.shashtihayaniDasaTextFont)
                    textItem.setPen(self.shashtihayaniDasaTextPen)
                    textItem.setBrush(self.shashtihayaniDasaTextBrush)
                    textItem.setTransform(textTransform)
                    
                # Also set the position of the vertical tick line.
                barHeight = artifact.getBarHeight()
                self.verticalTickItems[i].setBarHeight(barHeight)
                self.verticalTickItems[i].setPos(pointF)
                    
            # Call update on this item since positions and child items
            # were updated.
            self.prepareGeometryChange()

    def setStartPointF(self, pointF):
        """Sets the starting point of the shashtihayaniDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.startPointF != pointF: 
            self.startPointF = pointF

            self.setPos(self.startPointF)
            
            # Update the shashtihayaniDasa label text item positions.
            self.refreshTextItems()            

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def setEndPointF(self, pointF):
        """Sets the ending point of the shashtihayaniDasa.  The value passed in
        is the mouse location in scene coordinates.  
        """

        if self.endPointF != pointF:
            self.endPointF = pointF

            self.log.debug("ShashtihayaniDasaGraphicsItem." +
                           "setEndPointF(QPointF({}, {}))".\
                           format(pointF.x(), pointF.y()))
            
            # Update the shashtihayaniDasa label text item positions.
            self.refreshTextItems()

            # Call update on this item since positions and child items
            # were updated.
            if self.scene() != None:
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Sets the starting point X location to be less than the ending
        point X location.
        """

        #if self.startPointF.x() > self.endPointF.x():
        #    self.log.debug("Normalization of ShashtihayaniDasaGraphicsItem " +
        #                   "required.")
        #    
        #    # Swap the points.
        #    temp = self.startPointF
        #    self.startPointF = self.endPointF
        #    self.endPointF = temp
        #
        #    super().setPos(self.startPointF)
        #    
        #    # Update the shashtihayaniDasa label text item positions.
        #    self.refreshTextItems()
        pass

    def recalculateShashtihayaniDasa(self):
        """Updates the text items that represent the ticks on the
        modal scale.  These texts will have accurate values for where
        the notes are in terms of price and time.

        In this process, it also sets the internal variables such that
        a call to self.getArtifact().getXYForMusicalRatio(index) can
        be made and a value returned that is accurate.
        """

        scene = self.scene()

        if scene != None:
            artifact = self.getArtifact()
            musicalRatios = artifact.getMusicalRatios()
            for i in range(len(musicalRatios)):
                musicalRatio = musicalRatios[i]

                if musicalRatio.isEnabled():
                    # Enable and make visible.

                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For the text items for that point on the scale,
                    # set the text.  
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]

                        # Make the text visible if it is enabled.
                        textEnabled = artifact.isTextEnabled()
                        textItem.setEnabled(textEnabled)
                        textItem.setVisible(textEnabled)

                        # If text isn't enabled, there's no need to
                        # set the text for it.  Go to the next text item.
                        if textEnabled == False:
                            continue
                    
                        if j == 0:
                            # Dasa lord text.
                            textItem.setText(musicalRatio.getDescription())
                            
                        elif j == 1:
                            # Timestamp text.

                            # For this particular graphics item, we'll not have
                            # a timestamp text.
                            textItem.setEnabled(False)
                            textItem.setVisible(False)
                            continue
                        
                            # Get the x location and then convert to a datetime.
                            #(x, y) = artifact.getXYForMusicalRatio(i)
                            #timestamp = \
                            #    self.scene().sceneXPosToDatetime(x)
                            #timestampText = \
                            #    Ephemeris.datetimeToDayStr(timestamp)
                            #textItem.setText(timestampText)

                    # Also enable and set the vertical tick line.
                    self.verticalTickItems[i].setVisible(True)
                    self.verticalTickItems[i].setEnabled(True)
                            
                else:
                    # Disable and make not visable.
                    
                    # Get the text items for this point on the scale.
                    listOfTextItems = self.musicalRatioTextItems[i]
                    
                    # For each text item for that point on the scale,
                    # set as disabled and not visible.
                    for j in range(len(listOfTextItems)):
                        textItem = listOfTextItems[j]
                        textItem.setVisible(False)
                        textItem.setEnabled(False)

                    # Also disable the vertical tick line.
                    self.verticalTickItems[i].setVisible(False)
                    self.verticalTickItems[i].setEnabled(False)
                    

                        
    def setArtifact(self, artifact):
        """Loads a given PriceBarChartShashtihayaniDasaArtifact object's data
        into this QGraphicsItem.

        Arguments:
        artifact - PriceBarChartShashtihayaniDasaArtifact object with information
                   about this TextGraphisItem
        """

        self.log.debug("Entering setArtifact()")

        if isinstance(artifact, PriceBarChartShashtihayaniDasaArtifact):
            self.artifact = artifact
        else:
            raise TypeError("Expected artifact type: " + \
                            "PriceBarChartShashtihayaniDasaArtifact")

        # Extract and set the internals according to the info 
        # in this artifact object.

        # Grab the points from the artifact so that the values don't
        # change while we set them in this item.
        startPointF = self.artifact.getStartPointF()
        endPointF = self.artifact.getEndPointF()
        self.setPos(startPointF)
        self.setStartPointF(startPointF)
        self.setEndPointF(endPointF)

        self.shashtihayaniDasaTextFont.\
            setPointSizeF(self.artifact.getFontSize())
        self.shashtihayaniDasaPen.\
            setColor(self.artifact.getColor())
        self.shashtihayaniDasaTextPen.\
            setColor(self.artifact.getTextColor())
        self.shashtihayaniDasaTextBrush.\
            setColor(self.artifact.getTextColor())

        
        # Need to recalculate the time measurement, since the start and end
        # points have changed.  Note, if no scene has been set for the
        # QGraphicsView, then the measurements will be zero.
        self.refreshTextItems()

        self.log.debug("Exiting setArtifact()")

    def getArtifact(self):
        """Returns a PriceBarChartShashtihayaniDasaArtifact for this
        QGraphicsItem so that it may be pickled.
        """
        
        # Update the internal self.priceBarChartShashtihayaniDasaArtifact 
        # to be current, then return it.

        self.artifact.setPos(self.pos())
        self.artifact.setStartPointF(self.startPointF)
        self.artifact.setEndPointF(self.endPointF)
        
        # Everything else gets modified only by the edit dialog.
        
        return self.artifact

    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the center of 
        # the vertical bar that is at the left portion of this widget,
        # and represented in scene coordinates as the self.startPointF 
        # location.
        
        # The QRectF returned is relative to this (0, 0) point.
        barHeight = \
            self.getArtifact().getBarHeight()
        
        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta

        xValues = []
        xValues.append(xTopLeft)
        xValues.append(xBottomLeft)
        xValues.append(xTopRight)
        xValues.append(xBottomRight)

        yValues = []
        yValues.append(yTopLeft)
        yValues.append(yBottomLeft)
        yValues.append(yTopRight)
        yValues.append(yBottomRight)

        if self.isSelected():
            # Get the highest high, and lowest low PriceBar in local
            # coordinates.
            highestPriceBar = self.scene().getHighestPriceBar()
            if highestPriceBar != None:
                highestPrice = highestPriceBar.high
                highestPriceBarY = self.scene().priceToSceneYPos(highestPrice)
                localHighY = \
                    self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                yValues.append(localHighY)

            lowestPriceBar = self.scene().getLowestPriceBar()
            if lowestPriceBar != None:
                lowestPrice = lowestPriceBar.low
                lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                localLowY = \
                    self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                yValues.append(localLowY)
        
        xValues.sort()
        yValues.sort()
        
        # Find the smallest x and y.
        smallestX = xValues[0]
        smallestY = yValues[0]
        
        # Find the largest x and y.
        largestX = xValues[-1]
        largestY = yValues[-1]
            
        rv = QRectF(QPointF(smallestX, smallestY),
                    QPointF(largestX, largestY))

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        barHeight = \
            self.getArtifact().getBarHeight()
        
        # The QRectF returned is relative to this (0, 0) point.

        xTopLeft = 0.0
        yTopLeft = 1.0 * (barHeight * 0.5)
        topLeft = QPointF(xTopLeft, yTopLeft)
        
        xBottomLeft = 0.0
        yBottomLeft = -1.0 * (barHeight * 0.5)
        bottomLeft = QPointF(xBottomLeft, yBottomLeft)
        
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        
        xTopRight = 0.0 + xDelta
        yTopRight = (1.0 * (barHeight * 0.5)) + yDelta
        topRight = QPointF(xTopRight, yTopRight)
        
        xBottomRight = 0.0 + xDelta
        yBottomRight = (-1.0 * (barHeight * 0.5)) + yDelta
        bottomRight = QPointF(xBottomRight, yBottomRight)

        rectWithoutText = QRectF(topLeft, bottomRight)

        painterPath = QPainterPath()
        painterPath.addRect(rectWithoutText)
        
        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that
        self.shashtihayaniDasaPen is set to what we want for the drawing
        style.
        """

        self.log.debug("Entered ShashtihayaniDasaGraphicsItem.paint().  " +
                       "pos is: ({}, {})".format(self.pos().x(),
                                                 self.pos().y()))
                       
        if painter.pen() != self.shashtihayaniDasaPen:
            painter.setPen(self.shashtihayaniDasaPen)

        artifact = self.getArtifact()
        barHeight = artifact.getBarHeight()

        # Keep track of x and y values.  We use this to draw the
        # dotted lines later.
        xValues = []
        yValues = []
        
        # Draw the left vertical bar part.
        x1 = 0.0
        y1 = 1.0 * (barHeight * 0.5)
        x2 = 0.0
        y2 = -1.0 * (barHeight * 0.5)
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the right vertical bar part.
        xDelta = self.endPointF.x() - self.startPointF.x()
        yDelta = self.endPointF.y() - self.startPointF.y()
        x1 = 0.0 + xDelta
        y1 = (1.0 * (barHeight * 0.5)) + yDelta
        x2 = 0.0 + xDelta
        y2 = (-1.0 * (barHeight * 0.5)) + yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw the middle line.
        x1 = 0.0
        y1 = 0.0
        x2 = xDelta
        y2 = yDelta
        painter.drawLine(QLineF(x1, y1, x2, y2))

        xValues.append(x1)
        xValues.append(x2)
        yValues.append(y1)
        yValues.append(y2)
        
        # Draw vertical dotted lines at each enabled musicalRatio if
        # the flag is set to do so, or if it is selected.
        if self.drawVerticalDottedLinesFlag == True or \
           option.state & QStyle.State_Selected:

            if self.scene() != None:
                pad = self.shashtihayaniDasaPen.widthF() * 0.5;
                penWidth = 0.0
                fgcolor = option.palette.windowText().color()
                # Ensure good contrast against fgcolor.
                r = 255
                g = 255
                b = 255
                if fgcolor.red() > 127:
                    r = 0
                if fgcolor.green() > 127:
                    g = 0
                if fgcolor.blue() > 127:
                    b = 0
                bgcolor = QColor(r, g, b)
    
                # Get the highest high, and lowest low PriceBar in local
                # coordinates.
                highestPriceBar = self.scene().getHighestPriceBar()
                if highestPriceBar != None:
                    highestPrice = highestPriceBar.high
                    highestPriceBarY = \
                        self.scene().priceToSceneYPos(highestPrice)
                    localHighY = \
                        self.mapFromScene(QPointF(0.0, highestPriceBarY)).y()
                    yValues.append(localHighY)
                
                lowestPriceBar = self.scene().getLowestPriceBar()
                if lowestPriceBar != None:
                    lowestPrice = lowestPriceBar.low
                    lowestPriceBarY = self.scene().priceToSceneYPos(lowestPrice)
                    localLowY = \
                        self.mapFromScene(QPointF(0.0, lowestPriceBarY)).y()
                    yValues.append(localLowY)

                # We have all y values now, so sort them to get the
                # low and high.
                yValues.sort()
                smallestY = yValues[0]
                largestY = yValues[-1]
        
                for verticalTickItem in self.verticalTickItems:
                    if verticalTickItem.isEnabled() and \
                       verticalTickItem.isVisible():
                    
                        localPosX = verticalTickItem.pos().x()

                        startPoint = QPointF(localPosX, largestY)
                        endPoint = QPointF(localPosX, smallestY)
                        
                        painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)
                
                        painter.setPen(QPen(option.palette.windowText(), 0,
                                            Qt.DashLine))
                        painter.setBrush(Qt.NoBrush)
                        painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the start point.
                startPoint = QPointF(0.0, largestY)
                endPoint = QPointF(0.0, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

                # Draw the vertical line for the end point.
                startPoint = QPointF(0.0 + xDelta, largestY)
                endPoint = QPointF(0.0 + xDelta, smallestY)
                
                painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)
                
                painter.setPen(QPen(option.palette.windowText(), 0,
                                    Qt.DashLine))
                painter.setBrush(Qt.NoBrush)
                painter.drawLine(startPoint, endPoint)

        # Draw a dashed-line surrounding the item if it is selected.
        if option.state & QStyle.State_Selected:
            pad = self.shashtihayaniDasaPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this ShashtihayaniDasaGraphicsItem.  Actions that
        are triggered from this menu run various methods in the
        ShashtihayaniDasaGraphicsItem to handle the desired functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
                       readonly actions.
        """

        menu.setTitle(self.artifact.getInternalName())
        
        # These are the QActions that are in the menu.
        parent = menu
        selectAction = QAction("&Select", parent)
        unselectAction = QAction("&Unselect", parent)
        removeAction = QAction("&Remove", parent)
        infoAction = QAction("&Info", parent)
        editAction = QAction("&Edit", parent)
        rotateDownAction = QAction("Rotate Down", parent)
        rotateUpAction = QAction("Rotate Up", parent)
        reverseAction = QAction("Reverse", parent)
        
        setStartOnAstro1Action = \
            QAction("Set start timestamp on Astro Chart &1", parent)
        setStartOnAstro2Action = \
            QAction("Set start timestamp on Astro Chart &2", parent)
        setStartOnAstro3Action = \
            QAction("Set start timestamp on Astro Chart &3", parent)
        openStartInJHoraAction = \
            QAction("Open JHor&a with start timestamp", parent)
        openStartInAstrologAction = \
            QAction("Open As&trolog with start timestamp", parent)
        
        setEndOnAstro1Action = \
            QAction("Set end timestamp on Astro Chart 1", parent)
        setEndOnAstro2Action = \
            QAction("Set end timestamp on Astro Chart 2", parent)
        setEndOnAstro3Action = \
            QAction("Set end timestamp on Astro Chart 3", parent)
        openEndInJHoraAction = \
            QAction("Open JHora with end timestamp", parent)
        openEndInAstrologAction = \
            QAction("Open Astrolog with end timestamp", parent)
        
        selectAction.triggered.\
            connect(self._handleSelectAction)
        unselectAction.triggered.\
            connect(self._handleUnselectAction)
        removeAction.triggered.\
            connect(self._handleRemoveAction)
        infoAction.triggered.\
            connect(self._handleInfoAction)
        editAction.triggered.\
            connect(self._handleEditAction)
        rotateDownAction.triggered.\
            connect(self._handleRotateDownAction)
        rotateUpAction.triggered.\
            connect(self._handleRotateUpAction)
        reverseAction.triggered.\
            connect(self._handleReverseAction)
        setStartOnAstro1Action.triggered.\
            connect(self._handleSetStartOnAstro1Action)
        setStartOnAstro2Action.triggered.\
            connect(self._handleSetStartOnAstro2Action)
        setStartOnAstro3Action.triggered.\
            connect(self._handleSetStartOnAstro3Action)
        openStartInJHoraAction.triggered.\
            connect(self._handleOpenStartInJHoraAction)
        openStartInAstrologAction.triggered.\
            connect(self._handleOpenStartInAstrologAction)
        setEndOnAstro1Action.triggered.\
            connect(self._handleSetEndOnAstro1Action)
        setEndOnAstro2Action.triggered.\
            connect(self._handleSetEndOnAstro2Action)
        setEndOnAstro3Action.triggered.\
            connect(self._handleSetEndOnAstro3Action)
        openEndInJHoraAction.triggered.\
            connect(self._handleOpenEndInJHoraAction)
        openEndInAstrologAction.triggered.\
            connect(self._handleOpenEndInAstrologAction)
        
        # Enable or disable actions.
        selectAction.setEnabled(True)
        unselectAction.setEnabled(True)
        removeAction.setEnabled(not readOnlyMode)
        infoAction.setEnabled(True)
        editAction.setEnabled(not readOnlyMode)
        rotateDownAction.setEnabled(not readOnlyMode)
        rotateUpAction.setEnabled(not readOnlyMode)
        reverseAction.setEnabled(not readOnlyMode)
        setStartOnAstro1Action.setEnabled(True)
        setStartOnAstro2Action.setEnabled(True)
        setStartOnAstro3Action.setEnabled(True)
        openStartInJHoraAction.setEnabled(True)
        openStartInAstrologAction.setEnabled(True)
        setEndOnAstro1Action.setEnabled(True)
        setEndOnAstro2Action.setEnabled(True)
        setEndOnAstro3Action.setEnabled(True)
        openEndInJHoraAction.setEnabled(True)
        openEndInAstrologAction.setEnabled(True)

        # Add the QActions to the menu.
        menu.addAction(selectAction)
        menu.addAction(unselectAction)
        menu.addSeparator()
        menu.addAction(removeAction)
        menu.addSeparator()
        menu.addAction(infoAction)
        menu.addAction(editAction)
        menu.addAction(rotateDownAction)
        menu.addAction(rotateUpAction)
        menu.addAction(reverseAction)
        menu.addSeparator()
        menu.addAction(setStartOnAstro1Action)
        menu.addAction(setStartOnAstro2Action)
        menu.addAction(setStartOnAstro3Action)
        menu.addAction(openStartInJHoraAction)
        menu.addAction(openStartInAstrologAction)
        menu.addSeparator()
        menu.addAction(setEndOnAstro1Action)
        menu.addAction(setEndOnAstro2Action)
        menu.addAction(setEndOnAstro3Action)
        menu.addAction(openEndInJHoraAction)
        menu.addAction(openEndInAstrologAction)

    def rotateDown(self):
        """Causes the ShashtihayaniDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        self._handleRotateDownAction()
        
    def rotateUp(self):
        """Causes the ShashtihayaniDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        self._handleRotateUpAction()

    def reverse(self):
        """Causes the ShashtihayaniDasaGraphicsItem to have its musicalRatios
        reversed.
        """

        self._handleReverseAction()
        
    def _handleSelectAction(self):
        """Causes the QGraphicsItem to become selected."""

        self.setSelected(True)
        self.maybePrintTagsToStatusBar()

    def _handleUnselectAction(self):
        """Causes the QGraphicsItem to become unselected."""

        self.setSelected(False)

    def _handleRemoveAction(self):
        """Causes the QGraphicsItem to be removed from the scene."""
        
        scene = self.scene()
        if scene != None:
            scene.removeItem(self)

            # Emit signal to show that an item is removed.
            # This sets the dirty flag.
            scene.priceBarChartArtifactGraphicsItemRemoved.emit(self)
        
    def _handleInfoAction(self):
        """Causes a dialog to be executed to show information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartShashtihayaniDasaArtifactEditDialog(artifact,
                                                           self.scene(),
                                                           readOnlyFlag=True)
        
        # Run the dialog.  We don't care about what is returned
        # because the dialog is read-only.
        rv = dialog.exec_()
        
    def _handleEditAction(self):
        """Causes a dialog to be executed to edit information about
        the QGraphicsItem.
        """

        artifact = self.getArtifact()
        dialog = PriceBarChartShashtihayaniDasaArtifactEditDialog(artifact,
                                                         self.scene(),
                                                         readOnlyFlag=False)
        
        rv = dialog.exec_()
        
        if rv == QDialog.Accepted:
            # If the dialog is accepted then get the new artifact and
            # set it to this PriceBarChartArtifactGraphicsItem, which
            # will cause it to be reloaded in the scene.
            artifact = dialog.getArtifact()
            self.setArtifact(artifact)

            # Flag that a redraw of this QGraphicsItem is required.
            self.prepareGeometryChange()

            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        else:
            # The user canceled so don't change anything.
            pass
        
    def _handleRotateDownAction(self):
        """Causes the ShashtihayaniDasaGraphicsItem to have its musicalRatios
        rotated down (to the right).
        """

        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()

        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
            else:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
                
            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()

            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()
        
    def _handleRotateUpAction(self):
        """Causes the ShashtihayaniDasaGraphicsItem to have its musicalRatios
        rotated up (to the left).
        """
        
        # Get all the musicalRatios in the internally stored artifact.
        musicalRatios = self.getArtifact().getMusicalRatios()
        
        # See how many enabled musicalRatios there are.  
        numEnabledMusicalRatios = 0
        for musicalRatio in musicalRatios:
            if musicalRatio.isEnabled():
                numEnabledMusicalRatios += 1
                
        if len(musicalRatios) > 0 and numEnabledMusicalRatios > 0:

            if self.artifact.isReversed() == False:
                # Put the first musicalRatio in the back.
                firstRatio = musicalRatios.pop(0)
                musicalRatios.append(firstRatio)
        
                # Rotate until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the first musicalRatio in the back.
                    firstRatio = musicalRatios.pop(0)
                    musicalRatios.append(firstRatio)
            else:
                # Put the last musicalRatio in the front.
                lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                musicalRatios.insert(0, lastRatio)
        
                # Rotate down until there is a musicalRatio at the
                # beginning that is enabled.
                while musicalRatios[0].isEnabled() == False:
                    # Put the last musicalRatio in the front.
                    lastRatio = musicalRatios.pop(len(musicalRatios) - 1)
                    musicalRatios.insert(0, lastRatio)
                

            # Overwrite the old list in the internally stored artifact.
            self.artifact.setMusicalRatios(musicalRatios)

            # Refresh everything.
            self.refreshTextItems()
        
            self.prepareGeometryChange()
            
            # Emit that the PriceBarChart has changed so that the
            # dirty flag can be set.
            self.scene().priceBarChartChanged.emit()

    def _handleReverseAction(self):
        """Causes the ShashtihayaniDasaGraphicsItem to have its musicalRatios
        reversed.
        """
        
        # Flip the flag that indicates that the musical ratios are reversed.
        self.artifact.setReversed(not self.artifact.isReversed())
        
        # Refresh everything.
        self.refreshTextItems()
        
        self.prepareGeometryChange()
        
        # Emit that the PriceBarChart has changed so that the
        # dirty flag can be set.
        self.scene().priceBarChartChanged.emit()
        
    def _handleSetStartOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the start the ShashtihayaniDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.startPointF.x())
        
    def _handleSetStartOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the start the ShashtihayaniDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.startPointF.x())
        
    def _handleSetStartOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the start the ShashtihayaniDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.startPointF.x())
        
    def _handleOpenStartInJHoraAction(self):
        """Causes the the timestamp of the start the
        ShashtihayaniDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.startPointF.x())
        
    def _handleOpenStartInAstrologAction(self):
        """Causes the the timestamp of the start the
        ShashtihayaniDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.startPointF.x())
        
    def _handleSetEndOnAstro1Action(self):
        """Causes the astro chart 1 to be set with the timestamp
        of the end the ShashtihayaniDasaGraphicsItem.
        """

        self.scene().setAstroChart1(self.endPointF.x())

    def _handleSetEndOnAstro2Action(self):
        """Causes the astro chart 2 to be set with the timestamp
        of the end the ShashtihayaniDasaGraphicsItem.
        """

        self.scene().setAstroChart2(self.endPointF.x())

    def _handleSetEndOnAstro3Action(self):
        """Causes the astro chart 3 to be set with the timestamp
        of the end the ShashtihayaniDasaGraphicsItem.
        """

        self.scene().setAstroChart3(self.endPointF.x())

    def _handleOpenEndInJHoraAction(self):
        """Causes the the timestamp of the end the
        ShashtihayaniDasaGraphicsItem to be opened in JHora.
        """

        self.scene().openJHora(self.endPointF.x())
        
    def _handleOpenEndInAstrologAction(self):
        """Causes the the timestamp of the end the
        ShashtihayaniDasaGraphicsItem to be opened in Astrolog.
        """

        self.scene().openAstrolog(self.endPointF.x())
        

class TransientDashedLineSegmentGraphicsItem(QGraphicsItem):
    """QGraphicsItem that visualizes a dashed line segment in
    the GraphicsView.  This QGraphicsItem does not have any artifact
    backing it.
    """
    
    def __init__(self, parent=None, scene=None):
        super().__init__(parent, scene)

        # Logger
        self.log = logging.getLogger(\
            "pricebarchart.TransientDashedLineSegmentGraphicsItem")
        
        self.log.debug("Entered __init__().")

        # Width of the line segment, for bounding rect calculation purposes.
        self.lineSegmentGraphicsItemBarWidth = 1
 
        # Color of the item.
        self.lineSegmentGraphicsItemColor = QColor(Qt.gray)

        # Read the QSettings preferences for the various parameters of
        # this price bar.
        self.loadSettingsFromAppPreferences()
        
        # Pen which is used to do the painting of the bar ruler.
        self.lineSegmentPenWidth = 0.0
        self.lineSegmentPen = QPen()
        self.lineSegmentPen.\
            setColor(self.lineSegmentGraphicsItemColor)
        self.lineSegmentPen.\
            setWidthF(self.lineSegmentPenWidth)
        self.lineSegmentPen.setStyle(Qt.DashLine)
        
        # Starting point, in scene coordinates.
        self.startPointF = QPointF(0, 0)

        # Ending point, in scene coordinates.
        self.endPointF = QPointF(0, 0)

    def loadSettingsFromPriceBarChartSettings(self, priceBarChartSettings):
        """Reads some of the parameters/settings of this
        PriceBarGraphicsItem from the given PriceBarChartSettings object.

        Parameters:
        
        priceBarChartSettings - PriceBarChartSettings object from which
                                to pull settings information from.
        """

        self.log.debug("Entered loadSettingsFromPriceBarChartSettings()")
        
        # No settings.

        self.log.debug("Exiting loadSettingsFromPriceBarChartSettings()")
        
    def loadSettingsFromAppPreferences(self):
        """Reads some of the parameters/settings of this
        GraphicsItem from the QSettings object. 
        """

        # No settings.
        
    def setPos(self, pos):
        """Overwrites the QGraphicsItem setPos() function.

        Here we use the new position to re-set the self.startPointF and
        self.endPointF.

        Arguments:
        pos - QPointF holding the new position.
        """
        self.log.debug("Entered setPos()")
        
        super().setPos(pos)

        newScenePos = pos

        posDelta = newScenePos - self.startPointF

        # Update the start and end points accordingly. 
        self.startPointF = self.startPointF + posDelta
        self.endPointF = self.endPointF + posDelta

        if self.scene() != None:
            self.recalculateLineSegment()
            self.prepareGeometryChange()

        self.log.debug("Exiting setPos()")
        
    def mousePressEvent(self, event):
        """Overwrites the QGraphicsItem mousePressEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        super().mousePressEvent(event)
        
    def mouseMoveEvent(self, event):
        """Overwrites the QGraphicsItem mouseMoveEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """

        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Overwrites the QGraphicsItem mouseReleaseEvent() function.

        Arguments:
        event - QGraphicsSceneMouseEvent that triggered this call.
        """
        
        super().mouseReleaseEvent(event)

    def refreshItem(self):
        """Refreshes the item by recalculating and updating the text
        position/rotation.
        """

        self.recalculateLineSegment()
        
        self._updateTextItemPositions()
        
    def setStartPointF(self, pointF):
        """Sets the starting point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.startPointF != newValue: 
            self.startPointF = newValue

            self.setPos(self.startPointF)

            if self.scene() != None:
                self.recalculateLineSegment()
                self.prepareGeometryChange()
                
    def setEndPointF(self, pointF):
        """Sets the ending point of the bar count.  The value passed in
        is the mouse location in scene coordinates.  
        """

        newValue = QPointF(pointF.x(), pointF.y())

        if self.endPointF != newValue:
            self.endPointF = newValue

            if self.scene() != None:
                self.recalculateLineSegment()
                self.prepareGeometryChange()

    def normalizeStartAndEnd(self):
        """Does not do anything since normalization is not applicable
        to this graphics item.
        """

        # Do don't anything.
        pass

    def recalculateLineSegment(self):
        """Recalculates the lineSegment.
        """

        self.prepareGeometryChange()
        
    def boundingRect(self):
        """Returns the bounding rectangle for this graphicsitem."""

        # Coordinate (0, 0) in local coordinates is the startPointF.
        # If the user created the widget with the startPointF to the
        # right of the endPointF, then the startPointF will have a
        # higher X value than endPointF.

        # The QRectF returned is relative to this (0, 0) point.

        rv = self.shape().boundingRect()

        return rv

    def shape(self):
        """Overwrites the QGraphicsItem.shape() function to return a
        more accurate shape for collision detection, hit tests, etc.

        Returns:
        QPainterPath object holding the shape of this QGraphicsItem.
        """

        # Calculate the points that would be the selection box area
        # around the line.

        # Start and end points in local coordinates.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)

        # Utilize scaling from the scene if it is available.
        scaling = PriceBarChartScaling()
        if self.scene() != None:
            scaling = self.scene().getScaling()
            
        viewScaledStartPoint = \
            QPointF(self.startPointF.x() * scaling.getViewScalingX(),
                    self.startPointF.y() * scaling.getViewScalingY())
        viewScaledEndPoint = \
            QPointF(self.endPointF.x() * scaling.getViewScalingX(),
                    self.endPointF.y() * scaling.getViewScalingY())

        # Here we are calculating the angle of the text and the line
        # as the user would see it.  Actual angle is different if we
        # are calculating it from a scene perspective.
        angleDeg = QLineF(viewScaledStartPoint, viewScaledEndPoint).angle()
        angleRad = math.radians(angleDeg)
        
        shiftX = math.sin(angleRad) * \
                     (0.5 * self.lineSegmentGraphicsItemBarWidth) / \
                     scaling.getViewScalingX()
        
        shiftY = math.cos(angleRad) * \
                     (0.5 * self.lineSegmentGraphicsItemBarWidth) / \
                     scaling.getViewScalingY()

        # Create new points.
        p1 = \
            QPointF(localStartPointF.x() - shiftX,
                    localStartPointF.y() - shiftY)
        p2 = \
            QPointF(localStartPointF.x() + shiftX,
                    localStartPointF.y() + shiftY)
        p3 = \
            QPointF(localEndPointF.x() - shiftX,
                    localEndPointF.y() - shiftY)
        p4 = \
            QPointF(localEndPointF.x() + shiftX,
                    localEndPointF.y() + shiftY)

        points = [p2, p1, p3, p4, p2]
        polygon = QPolygonF(points)

        painterPath = QPainterPath()
        painterPath.addPolygon(polygon)

        return painterPath
        
    def paint(self, painter, option, widget):
        """Paints this QGraphicsItem.  Assumes that self.lineSegmentPen is set
        to what we want for the drawing style.
        """

        self.log.debug("LineSegmentGraphicsItem.paint()")
        
        if painter.pen() != self.lineSegmentPen:
            painter.setPen(self.lineSegmentPen)
        
        # Draw the line.
        localStartPointF = self.mapFromScene(self.startPointF)
        localEndPointF = self.mapFromScene(self.endPointF)
        painter.drawLine(QLineF(localStartPointF, localEndPointF))
        
        # Draw the shape if the item is selected.
        if option.state & QStyle.State_Selected:
            pad = self.lineSegmentPen.widthF() * 0.5;
            penWidth = 0.0
            fgcolor = option.palette.windowText().color()
            
            # Ensure good contrast against fgcolor.
            r = 255
            g = 255
            b = 255
            if fgcolor.red() > 127:
                r = 0
            if fgcolor.green() > 127:
                g = 0
            if fgcolor.blue() > 127:
                b = 0
            
            bgcolor = QColor(r, g, b)
            
            painter.setPen(QPen(bgcolor, penWidth, Qt.SolidLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())
            
            painter.setPen(QPen(option.palette.windowText(), 0, Qt.DashLine))
            painter.setBrush(Qt.NoBrush)
            painter.drawPath(self.shape())

    def appendActionsToContextMenu(self, menu, readOnlyMode=False):
        """Modifies the given QMenu object to update the title and add
        actions relevant to this TransientDashedLineSegmentGraphicsItem.
        Actions that are triggered from this menu run various methods in
        the TransientDashedLineSegmentGraphicsItem to handle the desired
        functionality.
        
        Arguments:
        menu - QMenu object to modify.
        readOnlyMode - bool value that indicates the actions are to be
        readonly actions.
        """

        # Do nothing.  
        pass


class PriceBarChartWidget(QWidget):
    """Widget holding the QGraphicsScene and QGraphicsView that displays
    the PriceBar information along with other indicators and analysis
    tools.
    """

    # Signal emitted when the PriceBarChartWidget changes.
    # 
    # Possible changes to the widget that will trigger this include: 
    #   - Any scene change (pricebars, artifacts)
    #   - Any settings change (scaling)
    #   
    # It does NOT include:
    #   - User selecting a pricebar
    #   - User opening a wheel astrology chart from a pricebar
    #   - Creation/Modification/Deletion of a LookbackMultiplePriceBar.
    #
    priceBarChartChanged = QtCore.pyqtSignal()

    # Signal emitted when current timestamp of where the mouse is changes.
    currentTimestampChanged = QtCore.pyqtSignal(datetime.datetime)

    # Signal emitted when a status message should be printed.
    statusMessageUpdate = QtCore.pyqtSignal(str)
    
    # Signal emitted when the user desires to change astro chart 1.
    astroChart1Update = QtCore.pyqtSignal(datetime.datetime)
    
    # Signal emitted when the user desires to change astro chart 2.
    astroChart2Update = QtCore.pyqtSignal(datetime.datetime)
    
    # Signal emitted when the user desires to change astro chart 3.
    astroChart3Update = QtCore.pyqtSignal(datetime.datetime)

    # Signal emitted when the user desires to view a datetime.datetime
    # in JHora.
    jhoraLaunch = QtCore.pyqtSignal(datetime.datetime)
    
    # Signal emitted when the user desires to view a datetime.datetime
    # in Astrolog.
    astrologLaunch = QtCore.pyqtSignal(datetime.datetime)
    
    # Tool modes that this widget can be in.
    ToolMode = {"ReadOnlyPointerTool"      : 0,
                "PointerTool"              : 1,
                "HandTool"                 : 2,
                "ZoomInTool"               : 3,
                "ZoomOutTool"              : 4,
                "BarCountTool"             : 5,
                "TimeMeasurementTool"      : 6,
                "TimeModalScaleTool"       : 7,
                "PriceModalScaleTool"      : 8,
                "TextTool"                 : 9,
                "PriceTimeInfoTool"        : 10,
                "PriceMeasurementTool"     : 11,
                "TimeRetracementTool"      : 12,
                "PriceRetracementTool"     : 13,
                "PriceTimeVectorTool"      : 14,
                "LineSegment1Tool"         : 15,
                "OctaveFanTool"            : 16,
                "FibFanTool"               : 17,
                "GannFanTool"              : 18,
                "VimsottariDasaTool"       : 19,
                "AshtottariDasaTool"       : 20,
                "YoginiDasaTool"           : 21,
                "DwisaptatiSamaDasaTool"   : 22,
                "ShattrimsaSamaDasaTool"   : 23,
                "DwadasottariDasaTool"     : 24,
                "ChaturaseetiSamaDasaTool" : 25,
                "SataabdikaDasaTool"       : 26,
                "ShodasottariDasaTool"     : 27,
                "PanchottariDasaTool"      : 28,
                "ShashtihayaniDasaTool"    : 29,
                "PlanetLongitudeMovementMeasurementTool"    : 30,
                "LineSegment2Tool"         : 31,
                "VerticalLineSegmentTool"  : 32,
                "HorizontalLineSegmentTool": 33,
                }


    def __init__(self, parent=None):
        super().__init__(parent)

        # Logger
        self.log = logging.getLogger("pricebarchart.PriceBarChartWidget")
        self.log.debug("Entered __init__()")

        # Create the contents.
        self.priceBarChartSettings = PriceBarChartSettings()
        
        # Holds the tool mode that this widget is currently in.
        self.toolMode = PriceBarChartWidget.ToolMode['ReadOnlyPointerTool']

        # Holds the timezone of PriceBars in this widget.  
        # This is a datetime.tzinfo object.  We need this to convert X
        # scene coordinate values to a datetime.datetime object with the
        # correct timezone.
        self.timezone = pytz.utc

        # These are the label widgets at the top of the PriceBarChartWidget.
        self.descriptionLabel = QLabel("")
        self.firstPriceBarTimestampLabel = QLabel("")
        self.lastPriceBarTimestampLabel = QLabel("")
        self.numPriceBarsLabel = QLabel("")
        
        localizedTimestampStr = "Mouse time: "
        utcTimestampStr       = "Mouse time: "
        hebrewTimestampStr    = "Mouse time: "
        geoSunTimestampStr    = "Mouse time: "
        geoMoSuTimestampStr   = "Mouse time: "
        jdTimestampStr        = "Mouse jd:   "
        priceStr = "Mouse price: " 
        self.cursorLocalizedTimestampLabel = \
            QLabel(localizedTimestampStr)
        self.cursorUtcTimestampLabel = \
            QLabel(utcTimestampStr)
        self.cursorHebrewTimestampLabel = \
            QLabel(hebrewTimestampStr)
        self.cursorGeoSunTimestampLabel = \
            QLabel(geoSunTimestampStr)
        self.cursorGeoMoSuTimestampLabel = \
            QLabel(geoMoSuTimestampStr)
        self.cursorJdTimestampLabel = \
            QLabel(jdTimestampStr)
        self.cursorPriceLabel = \
            QLabel(priceStr)

        
        self.selectedPriceBarTimestampLabel = QLabel("")
        self.selectedPriceBarOpenPriceLabel = QLabel("")
        self.selectedPriceBarHighPriceLabel = QLabel("")
        self.selectedPriceBarLowPriceLabel = QLabel("")
        self.selectedPriceBarClosePriceLabel = QLabel("")
        
        # These labels will have smaller font.
        smallFont = QFont()
        smallFont.setPointSize(8)
        self.descriptionLabel.setFont(smallFont)
        self.firstPriceBarTimestampLabel.setFont(smallFont)
        self.lastPriceBarTimestampLabel.setFont(smallFont)
        self.numPriceBarsLabel.setFont(smallFont)
        self.selectedPriceBarTimestampLabel.setFont(smallFont)
        self.selectedPriceBarOpenPriceLabel.setFont(smallFont)
        self.selectedPriceBarHighPriceLabel.setFont(smallFont)
        self.selectedPriceBarLowPriceLabel.setFont(smallFont)
        self.selectedPriceBarClosePriceLabel.setFont(smallFont)

        # Set the cursor timestamp labels as being in a monospaced font.
        smallMonospacedFont = QFont()

        # Here we use the best-looking mono-spaced font for the platform.
        if platform.system() == "Linux":
            smallMonospacedFont.setFamily("DejaVu Sans Mono")
        elif platform.system() == "Darwin":
            smallMonospacedFont.setFamily("Monaco")
        else:
            smallMonospacedFont.setFamily("DejaVu Sans Mono")
            
        smallMonospacedFont.setPointSize(8)
        
        self.cursorLocalizedTimestampLabel.setFont(smallMonospacedFont)
        self.cursorUtcTimestampLabel.setFont(smallMonospacedFont)
        self.cursorHebrewTimestampLabel.setFont(smallMonospacedFont)
        self.cursorGeoSunTimestampLabel.setFont(smallMonospacedFont)
        self.cursorGeoMoSuTimestampLabel.setFont(smallMonospacedFont)
        self.cursorJdTimestampLabel.setFont(smallMonospacedFont)
        self.cursorPriceLabel.setFont(smallMonospacedFont)
        
        # Create the QGraphicsView and QGraphicsScene for the display portion.
        self.graphicsScene = PriceBarChartGraphicsScene()
        self.graphicsView = PriceBarChartGraphicsView()
        self.graphicsView.setScene(self.graphicsScene)

        # Setup the layouts.
        col0 = QVBoxLayout()
        col0.addWidget(self.descriptionLabel)
        col0.addWidget(self.numPriceBarsLabel)

        col1 = QVBoxLayout()
        col1.addWidget(self.firstPriceBarTimestampLabel)
        col1.addWidget(self.lastPriceBarTimestampLabel)

        col2 = QVBoxLayout()
        col2.addWidget(self.selectedPriceBarTimestampLabel)
        col2.addWidget(self.selectedPriceBarOpenPriceLabel)
        col2.addWidget(self.selectedPriceBarClosePriceLabel)

        col3 = QVBoxLayout()
        col3.addWidget(self.selectedPriceBarHighPriceLabel)
        col3.addWidget(self.selectedPriceBarLowPriceLabel)
        
        col4 = QVBoxLayout()
        col4.addWidget(self.cursorJdTimestampLabel)
        col4.addWidget(self.cursorPriceLabel)
       
        col5 = QVBoxLayout()
        col5.addWidget(self.cursorLocalizedTimestampLabel)
        col5.addWidget(self.cursorUtcTimestampLabel)
        col5.addWidget(self.cursorHebrewTimestampLabel)
        
        col6 = QVBoxLayout()
        col6.addWidget(self.cursorGeoSunTimestampLabel)
        col6.addWidget(self.cursorGeoMoSuTimestampLabel)
        
        topLabelsLayout = QGridLayout()
        topLabelsLayout.addLayout(col0, 0, 0)
        topLabelsLayout.addLayout(col1, 0, 1)
        topLabelsLayout.addLayout(col2, 0, 2)
        topLabelsLayout.addLayout(col3, 0, 3)
        topLabelsLayout.addLayout(col4, 0, 4)
        topLabelsLayout.addLayout(col5, 0, 5)
        topLabelsLayout.addLayout(col6, 0, 6)
        
        layout = QVBoxLayout()
        layout.addLayout(topLabelsLayout)
        layout.addWidget(self.graphicsView)
        self.setLayout(layout)

        self.graphicsView.show()

        # Connect signals and slots.
        self.graphicsView.mouseLocationUpdate.\
            connect(self._handleMouseLocationUpdate)
        self.graphicsView.statusMessageUpdate.\
            connect(self.statusMessageUpdate)
        self.graphicsScene.statusMessageUpdate.\
            connect(self.statusMessageUpdate)
        self.graphicsScene.priceBarChartChanged.\
            connect(self.priceBarChartChanged)
        self.graphicsScene.selectionChanged.\
            connect(self._handleSelectionChanged)

        # Bubble up the signal emission to update the time of the astro charts.
        self.graphicsScene.astroChart1Update.\
            connect(self.astroChart1Update)
        self.graphicsScene.astroChart2Update.\
            connect(self.astroChart2Update)
        self.graphicsScene.astroChart3Update.\
            connect(self.astroChart3Update)
        self.graphicsScene.jhoraLaunch.\
            connect(self.jhoraLaunch)
        self.graphicsScene.astrologLaunch.\
            connect(self.astrologLaunch)
        
        self.log.debug("Leaving __init__()")

    def setBirthInfo(self, birthInfo):
        """Sets the birth info for this trading entity.
        
        Arguments:

        birthInfo - BirthInfo object.
        """

        # Pass the information to the graphics scene.  If graphics
        # items need it, it will get it from there.
        self.graphicsScene.setBirthInfo(birthInfo)
        
    def setTimezone(self, timezone):
        """Sets the timezone used.  This is used for converting mouse
        X location to a datetime.datetime object.
        
        Arguments:
            
        timezone - A datetime.tzinfo object holding the timezone for the
                   pricebars in this widget.
        """

        self.timezone = timezone

        # The PriceBarChartGraphicsScene is actually the object that
        # does the conversions.  Pass the timezone info to that object.
        self.graphicsScene.setTimezone(self.timezone)

    def setDescriptionText(self, text):
        """Sets the text of the QLabel self.descriptionLabel."""

        self.descriptionLabel.setText("Description: " + text)

    def updateFirstPriceBarTimestampLabel(self, priceBar=None):
        """Updates the QLabel holding the timestamp of the first PriceBar
        in the pricebarchart.

        Arguments:

        priceBar - PriceBar object to use for updating the timestamp.  
                   If this argument is None, then the label text will be
                   blank.
        """

        # Datetime format to datetime.strftime().
        timestampStr = "First PriceBar: "
        
        if priceBar != None:
            timestampStr += Ephemeris.datetimeToDayStr(priceBar.timestamp)

        self.firstPriceBarTimestampLabel.setText(timestampStr)

    def updateLastPriceBarTimestampLabel(self, priceBar=None):
        """Updates the QLabel holding the timestamp of the last PriceBar
        in the pricebarchart.

        Arguments:

        priceBar - PriceBar object to use for updating the timestamp.  
                   If this argument is None, then the label text will be
                   blank.
        """

        timestampStr = "Last PriceBar: "
        
        if priceBar != None:
            timestampStr += Ephemeris.datetimeToDayStr(priceBar.timestamp)
        
        self.lastPriceBarTimestampLabel.setText(timestampStr)

    def updateNumPriceBarsLabel(self, numPriceBars):
        """Updates the QLabel holding the number of PriceBars
        currently drawn in the pricebarchart.

        Arguments:

        numPriceBars - int value for the number of PriceBars displayed in
                       the PriceBarChart.
        """

        text = "Number of PriceBars: {}".format(numPriceBars)

        self.numPriceBarsLabel.setText(text)

    def updateMouseLocationLabels(self, sceneXPos=None, sceneYPos=None):
        """Updates the QLabels holding the information about the time and
        price of where the mouse position is.  If either of the input
        arguments are None, then the cursor labels are cleared out.
        
        Arguments:
            
        sceneXPos - float value holding the X location of the mouse, in
                    scene coordinates. 
        sceneYPos - float value holding the X location of the mouse, in
                    scene coordinates.
        """

        localizedTimestampStr = "Mouse time: "
        utcTimestampStr       = "Mouse time: "
        hebrewTimestampStr    = "Mouse time: "
        geoSunTimestampStr    = "Mouse time: G.Sun:  "
        geoMoSuTimestampStr   = "Mouse time: G.MoSu: "
        jdTimestampStr        = "Mouse jd:   "
        priceStr = "Mouse price: " 

        # Set the values if the X and Y positions are valid.
        if sceneXPos != None and sceneYPos != None:

            # Convert coordinate to the actual values they represent.
            timestamp = self.graphicsScene.sceneXPosToDatetime(sceneXPos)
            price = self.graphicsScene.sceneYPosToPrice(sceneYPos)

            # Append to the strings.
            localizedTimestampStr += Ephemeris.datetimeToDayStr(timestamp)

            utcTimestampStr += \
                Ephemeris.datetimeToDayStr(timestamp.astimezone(pytz.utc))
              
            hebrewTimestampStr += \
                "[ {} ]    {}".format(\
                HebrewCalendarUtils.datetimeToHebrewDateStr(timestamp),
                    HebrewCalendarUtils.datetimeToHebrewMonthDayStr(timestamp))

            planetSun = Ephemeris.getPlanetaryInfo("Sun", timestamp)
            longitude = planetSun.geocentric['tropical']['longitude']
            geoSunTimestampStr += \
              AstrologyUtils.convertLongitudeToStrWithRasiAbbrev(longitude)

            planetMoSu = Ephemeris.getPlanetaryInfo("MoSu", timestamp)
            longitude = planetMoSu.geocentric['tropical']['longitude']
            synodicPhase = longitude / 12.0
            geoMoSuTimestampStr += \
                "{: >6.2f} deg.  [ Phase {: >5.2f} ]".\
                format(longitude, synodicPhase)

            jdTimestampStr += \
                str(Ephemeris.datetimeToJulianDay(timestamp))

            priceStr += "{}".format(price)

        # Actually set the text to the widgets.
        self.cursorLocalizedTimestampLabel.setText(localizedTimestampStr)
        self.cursorUtcTimestampLabel.setText(utcTimestampStr)
        self.cursorHebrewTimestampLabel.setText(hebrewTimestampStr)
        self.cursorGeoSunTimestampLabel.setText(geoSunTimestampStr)
        self.cursorGeoMoSuTimestampLabel.setText(geoMoSuTimestampStr)
        self.cursorJdTimestampLabel.setText(jdTimestampStr)
        self.cursorPriceLabel.setText(priceStr)

    def updateSelectedPriceBarLabels(self, priceBar=None):
        """Updates the QLabels describing the currently selected PriceBar.
        
        Arguments:

        priceBar - PriceBar object that holds info about the currently
                   selected PriceBar.
        """

        timestampStr = "Timestamp: "
        openStr = "Open: "
        highStr = "High: "
        lowStr = "Low: "
        closeStr = "Close: "

        if priceBar != None:
            timestampStr += Ephemeris.datetimeToDayStr(priceBar.timestamp)
            openStr += "{}".format(priceBar.open)
            highStr += "{}".format(priceBar.high)
            lowStr += "{}".format(priceBar.low)
            closeStr += "{}".format(priceBar.close)

        # Only change the labels if they are now different.
        if self.selectedPriceBarTimestampLabel.text() != timestampStr:
            self.selectedPriceBarTimestampLabel.setText(timestampStr)

        if self.selectedPriceBarOpenPriceLabel.text() != openStr:
            self.selectedPriceBarOpenPriceLabel.setText(openStr)

        if self.selectedPriceBarHighPriceLabel.text() != highStr:
            self.selectedPriceBarHighPriceLabel.setText(highStr)

        if self.selectedPriceBarLowPriceLabel.text() != lowStr:
            self.selectedPriceBarLowPriceLabel.setText(lowStr)

        if self.selectedPriceBarClosePriceLabel.text() != closeStr:
            self.selectedPriceBarClosePriceLabel.setText(closeStr)


    def loadPriceBars(self, priceBars):
        """Loads the given PriceBars list into this widget as
        PriceBarGraphicsItems.
        """
        
        self.log.debug("Entered loadPriceBars({} pricebars)".\
                       format(len(priceBars)))

        for priceBar in priceBars:

            # Create the QGraphicsItem
            item = PriceBarGraphicsItem()
            item.loadSettingsFromPriceBarChartSettings(\
                self.priceBarChartSettings)
            item.setPriceBar(priceBar)

            # Add the item.
            self.graphicsScene.addItem(item)

            # Make sure the proper flags are set for the mode we're in.
            self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(item)

            # X location based on the timestamp.
            x = self.graphicsScene.datetimeToSceneXPos(priceBar.timestamp)

            # Y location based on the mid price (average of high and low).
            y = self.graphicsScene.priceToSceneYPos(priceBar.midPrice())

            # Set the position, in parent coordinates.
            item.setPos(QPointF(x, y))

        # Set the labels for the timestamps of the first and 
        # last pricebars.
        if len(priceBars) > 0:
            firstPriceBar = self.graphicsScene.getEarliestPriceBar()
            lastPriceBar = self.graphicsScene.getLatestPriceBar()

            self.updateFirstPriceBarTimestampLabel(firstPriceBar)
            self.updateLastPriceBarTimestampLabel(lastPriceBar)
            self.updateNumPriceBarsLabel(len(priceBars))
        else:
            # There are no PriceBars.  Update the labels to reflect that.
            self.updateFirstPriceBarTimestampLabel(None)
            self.updateLastPriceBarTimestampLabel(None)
            self.updateNumPriceBarsLabel(len(priceBars))

            self.graphicsScene.clearCachedPriceBars()
            
        self.log.debug("Leaving loadPriceBars({} pricebars)".\
                       format(len(priceBars)))

    def clearAllPriceBars(self):
        """Clears all the PriceBar QGraphicsItems from the 
        QGraphicsScene."""

        # Get all the QGraphicsItems.
        graphicsItems = self.graphicsScene.items()

        # Only remove the PriceBarGraphicsItem items.
        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):
                if item.scene() != None:
                    self.graphicsScene.removeItem(item)

        # Update the labels describing the pricebarchart.
        self.updateFirstPriceBarTimestampLabel(None)
        self.updateLastPriceBarTimestampLabel(None)
        self.updateNumPriceBarsLabel(0)
        self.updateSelectedPriceBarLabels(None)
        self.graphicsScene.clearCachedPriceBars()

    def loadPriceBarChartArtifacts(self, priceBarChartArtifacts):
        """Loads the given list of PriceBarChartArtifact objects
        into this widget as QGraphicsItems.

        Arguments:
        
        priceBarChartArtifacts - list of PriceBarChartArtifact objects,
                                 which is used to create various types of
                                 PriceBarChartArtifactGraphicsItem to be
                                 added to the QGraphicsScene.
        """
        
        self.log.debug("Entered loadPriceBarChartArtifacts()")

        self.log.debug("Attempting to load {} artifacts.".\
                       format(len(priceBarChartArtifacts)))

        # Flag to determine if an item was created and added.
        addedItemFlag = False
        
        for artifact in priceBarChartArtifacts:

            # Create the specific PriceBarChartArtifactGraphicsItem,
            # depending on what kind of artifact this is.
            if isinstance(artifact, PriceBarChartBarCountArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = BarCountGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate bar count, since it wasn't in
                # the QGraphicsScene until now.
                newItem.recalculateBarCount()
        
                addedItemFlag = True
                
            elif isinstance(artifact, PriceBarChartTimeMeasurementArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = TimeMeasurementGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate time measurement, since it wasn't in
                # the QGraphicsScene until now.
                newItem.recalculateTimeMeasurement()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartTimeModalScaleArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = TimeModalScaleGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartPriceModalScaleArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = PriceModalScaleGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartPlanetLongitudeMovementMeasurementArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = PlanetLongitudeMovementMeasurementGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate time measurement, since it wasn't in
                # the QGraphicsScene until now.
                newItem.recalculatePlanetLongitudeMovementMeasurement()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartTextArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = TextGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)

                self.log.debug("Before setting artifact, " +
                               "internal artifact is: " +
                               newItem.getArtifact().toString())
                
                newItem.setArtifact(artifact)

                self.log.debug("After  setting artifact, " +
                               "internal artifact is: " +
                               newItem.getArtifact().toString())
                
                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                self.log.debug("After  adding item,      " +
                               "internal artifact is: " +
                               newItem.getArtifact().toString())
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                addedItemFlag = True
                
            elif isinstance(artifact, PriceBarChartPriceTimeInfoArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = PriceTimeInfoGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)

                # Set the conversion object as the scene so that it
                # can do initial calculations for the text to display.
                newItem.setConvertObj(self.graphicsScene)

                # Set the artifact offically so that it can update the text.
                newItem.setArtifact(artifact)

                # Set the birthInfo in the new item.  This will again
                # trigger a text update.
                birthInfo = self.graphicsScene.getBirthInfo()
                newItem.setBirthInfo(birthInfo)
                
                # Add the item to the graphics scene.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartPriceMeasurementArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = PriceMeasurementGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate price measurement, since it wasn't in
                # the QGraphicsScene until now.
                newItem.recalculatePriceMeasurement()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartTimeRetracementArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = TimeRetracementGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate time retracement, since it wasn't in
                # the QGraphicsScene until now.
                newItem.recalculateTimeRetracement()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartPriceRetracementArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = PriceRetracementGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate price retracement, since it wasn't in
                # the QGraphicsScene until now.
                newItem.recalculatePriceRetracement()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartPriceTimeVectorArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = PriceTimeVectorGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to refresh the item (recalculate) since it
                # wasn't in the QGraphicsScene until now.
                newItem.refreshItem()

                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartLineSegmentArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = LineSegmentGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)
                
                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)
                
                # Need to refresh the item (recalculate) since it
                # wasn't in the QGraphicsScene until now.
                newItem.refreshItem()

                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartVerticalLineSegmentArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = VerticalLineSegmentGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)
                
                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)
                
                # Need to refresh the item (recalculate) since it
                # wasn't in the QGraphicsScene until now.
                newItem.refreshItem()

                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartHorizontalLineSegmentArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = HorizontalLineSegmentGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)
                
                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)
                
                # Need to refresh the item (recalculate) since it
                # wasn't in the QGraphicsScene until now.
                newItem.refreshItem()

                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartOctaveFanArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = OctaveFanGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
        
                # Set the conversion object as the scene so that it
                # can do initial calculations for the text to display.
                newItem.setConvertObj(self.graphicsScene)

                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to refresh the item (recalculate) since it
                # wasn't in the QGraphicsScene until now.
                newItem.refreshItem()
                
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartFibFanArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = FibFanGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
        
                # Set the conversion object as the scene so that it
                # can do initial calculations for the text to display.
                newItem.setConvertObj(self.graphicsScene)

                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to refresh the item (recalculate) since it
                # wasn't in the QGraphicsScene until now.
                newItem.refreshItem()
                
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartGannFanArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = GannFanGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
        
                # Set the conversion object as the scene so that it
                # can do initial calculations for the text to display.
                newItem.setConvertObj(self.graphicsScene)

                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to refresh the item (recalculate) since it
                # wasn't in the QGraphicsScene until now.
                newItem.refreshItem()
                
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartVimsottariDasaArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = VimsottariDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartAshtottariDasaArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = AshtottariDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartYoginiDasaArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = YoginiDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartDwisaptatiSamaDasaArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = DwisaptatiSamaDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartShattrimsaSamaDasaArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = ShattrimsaSamaDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact, PriceBarChartDwadasottariDasaArtifact):
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = DwadasottariDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact,
                            PriceBarChartChaturaseetiSamaDasaArtifact):
                
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = ChaturaseetiSamaDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact,
                            PriceBarChartSataabdikaDasaArtifact):
                
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = SataabdikaDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact,
                            PriceBarChartShodasottariDasaArtifact):
                
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = ShodasottariDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact,
                            PriceBarChartPanchottariDasaArtifact):
                
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = PanchottariDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

            elif isinstance(artifact,
                            PriceBarChartShashtihayaniDasaArtifact):
                
                self.log.debug("Loading artifact: " + artifact.toString())
                
                newItem = ShashtihayaniDasaGraphicsItem()
                newItem.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                newItem.setArtifact(artifact)

                # Add the item.
                self.graphicsScene.addItem(newItem)
                
                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(newItem)

                # Need to recalculate musicalRatios in the scale,
                # since it wasn't in the QGraphicsScene until now.
                newItem.refreshTextItems()
        
                addedItemFlag = True

        if addedItemFlag == True:
            # Emit that the PriceBarChart has changed.
            self.graphicsScene.priceBarChartChanged.emit()
            
        self.log.debug("Exiting loadPriceBarChartArtifacts()")



    def getPriceBarChartArtifacts(self):
        """Returns the list of PriceBarChartArtifacts that have been used
        to draw the the artifacts in the QGraphicsScene.
        """

        self.log.debug("Entered getPriceBarChartArtifacts()")
        
        # List of PriceBarChartArtifact objects returned.
        artifacts = []
        
        # Go through all the QGraphicsItems and for each artifact type,
        # extract the PriceBarChartArtifact.
        graphicsItems = self.graphicsScene.items()
        
        for item in graphicsItems:
            if isinstance(item, PriceBarChartArtifactGraphicsItem):
                artifacts.append(item.getArtifact())

        self.log.debug("Number of artifacts being returned is: {}".\
                       format(len(artifacts)))
        
        self.log.debug("Exiting getPriceBarChartArtifacts()")
        
        return artifacts

    def clearAllPriceBarChartArtifacts(self):
        """Clears all the PriceBarChartArtifact objects from the 
        QGraphicsScene."""

        self.log.debug("Entered clearAllPriceBarChartArtifacts()")

        # Flag to determine if an item was removed.
        removedItemFlag = False
        
        # Go through all the QGraphicsItems and remove the artifact items.
        graphicsItems = self.graphicsScene.items()

        for item in graphicsItems:
            if isinstance(item, PriceBarChartArtifactGraphicsItem):
                self.log.debug("Removing QGraphicsItem for artifact " + \
                               item.getArtifact().toString())
                if item.scene() != None:
                    self.graphicsScene.removeItem(item)
                
                removedItemFlag = True

        if removedItemFlag == True:
            # Emit that the PriceBarChart has changed.
            self.graphicsScene.priceBarChartChanged.emit()
            
        self.log.debug("Exiting clearAllPriceBarChartArtifacts()")

    def drawLookbackMultiplePriceBars(self, lookbackMultiples):
        """Causes the drawing of LookbackMultiplePriceBarGraphicsItems

        These are only drawn for the currently visible area of the 
        QGraphicsScene.

        Note: This drawing does not cause a priceBarChartChanged signal
        to be emitted.  That is because LookbackMultiplePriceBars are
        transient and are not persisted.  They get redrawn frequently, 
        and where they are drawn are highly dependent on the user's current 
        view.
        """
        
        self.log.debug("Entered drawLookbackMultiplePriceBars()")

        # Maximum error for calculation of LookbackMultiple results.
        maxErrorTd = datetime.timedelta(minutes=60)
        
        
        # Set the birth location in the Ephemeris.
        #
        # This is required before making Ephemeris calculations for
        # LookbackMultiple.
        birthInfo = self.graphicsScene.getBirthInfo()
        Ephemeris.setGeographicPosition(birthInfo.longitudeDegrees,
                                        birthInfo.latitudeDegrees,
                                        birthInfo.elevation)

        # Get area of the QGraphicsScene that is visible in the 
        # QGraphicsView, as a QRect.
        viewportRect = QRect(0, 0, 
                             self.graphicsView.viewport().width(), 
                             self.graphicsView.viewport().height());
        visibleSceneRectF = \
            self.graphicsView.mapToScene(viewportRect).boundingRect()

        if self.log.isEnabledFor(logging.DEBUG) == True:
            self.log.debug("visibleSceneRect is: x={}, y={}, w={}, h={}".\
                           format(visibleSceneRectF.x(), 
                                  visibleSceneRectF.y(), 
                                  visibleSceneRectF.width(), 
                                  visibleSceneRectF.height()))

        # Convert the scene rectangle coordinates to dates and prices.
        earliestViewDt = \
            self.graphicsScene.sceneXPosToDatetime(visibleSceneRectF.x())
        latestViewDt = \
            self.graphicsScene.sceneXPosToDatetime(visibleSceneRectF.x() + \
                                                   visibleSceneRectF.width())
        highestViewPrice = \
            self.graphicsScene.sceneYPosToPrice(visibleSceneRectF.y())
        lowestViewPrice = \
            self.graphicsScene.sceneYPosToPrice(visibleSceneRectF.y() + \
                                                visibleSceneRectF.height())

        if self.log.isEnabledFor(logging.DEBUG) == True:
            self.log.debug("earliestViewDt == {}".\
                           format(Ephemeris.datetimeToDayStr(earliestViewDt)))
            self.log.debug("latestViewDt   == {}".\
                           format(Ephemeris.datetimeToDayStr(latestViewDt)))
            self.log.debug("highestViewPrice == {}".format(highestViewPrice))
            self.log.debug("lowestViewPrice  == {}".format(lowestViewPrice))

        for lookbackMultiple in lookbackMultiples:

            # Don't process disabled LookbackMultiples.
            if lookbackMultiple.getEnabled() == False:
                continue
            else:
                if self.log.isEnabledFor(logging.DEBUG) == True:
                    self.log.debug("Processing LookbackMultiple: {}".\
                                   format(lookbackMultiple.toString()))

            # Extract needed information from the LookbackMultiple.
            planetName = lookbackMultiple.getPlanetName()

            centricityType = ""
            if lookbackMultiple.getGeocentricFlag() == True:
                centricityType = "geocentric"
            if lookbackMultiple.getHeliocentricFlag() == True:
                centricityType = "heliocentric"

            longitudeType = ""
            if lookbackMultiple.getTropicalFlag() == True:
                longitudeType = "tropical"
            if lookbackMultiple.getSiderealFlag() == True:
                longitudeType = "sidereal"

            desiredDeltaDegrees = 0
            if lookbackMultiple.getBaseUnitTypeDegreesFlag() == True:
                desiredDeltaDegrees = \
                    lookbackMultiple.getLookbackMultiple() * \
                    lookbackMultiple.getBaseUnit()
            if lookbackMultiple.getBaseUnitTypeRevolutionsFlag() == True:
                desiredDeltaDegrees = \
                    lookbackMultiple.getLookbackMultiple() * \
                    lookbackMultiple.getBaseUnit() * \
                    360
            
            # Look backwards in time to get the start and end datetimes for
            # obtaining the time range of historic PriceBars.
            self.log.debug("Looking backwards in time ...")
            
            argsTupleList = []

            startLookbackArgs = (\
                    planetName, 
                    centricityType, 
                    longitudeType, 
                    earliestViewDt, 
                    desiredDeltaDegrees * -1, 
                    maxErrorTd, 
                    birthInfo.longitudeDegrees,
                    birthInfo.latitudeDegrees,
                    birthInfo.elevation)

            argsTupleList.append(startLookbackArgs)

            endLookbackArgs = (\
                    planetName, 
                    centricityType, 
                    longitudeType, 
                    latestViewDt, 
                    desiredDeltaDegrees * -1, 
                    maxErrorTd, 
                    birthInfo.longitudeDegrees,
                    birthInfo.latitudeDegrees,
                    birthInfo.elevation)

            argsTupleList.append(endLookbackArgs)

            # Compute results.
            resultsList = \
                self._getLookbackMultipleDatetimesOfLongitudeDeltaDegreesInPast(\
                    argsTupleList)
            
            if len(resultsList) == 0:
                # No results were returned.  This means an error happened
                # during calculation that was already logged.  Return without
                # drawing any LookbackMultiplePriceBars.
                return
                
            startLookbackDts = resultsList[0]
            endLookbackDts = resultsList[1]
            
            if self.log.isEnabledFor(logging.DEBUG) == True:
                self.log.debug("len(startLookbackDts) == {}".\
                               format(len(startLookbackDts)))
                for i in range(len(startLookbackDts)):
                    dt = startLookbackDts[i]
                    self.log.debug("startLookbackDts[{}] == {}".format(i, dt))
    
                self.log.debug("len(endLookbackDts) == {}".\
                               format(len(endLookbackDts)))
                for i in range(len(endLookbackDts)):
                    dt = endLookbackDts[i]
                    self.log.debug("endLookbackDts[{}] == {}".format(i, dt))

            # Put the datetimes together into one list, then sort, and get the
            # earliest and latest datetimes.  We need to do this because if the
            # QGraphicsView is very zoomed in, and the planet is going
            # retrograde, then the startLookbackDts may actually come after the
            # endLookbackDts.  By doing this, we ensure that we get the largest
            # possible set of PriceBars for the historic time period compared
            # related to this current period.
            startAndEndPriceBarSearchDts = startLookbackDts + endLookbackDts
            startAndEndPriceBarSearchDts.sort()

            startPriceBarSearchDt = startAndEndPriceBarSearchDts[0]
            endPriceBarSearchDt = startAndEndPriceBarSearchDts[-1]

            if self.log.isEnabledFor(logging.DEBUG) == True:
                self.log.debug("startPriceBarSearchDt == {}".\
                    format(Ephemeris.datetimeToDayStr(startPriceBarSearchDt)))
                self.log.debug("endPriceBarSearchDt == {}".\
                    format(Ephemeris.datetimeToDayStr(endPriceBarSearchDt)))

            # Get the PriceBars in time between startPriceBarSearchDt and
            # endPriceBarSearchDt.  Store these in list 'pbs'.
            pbs = []

            graphicsItems = self.graphicsScene.items()
            for item in graphicsItems:
                if isinstance(item, PriceBarGraphicsItem):
                    pb = item.getPriceBar()
                    dt = pb.timestamp
                    if startPriceBarSearchDt <= dt <= endPriceBarSearchDt:
                        # Found a PriceBar within our historic time range.
                        pbs.append(pb)

                        if self.log.isEnabledFor(logging.DEBUG) == True:
                            debugStr = "Found a pricebar within " + \
                                "our historic time range: {}".\
                                format(Ephemeris.datetimeToDayStr(dt))
                            self.log.debug(debugStr)

            # Sort the PriceBars by ascending timestamp (earlier to later).
            pbs.sort(key=lambda x: x.timestamp)
            
            # Working variables that will be used later for scaling the
            # LookbackMultiplePriceBars to fit within the visible portion of
            # the QGraphicsView.
            highestPriceBarPrice = None
            lowestPriceBarPrice = None
            
            for pb in pbs:
                if highestPriceBarPrice == None:
                    highestPriceBarPrice = pb.high
                elif pb.high > highestPriceBarPrice:
                    highestPriceBarPrice = pb.high

                if lowestPriceBarPrice == None:
                    lowestPriceBarPrice = pb.low
                elif pb.low < lowestPriceBarPrice:
                    lowestPriceBarPrice = pb.low

            if self.log.isEnabledFor(logging.DEBUG) == True:
                self.log.debug("highestPriceBarPrice == {}".\
                               format(highestPriceBarPrice))
                self.log.debug("lowestPriceBarPrice == {}".\
                               format(lowestPriceBarPrice))
            
            # Calculate LookbackMultiple datetimes for each PriceBar's
            # timestamp.

            # Assemble arguments for each method invocation to get datetimes.
            argsTupleList = []
            for pb in pbs:
                referenceDt = pb.timestamp
                
                args = (\
                    planetName, 
                    centricityType, 
                    longitudeType, 
                    referenceDt, 
                    desiredDeltaDegrees, 
                    maxErrorTd, 
                    birthInfo.longitudeDegrees,
                    birthInfo.latitudeDegrees,
                    birthInfo.elevation)

                argsTupleList.append(args)
            
            if self.log.isEnabledFor(logging.INFO) == True:
                infoMsg = \
                    "Calculating LookbackMultiple datetimes " + \
                    "in the future for {} historic PriceBars ".\
                    format(len(pbs)) + \
                    "(startDt={}, endDt={}) ...".\
                    format(Ephemeris.datetimeToDayStr(startPriceBarSearchDt),
                           Ephemeris.datetimeToDayStr(endPriceBarSearchDt))
                self.log.info(infoMsg)
            
            # Compute results.
            resultsList = \
                self._getLookbackMultipleDatetimesOfLongitudeDeltaDegreesInFuture(\
                    argsTupleList)
    
            if len(resultsList) == 0:
                # No results were returned.  This means an error happened
                # during calculation that was already logged.  Return without
                # drawing any LookbackMultiplePriceBars.
                return
                
            # Create the LookbackMultiplePriceBars for these historic
            # PriceBars and store them in a list.
            lmpbs = []
            for i in range(len(pbs)):
                
                # Current PriceBar and it's LookbackMultiple datetimes 
                # in the future.
                pb = pbs[i]
                resultDts = resultsList[i]
                
                # Create the LookbackMultiplePriceBar for each timestamp.
                # The prices used in the LookbackMultiplePriceBars are 
                # the underlying PriceBar's values scaled.
                for dt in resultDts:
                    lmpb = LookbackMultiplePriceBar(lookbackMultiple, pb)
                    lmpb.timestamp = dt
                    lmpb.open = \
                        self._scaleLookbackMultiplePriceBarPrice(\
                            highestViewPrice,
                            lowestViewPrice,
                            highestPriceBarPrice,
                            lowestPriceBarPrice,
                            priceBarPriceToScale=pb.open)
                    lmpb.high = \
                        self._scaleLookbackMultiplePriceBarPrice(\
                            highestViewPrice,
                            lowestViewPrice,
                            highestPriceBarPrice,
                            lowestPriceBarPrice,
                            priceBarPriceToScale=pb.high)
                    lmpb.low = \
                        self._scaleLookbackMultiplePriceBarPrice(\
                            highestViewPrice,
                            lowestViewPrice,
                            highestPriceBarPrice,
                            lowestPriceBarPrice,
                            priceBarPriceToScale=pb.low)
                    lmpb.close = \
                        self._scaleLookbackMultiplePriceBarPrice(\
                            highestViewPrice,
                            lowestViewPrice,
                            highestPriceBarPrice,
                            lowestPriceBarPrice,
                            priceBarPriceToScale=pb.close)
                    lmpb.oi = pb.oi
                    lmpb.vol = pb.vol
                    lmpb.tags = copy.deepcopy(pb.tags)

                    # Append to our list of LookbackMultiplePriceBars.
                    lmpbs.append(lmpb)

            # Create and draw the LookbackMultiplePriceBarGraphicsItems for
            # each of the LookbackMultiplePriceBars.
            for lmpb in lmpbs:
                # Create the QGraphicsItem.
                item = LookbackMultiplePriceBarGraphicsItem()
                item.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                item.setLookbackMultiplePriceBar(lmpb)

                # Add the item.
                self.graphicsScene.addItem(item)

                # Make sure the proper flags are set for the mode we're in.
                self.graphicsView.setGraphicsItemFlagsPerCurrToolMode(item)
    
                # X location based on the timestamp.
                x = self.graphicsScene.datetimeToSceneXPos(lmpb.timestamp)
    
                # Y location based on the mid price (average of high and low).
                y = self.graphicsScene.priceToSceneYPos(lmpb.midPrice())
    
                # Set the position, in parent coordinates.
                item.setPos(QPointF(x, y))
        
        
        self.log.debug("Exiting drawLookbackMultiplePriceBars()")


    def _getLookbackMultipleDatetimesOfLongitudeDeltaDegreesInFuture(self, argsTupleList):
        """Makes LookbackMultiple calculations into the future by
        one of the following methods, depending on what is
        configured in QSettings (set via AppPreferencesEditDialog).

        The possible calculation model/methods are:
          - Local serial calculations.
          - Local parallel calculations (multiple processes).
          - Remote parallel calculations (multiple processes, distributed).
            
        Arguments:
        argsTupleList - List of tuple objects.  
                        Each tuple has the following within it:
            
            planetName - str holding the name of the planet to do the
                         calculations for.
            centricityType - str value holding either "geocentric",
                             "topocentric", or "heliocentric".
            longitudeType - str value holding either "tropical" or "sidereal".
            referenceDt - datetime.datetime object for the reference time.
                          The planet longitude at this moment is taken as
                          the zero-point.  Increments or decrements in time 
                          are started from this moment in time.
            desiredDeltaDegrees - float value for the number of 
                            longitude degrees elapsed from the 
                            longitude at 'referenceDt'.
            maxErrorTd - datetime.timedelta object holding the maximum
                         time difference between the exact planetary
                         combination timestamp, and the one calculated.
                         This would define the accuracy of the
                         calculations.  
            locationLongitudeDegrees - float value holding the
                          location longitude in degrees.  
                          West longitudes are negative,
                          East longitudes are positive.
                          Value should be in the range of -180 to 180.
            locationLatitudeDegrees - float value holding the
                          location latitude in degrees.
                          North latitudes are positive, 
                          South latitudes are negative.  
                          Value should be in the range of -90 to 90.
            locationElevationMeters - float value holding the
                          altitude in meters.
            
        Returns:
        List of list of datetime.datetime objects.
        Each list within the list corresponds to the
        respective tuple within argsTupleList
        The datetime.datetime objects are the timestamps
        where the planet is at the elapsed number of
        degrees away from the longitude at 'referenceDt'.
        """
        
        self.log.debug("Entered _getLookbackMultipleDatetimesOfLongitudeDeltaDegreesInFuture()")

        # Return value.
        rv = []

        # Set the start time for timing how long the computations take.
        startTime = time.time()
 
        # Obtain the QSettings value for the LookbackMultiple
        # calculation model/architecture to use.
        settings = QSettings()
        key = SettingsKeys.lookbackMultipleCalcModelKey
        value = settings.value(key, \
            SettingsKeys.lookbackMultipleCalcModelDefValue,
            type=str)
        
        if value == str(LookbackMultipleCalcModel.local_serial):
            self.log.debug(\
                "Doing LookbackMultiple calculations local serial.")
            
            for argsTuple in argsTupleList:
                
                # Extract variable values from the tuple.
                planetName = argsTuple[0]
                centricityType = argsTuple[1]
                longitudeType = argsTuple[2]
                referenceDt = argsTuple[3]
                desiredDeltaDegrees = argsTuple[4]
                maxErrorTd = argsTuple[5]
                locationLongitudeDegrees = argsTuple[6]
                locationLatitudeDegrees = argsTuple[7]
                locationElevationMeters = argsTuple[8]

                # Initialize ephemeris.
                LookbackMultipleUtils.initializeEphemeris(\
                    locationLongitudeDegrees, 
                    locationLatitudeDegrees,
                    locationElevationMeters)
                
                # Do LookbackMultiple calculations.
                dts = \
                    LookbackMultipleUtils.\
                    getDatetimesOfLongitudeDeltaDegreesInFuture(\
                        planetName,
                        centricityType,
                        longitudeType,
                        referenceDt,
                        desiredDeltaDegrees,
                        maxErrorTd)

                rv.append(dts)
                
        elif value == str(LookbackMultipleCalcModel.local_parallel):
            self.log.debug(\
                "Doing LookbackMultiple calculations local parallel.")

            # Run calculations in parallel, locally.
            rv = \
               LookbackMultipleParallel.\
               getDatetimesOfLongitudeDeltaDegreesInFutureParallel(\
                   argsTupleList)
            
        elif value == str(LookbackMultipleCalcModel.remote_parallel):
            self.log.debug(\
                "Doing LookbackMultiple calculations remote parallel.")

            # Run calculations in parallel, remotely.
            methodName = "getDatetimesOfLongitudeDeltaDegreesInFuture"

            rv = self._runLookbackMultipleCalculationsRemoteParallel(\
                methodName, argsTupleList)

        else:
            errorMsg = "QSettings had an unknown or unsupported " + \
                       "LookbackMultiple calculation model/architecture.  " + \
                       "The calculation was aborted."
            self.log.error(errMsg)
            QMessageBox.warning(self, "LookbackMultiple",
                                errorMsg,
                                QMessageBox.Ok,
                                QMessageBox.NoButton);

        # Set the end time for timing how long the computations take.
        endTime = time.time()

        self.log.info("Calculations for {} took: {} sec".\
                      format(value, endTime - startTime))

        self.log.debug("Exiting _getLookbackMultipleDatetimesOfLongitudeDeltaDegreesInFuture()")
        return rv


    def _getLookbackMultipleDatetimesOfLongitudeDeltaDegreesInPast(self, argsTupleList):
        """Makes LookbackMultiple calculations into the past by
        one of the following methods, depending on what is
        configured in QSettings (set via AppPreferencesEditDialog).

        The possible calculation model/methods are:
          - Local serial calculations.
          - Local parallel calculations (multiple processes).
          - Remote parallel calculations (multiple processes, distributed).
            
        Arguments:
        argsTupleList - List of tuple objects.  
                        Each tuple has the following within it:
            
            planetName - str holding the name of the planet to do the
                         calculations for.
            centricityType - str value holding either "geocentric",
                             "topocentric", or "heliocentric".
            longitudeType - str value holding either "tropical" or "sidereal".
            referenceDt - datetime.datetime object for the reference time.
                          The planet longitude at this moment is taken as
                          the zero-point.  Increments or decrements in time 
                          are started from this moment in time.
            desiredDeltaDegrees - float value for the number of 
                            longitude degrees elapsed from the 
                            longitude at 'referenceDt'.
            maxErrorTd - datetime.timedelta object holding the maximum
                         time difference between the exact planetary
                         combination timestamp, and the one calculated.
                         This would define the accuracy of the
                         calculations.  
            locationLongitudeDegrees - float value holding the
                          location longitude in degrees.  
                          West longitudes are negative,
                          East longitudes are positive.
                          Value should be in the range of -180 to 180.
            locationLatitudeDegrees - float value holding the
                          location latitude in degrees.
                          North latitudes are positive, 
                          South latitudes are negative.  
                          Value should be in the range of -90 to 90.
            locationElevationMeters - float value holding the
                          altitude in meters.
            
        Returns:
        List of list of datetime.datetime objects.
        Each list within the list corresponds to the
        respective tuple within argsTupleList
        The datetime.datetime objects are the timestamps
        where the planet is at the elapsed number of
        degrees away from the longitude at 'referenceDt'.
        """

        self.log.debug("Entered _getLookbackMultipleDatetimesOfLongitudeDeltaDegreesInPast()")

        # Return value.
        rv = []

        # Set the start time for timing how long the computations take.
        startTime = time.time()
 
        # Obtain the QSettings value for the LookbackMultiple
        # calculation model/architecture to use.
        settings = QSettings()
        key = SettingsKeys.lookbackMultipleCalcModelKey
        value = settings.value(key, \
            SettingsKeys.lookbackMultipleCalcModelDefValue,
            type=str)
        
        if value == str(LookbackMultipleCalcModel.local_serial):
            self.log.debug(\
                "Doing LookbackMultiple calculations local serial.")
            
            for argsTuple in argsTupleList:
                
                # Extract variable values from the tuple.
                planetName = argsTuple[0]
                centricityType = argsTuple[1]
                longitudeType = argsTuple[2]
                referenceDt = argsTuple[3]
                desiredDeltaDegrees = argsTuple[4]
                maxErrorTd = argsTuple[5]
                locationLongitudeDegrees = argsTuple[6]
                locationLatitudeDegrees = argsTuple[7]
                locationElevationMeters = argsTuple[8]

                # Initialize ephemeris.
                LookbackMultipleUtils.initializeEphemeris(\
                    locationLongitudeDegrees, 
                    locationLatitudeDegrees,
                    locationElevationMeters)
                
                # Do LookbackMultiple calculations.
                dts = \
                    LookbackMultipleUtils.\
                    getDatetimesOfLongitudeDeltaDegreesInPast(\
                        planetName,
                        centricityType,
                        longitudeType,
                        referenceDt,
                        desiredDeltaDegrees,
                        maxErrorTd)

                rv.append(dts)
                
        elif value == str(LookbackMultipleCalcModel.local_parallel):
            self.log.debug(\
                "Doing LookbackMultiple calculations local parallel.")

            # Run calculations in parallel, locally.
            rv = \
               LookbackMultipleParallel.\
               getDatetimesOfLongitudeDeltaDegreesInPastParallel(\
                   argsTupleList)
            
        elif value == str(LookbackMultipleCalcModel.remote_parallel):
            self.log.debug(\
                "Doing LookbackMultiple calculations remote parallel.")

            # Run calculations in parallel, remotely.
            methodName = "getDatetimesOfLongitudeDeltaDegreesInPast"

            rv = self._runLookbackMultipleCalculationsRemoteParallel(\
                methodName, argsTupleList)

        else:
            errorMsg = "QSettings had an unknown or unsupported " + \
                       "LookbackMultiple calculation model/architecture.  " + \
                       "The calculation was aborted."
            self.log.error(errMsg)
            QMessageBox.warning(self, "LookbackMultiple",
                                errorMsg,
                                QMessageBox.Ok,
                                QMessageBox.NoButton);


        # Set the end time for timing how long the computations take.
        endTime = time.time()

        self.log.info("Calculations for {} took: {} sec".\
                      format(value, endTime - startTime))

        self.log.debug("Exiting _getLookbackMultipleDatetimesOfLongitudeDeltaDegreesInPast()")
        return rv

    def _runLookbackMultipleCalculationsRemoteParallel(self, 
                                                       methodName, 
                                                       argsTupleList):
        """
        Arguments:
        methodName   - str holding one of the following:
                       getDatetimesOfLongitudeDeltaDegreesInFuture
                       getDatetimesOfLongitudeDeltaDegreesInPast
        listOfTuples - List of tuple objects.  Each tuple has 
                       the following within it:
            
            planetName - str holding the name of the planet to do the
                         calculations for.
            centricityType - str value holding either "geocentric",
                             "topocentric", or "heliocentric".
            longitudeType - str value holding either "tropical" or "sidereal".
            referenceDt - datetime.datetime object for the reference time.
                          The planet longitude at this moment is taken as
                          the zero-point.  Increments or decrements in time 
                          are started from this moment in time.
            desiredDeltaDegrees - float value for the number of 
                            longitude degrees elapsed from the 
                            longitude at 'referenceDt'.
            maxErrorTd - datetime.timedelta object holding the maximum
                         time difference between the exact planetary
                         combination timestamp, and the one calculated.
                         This would define the accuracy of the
                         calculations.  
            locationLongitudeDegrees - float value holding the
                          location longitude in degrees.  
                          West longitudes are negative,
                          East longitudes are positive.
                          Value should be in the range of -180 to 180.
            locationLatitudeDegrees - float value holding the
                          location latitude in degrees.
                          North latitudes are positive, 
                          South latitudes are negative.  
                          Value should be in the range of -90 to 90.
            locationElevationMeters - float value holding the
                          altitude in meters.
            
        Returns:
        List of list of datetime.datetime objects.
        Each list within the list corresponds to the
        respective tuple within listOfTuples
        The datetime.datetime objects are the timestamps
        where the planet is at the elapsed number of
        degrees away from the longitude at 'referenceDt'.
        """

        if methodName != "getDatetimesOfLongitudeDeltaDegreesInFuture" and \
                methodName != "getDatetimesOfLongitudeDeltaDegreesInPast":
            
            errStr = "Invalid 'methodName' argument given to do " + \
                "remote parallel LookbackMultiple processing: {}".\
                format(methodName)
            self.log.error(errStr)
            raise ValueError(errStr)
        
        # Get QSettings values for what server to connect to, for
        # submitting tasks and retrieving results.
        settings = QSettings()

        # Server address (str).
        # Either a hostname or an IP address.
        key = SettingsKeys.lookbackMultipleCalcRemoteServerAddressKey
        value = settings.value(key, \
            SettingsKeys.lookbackMultipleCalcRemoteServerAddressDefValue,
            type=str)
        serverAddress = value

        # Server port number (int).
        key = SettingsKeys.lookbackMultipleCalcRemoteServerPortKey
        value = settings.value(key, \
            SettingsKeys.lookbackMultipleCalcRemoteServerPortDefValue,
            type=int)
        serverPort = value
            
        # Server auth key (bytes).
        key = SettingsKeys.lookbackMultipleCalcRemoteServerAuthKeyKey
        value = settings.value(key, \
            SettingsKeys.lookbackMultipleCalcRemoteServerAuthKeyDefValue,
            type=str)
        serverAuthKey = value.encode("utf-8")
           
        class QueueManager(BaseManager):
            pass
            
        QueueManager.register("getTaskQueue", 
                              callable=lambda: taskQueue)
        QueueManager.register("getResultQueue", 
                              callable=lambda: resultQueue)
    
        manager = QueueManager(address=(serverAddress, serverPort), 
                               authkey=serverAuthKey)

        self.log.debug("LookbackMultiple client tasker connecting " + \
                       "to server {} port {} ...".\
                       format(serverAddress, serverPort))
        try:
            manager.connect()
        except ConnectionRefusedError as e:
            endl = os.linesep
            errorStr = "Caught ConnectionRefusedError while " + \
                "trying to connect to " + \
                "LookbackMultiple server {} port {}.  Aborting calculations.".\
                format(serverAddress, serverPort, e) + \
                "  e == {}".format(e)
            self.log.error(errorStr)
            QMessageBox.warning(self, 
                                "Connection Refused Error",
                                errorStr,
                                QMessageBox.Ok,
                                QMessageBox.NoButton);
            rv = []
            return rv
        except AuthenticationError as e:
            endl = os.linesep
            errorStr = "Caught AuthenticationError while " + \
                "trying to connect to " + \
                "LookbackMultiple server {} port {}.  ".\
                format(serverAddress, serverPort) + \
                "Please verify your authkey/password!  " + \
                "Aborting calculations.  e == {}".format(e)
            self.log.error(errorStr)
            QMessageBox.warning(self, 
                                "Authentication Error",
                                errorStr,
                                QMessageBox.Ok,
                                QMessageBox.NoButton);
            rv = []
            return rv
                           
        self.log.debug("LookbackMultiple client tasker connected.")
        
        taskQueue = manager.getTaskQueue()
        resultQueue = manager.getResultQueue()

        # The remote parallel distributed method takes a list of tuples with
        # different arguments/parameters.  This list holds the reformatted
        # parameters.
        newArgsTupleList = []

        for i in range(len(argsTupleList)):
            argsTuple = argsTupleList[i]
                            
            # Extract variable values from the tuple.
            planetName = argsTuple[0]
            centricityType = argsTuple[1]
            longitudeType = argsTuple[2]
            referenceDt = argsTuple[3]
            desiredDeltaDegrees = argsTuple[4]
            maxErrorTd = argsTuple[5]
            locationLongitudeDegrees = argsTuple[6]
            locationLatitudeDegrees = argsTuple[7]
            locationElevationMeters = argsTuple[8]
            
            # Variables not in the original tuple.
            methodToRun = methodName
            taskId = i

            # Assemble a new tuple for sending to the remote server.
            newArgsTuple = (\
                methodToRun,
                taskId,
                planetName, 
                centricityType, 
                longitudeType, 
                referenceDt, 
                desiredDeltaDegrees, 
                maxErrorTd, 
                locationLongitudeDegrees, 
                locationLatitudeDegrees, 
                locationElevationMeters)
            
            newArgsTupleList.append(newArgsTuple)
            
        # Submit tasks.
        self.log.info("Submitting {} tasks ...".format(len(newArgsTupleList)))
        for argsTuple in newArgsTupleList:
            taskQueue.put(argsTuple)
        self.log.info("Submitting {} tasks completed.".\
                  format(len(newArgsTupleList)))
            
        # Block, waiting for all the tasks to complete.
        self.log.info("Waiting for all tasks to complete ...")

        taskQueue.join()

        self.log.info("Tasks completed.  Now analyzing results ...")
        
        # Initialize the results list that will be returned.  
        #
        # The results extracted out of the resultQueue is not guaranteed to be
        # in the same order as the corresponding tasks submitted to the
        # taskQueue.  This is the results after we have put them in the correct
        # order.
        resultsList = [None] * len(newArgsTupleList)

        resultCount = 0
        while resultCount < len(newArgsTupleList):

            # Get a result.
            (argsTuple, resultDts) = resultQueue.get()
             
            argIndex = 0
            methodToRun = argsTuple[argIndex]
            argIndex += 1
            taskId = argsTuple[argIndex]
            argIndex += 1
            planetName = argsTuple[argIndex]
            argIndex += 1
            centricityType = argsTuple[argIndex]
            argIndex += 1
            longitudeType = argsTuple[argIndex]
            argIndex += 1
            referenceDt = argsTuple[argIndex]
            argIndex += 1
            desiredDeltaDegrees = argsTuple[argIndex]
            argIndex += 1
            maxErrorTd = argsTuple[argIndex]
            argIndex += 1
            locationLongitudeDegrees = argsTuple[argIndex]
            argIndex += 1
            locationLatitudeDegrees = argsTuple[argIndex]
            argIndex += 1
            locationElevationMeters = argsTuple[argIndex]
            argIndex += 1
            

            # Place the resultDts in the correct place.
            resultsList[taskId] = resultDts

            # Debug output.
            if self.log.isEnabledFor(logging.DEBUG) == True:
                endl = os.linesep
                argsTupleStr = \
                    "methodToRun == {}".format(methodToRun) + endl + \
                    "taskId == {}".format(taskId) + endl + \
                    "planetName == {}".format(planetName) + endl + \
                    "centricityType == {}".format(centricityType) + endl + \
                    "longitudeType == {}".format(longitudeType) + endl + \
                    "referenceDt == {}".format(referenceDt) + endl + \
                    "desiredDeltaDegrees == {}".\
                    format(desiredDeltaDegrees) + endl + \
                    "maxErrorTd == {}".format(maxErrorTd) + endl + \
                    "locationLongitudeDegrees == {}".\
                    format(locationLongitudeDegrees) + endl + \
                    "locationLatitudeDegrees == {}".\
                    format(locationLatitudeDegrees) + endl + \
                    "locationElevationMeters == {}".\
                    format(locationElevationMeters)
    
                self.log.debug("Obtained result: " + \
                          "argsTuple == {}, ".format(argsTuple) + 
                          "len(resultDts) == {}".format(len(resultDts)))
                for i in range(len(resultDts)):
                    dt = resultDts[i]
                    self.log.debug("  resultDts[{}] == {}".format(i, dt))

            # Notify that the consumption of this result is complete.
            resultQueue.task_done()

            resultCount += 1
            if self.log.isEnabledFor(logging.DEBUG) == True:
                self.log.debug("We have consumed {} total results now.".\
                          format(resultCount))
    
        self.log.info("Done consuming all tasks submitted.") 
        return resultsList

    def clearAllLookbackMultiplePriceBars(self):
        """Causes the removal of all LookbackMultiplePriceBarGraphicsItems.
        
        Note: This clearing does not cause a priceBarChartChanged signal
        to be emitted.  That is because LookbackMultiplePriceBars are
        transient and are not persisted.  They get redrawn frequently, 
        and where they are drawn are highly dependent on the user's current 
        view.
        """

        self.log.debug("Entered clearAllLookbackMultiplePriceBars()")
        
        # Go through all the QGraphicsItems and remove the artifact items.
        graphicsItems = self.graphicsScene.items()

        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):

                debugStr = \
                    "Removing LookbackMultiplePriceBarGraphicsItem for " + \
                    "LookbackMultiplePriceBar: " + \
                    item.getLookbackMultiplePriceBar().toString()
                self.log.debug(debugStr)
                               
                if item.scene() != None:
                    self.graphicsScene.removeItem(item)
                
        self.log.debug("Exiting clearAllLookbackMultiplePriceBars()")

    def applyPriceBarChartSettings(self, priceBarChartSettings):
        """Applies the settings in the given PriceBarChartSettings object.
        """
        
        self.log.debug("Entering applyPriceBarChartSettings()")

        self.priceBarChartSettings = priceBarChartSettings

        # Save a reference to the current PriceBarChartSettings in the
        # QGraphicsView.  This is used when the user creates new chart
        # artificats at run time.
        self.graphicsView.setPriceBarChartSettings(self.priceBarChartSettings)

        # Flag to indicate if the settings has changed because we
        # corrected an invalid settings field and the settings needs
        # to be re-saved.
        settingsChangedFlag = False

        self.log.debug("Applying QGraphicsView scaling...")

        numScalings = \
            len(self.priceBarChartSettings.priceBarChartGraphicsViewScalings)

        # Get the index for which scaling we should apply.
        currScalingIndex = \
            self.priceBarChartSettings.priceBarChartGraphicsViewScalingsIndex

        # Temporary variable holding the PriceBarChartScaling scaling
        # object to use.
        scaling = PriceBarChartScaling()

        if numScalings >= 1:
            
            if currScalingIndex < 0 or currScalingIndex >= numScalings:
                # Use the first scaling in the list.
                currScalingIndex = 0
                self.priceBarChartSettings.\
                    priceBarChartGraphicsViewScalingsIndex = 0

                settingsChangedFlag = True

            # Use the scaling at index currScalingIndex.
            scaling = \
                self.priceBarChartSettings.\
                    priceBarChartGraphicsViewScalings[currScalingIndex]

        elif numScalings == 0:
            # There are no scalings in the list.  

            # Create a scaling containing the identity matrix, and then
            # add it to the array and then use that scaling.
            scaling = PriceBarChartScaling()
            scaling.name = "Default"

            self.priceBarChartSettings.\
                priceBarChartGraphicsViewScalings.append(scaling)

            self.priceBarChartSettings.\
                priceBarChartGraphicsViewScalingsIndex = 0

            settingsChangedFlag = True

        # Give the scaling to the QGraphicsScene so that it is
        # available for scaling-related calculations that some of the
        # graphics items/indicators.
        self.graphicsScene.setScaling(scaling)
        
        # Create a new QTransform that holds the scaling we want
        # but preserve the translation and other parts of the
        # transform from what is currently displayed in the
        # QGraphicsView.

        # Get the current QTransform.
        transform = self.graphicsView.transform()

        # Get the QTransform that has the desired scaling from the
        # PriceBarChartSettings.
        scalingTransform = scaling.getTransform()

        # Create a new QTransform that has elements of both.
        newTransform = QTransform(scalingTransform.m11(),
                                  transform.m12(),
                                  transform.m13(),
                                  transform.m21(),
                                  scalingTransform.m22(),
                                  transform.m23(),
                                  transform.m31(),
                                  transform.m32(),
                                  transform.m33())

        # Apply the transform.
        self.graphicsView.setTransform(newTransform)

        # Apply the settings on all the existing relevant QGraphicsItems.
        graphicsItems = self.graphicsScene.items()
        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):
                self.log.debug("Applying settings to PriceBarGraphicsItem.")
                item.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
            elif isinstance(item, BarCountGraphicsItem):
                self.log.debug("Applying settings to BarCountGraphicsItem.")
                item.loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
            elif isinstance(item, TimeMeasurementGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "TimeMeasurementGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.recalculateTimeMeasurement()
            elif isinstance(item, TimeModalScaleGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "TimeModalScaleGraphicsItem.")
            elif isinstance(item, PriceModalScaleGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "PriceModalScaleGraphicsItem.")
            elif isinstance(item, PlanetLongitudeMovementMeasurementGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "PlanetLongitudeMovementMeasurementGraphicsItem.")
            elif isinstance(item, TextGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "TextGraphicsItem.")
            elif isinstance(item, PriceTimeInfoGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "PriceTimeInfoGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.recalculatePriceTimeInfo()
            elif isinstance(item, PriceMeasurementGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "PriceMeasurementGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.recalculatePriceMeasurement()
            elif isinstance(item, TimeRetracementGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "TimeRetracementGraphicsItem.")
            elif isinstance(item, PriceRetracementGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "PriceRetracementGraphicsItem.")
            elif isinstance(item, PriceTimeVectorGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "PriceTimeVectorGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.recalculatePriceTimeVector()
            elif isinstance(item, LineSegmentGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "LineSegmentGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.recalculateLineSegment()
            elif isinstance(item, VerticalLineSegmentGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "VerticalLineSegmentGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.recalculateVerticalLineSegment()
            elif isinstance(item, HorizontalLineSegmentGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "HorizontalLineSegmentGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.recalculateHorizontalLineSegment()
            elif isinstance(item, OctaveFanGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "OctaveFanGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.refreshItem()
            elif isinstance(item, FibFanGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "FibFanGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.refreshItem()
            elif isinstance(item, GannFanGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "GannFanGraphicsItem.")
                # Redo calculations in case the scaling changed.
                item.refreshItem()
            elif isinstance(item, VimsottariDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "VimsottariDasaGraphicsItem.")
            elif isinstance(item, AshtottariDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "AshtottariDasaGraphicsItem.")
            elif isinstance(item, YoginiDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "YoginiDasaGraphicsItem.")
            elif isinstance(item, DwisaptatiSamaDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "DwisaptatiSamaDasaGraphicsItem.")
            elif isinstance(item, ShattrimsaSamaDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "ShattrimsaSamaDasaGraphicsItem.")
            elif isinstance(item, DwadasottariDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "DwadasottariDasaGraphicsItem.")
            elif isinstance(item, ChaturaseetiSamaDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "ChaturaseetiSamaDasaGraphicsItem.")
            elif isinstance(item, SataabdikaDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "SataabdikaDasaGraphicsItem.")
            elif isinstance(item, ShodasottariDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "ShodasottariDasaGraphicsItem.")
            elif isinstance(item, PanchottariDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "PanchottariDasaGraphicsItem.")
            elif isinstance(item, ShashtihayaniDasaGraphicsItem):
                self.log.debug("Not applying settings to " +
                               "ShashtihayaniDasaGraphicsItem.")
                
        if settingsChangedFlag == True:
            # Emit that the PriceBarChart has changed, because we have
            # updated the PriceBarChartSettings.
            self.priceBarChartChanged.emit()

        self.log.debug("Exiting applyPriceBarChartSettings()")

    def getPriceBarChartSettings(self):
        """Returns the current settings used in this PriceBarChartWidget."""
        
        return self.priceBarChartSettings

    def toReadOnlyPointerToolMode(self):
        """Changes the tool mode to be the ReadOnlyPointerTool."""

        self.log.debug("Entered toReadOnlyPointerToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartWidget.ToolMode['ReadOnlyPointerTool']:

            self.toolMode = \
                PriceBarChartWidget.ToolMode['ReadOnlyPointerTool']
            self.graphicsView.toReadOnlyPointerToolMode()

        self.log.debug("Exiting toReadOnlyPointerToolMode()")

    def toPointerToolMode(self):
        """Changes the tool mode to be the PointerTool."""

        self.log.debug("Entered toPointerToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['PointerTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['PointerTool']
            self.graphicsView.toPointerToolMode()

        self.log.debug("Exiting toPointerToolMode()")

    def toHandToolMode(self):
        """Changes the tool mode to be the HandTool."""

        self.log.debug("Entered toHandToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['HandTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['HandTool']
            self.graphicsView.toHandToolMode()

        self.log.debug("Exiting toHandToolMode()")

    def toZoomInToolMode(self):
        """Changes the tool mode to be the ZoomInTool."""

        self.log.debug("Entered toZoomInToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['ZoomInTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['ZoomInTool']
            self.graphicsView.toZoomInToolMode()

        self.log.debug("Exiting toZoomInToolMode()")

    def toZoomOutToolMode(self):
        """Changes the tool mode to be the ZoomOutTool."""

        self.log.debug("Entered toZoomOutToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['ZoomOutTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['ZoomOutTool']
            self.graphicsView.toZoomOutToolMode()

        self.log.debug("Exiting toZoomOutToolMode()")

    def toBarCountToolMode(self):
        """Changes the tool mode to be the BarCountTool."""

        self.log.debug("Entered toBarCountToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['BarCountTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['BarCountTool']
            self.graphicsView.toBarCountToolMode()

        self.log.debug("Exiting toBarCountToolMode()")

    def toTimeMeasurementToolMode(self):
        """Changes the tool mode to be the TimeMeasurementTool."""

        self.log.debug("Entered toTimeMeasurementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['TimeMeasurementTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['TimeMeasurementTool']
            self.graphicsView.toTimeMeasurementToolMode()

        self.log.debug("Exiting toTimeMeasurementToolMode()")

    def toTimeModalScaleToolMode(self):
        """Changes the tool mode to be the TimeModalScaleTool."""

        self.log.debug("Entered toTimeModalScaleToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['TimeModalScaleTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['TimeModalScaleTool']
            self.graphicsView.toTimeModalScaleToolMode()

        self.log.debug("Exiting toTimeModalScaleToolMode()")

    def toPriceModalScaleToolMode(self):
        """Changes the tool mode to be the PriceModalScaleTool."""

        self.log.debug("Entered toPriceModalScaleToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['PriceModalScaleTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['PriceModalScaleTool']
            self.graphicsView.toPriceModalScaleToolMode()

        self.log.debug("Exiting toPriceModalScaleToolMode()")

    def toPlanetLongitudeMovementMeasurementToolMode(self):
        """Changes the tool mode to be the PlanetLongitudeMovementMeasurementTool."""

        self.log.debug("Entered toPlanetLongitudeMovementMeasurementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['PlanetLongitudeMovementMeasurementTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['PlanetLongitudeMovementMeasurementTool']
            self.graphicsView.toPlanetLongitudeMovementMeasurementToolMode()

        self.log.debug("Exiting toPlanetLongitudeMovementMeasurementToolMode()")

    def toTextToolMode(self):
        """Changes the tool mode to be the TextTool."""

        self.log.debug("Entered toTextToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['TextTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['TextTool']
            self.graphicsView.toTextToolMode()

        self.log.debug("Exiting toTextToolMode()")

    def toPriceTimeInfoToolMode(self):
        """Changes the tool mode to be the PriceTimeInfoTool."""

        self.log.debug("Entered toPriceTimeInfoToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['PriceTimeInfoTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['PriceTimeInfoTool']
            self.graphicsView.toPriceTimeInfoToolMode()

        self.log.debug("Exiting toPriceTimeInfoToolMode()")

    def toPriceMeasurementToolMode(self):
        """Changes the tool mode to be the PriceMeasurementTool."""

        self.log.debug("Entered toPriceMeasurementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['PriceMeasurementTool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['PriceMeasurementTool']
            self.graphicsView.toPriceMeasurementToolMode()

        self.log.debug("Exiting toPriceMeasurementToolMode()")

    def toTimeRetracementToolMode(self):
        """Changes the tool mode to be the TimeRetracementTool."""

        self.log.debug("Entered toTimeRetracementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['TimeRetracementTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['TimeRetracementTool']
            self.graphicsView.toTimeRetracementToolMode()

        self.log.debug("Exiting toTimeRetracementToolMode()")

    def toPriceRetracementToolMode(self):
        """Changes the tool mode to be the PriceRetracementTool."""

        self.log.debug("Entered toPriceRetracementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['PriceRetracementTool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['PriceRetracementTool']
            self.graphicsView.toPriceRetracementToolMode()

        self.log.debug("Exiting toPriceRetracementToolMode()")

    def toPriceTimeVectorToolMode(self):
        """Changes the tool mode to be the PriceTimeVectorTool."""

        self.log.debug("Entered toPriceTimeVectorToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['PriceTimeVectorTool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['PriceTimeVectorTool']
            self.graphicsView.toPriceTimeVectorToolMode()

        self.log.debug("Exiting toPriceTimeVectorToolMode()")

    def toLineSegment1ToolMode(self):
        """Changes the tool mode to be the LineSegment1Tool."""

        self.log.debug("Entered toLineSegment1ToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['LineSegment1Tool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['LineSegment1Tool']
            self.graphicsView.toLineSegment1ToolMode()

        self.log.debug("Exiting toLineSegment1ToolMode()")

    def toLineSegment2ToolMode(self):
        """Changes the tool mode to be the LineSegment2Tool."""

        self.log.debug("Entered toLineSegment2ToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['LineSegment2Tool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['LineSegment2Tool']
            self.graphicsView.toLineSegment2ToolMode()

        self.log.debug("Exiting toLineSegment2ToolMode()")

    def toVerticalLineSegmentToolMode(self):
        """Changes the tool mode to be the VerticalLineSegmentTool."""

        self.log.debug("Entered toVerticalLineSegmentToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['VerticalLineSegmentTool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['VerticalLineSegmentTool']
            self.graphicsView.toVerticalLineSegmentToolMode()

        self.log.debug("Exiting toVerticalLineSegmentToolMode()")

    def toHorizontalLineSegmentToolMode(self):
        """Changes the tool mode to be the HorizontalLineSegmentTool."""

        self.log.debug("Entered toHorizontalLineSegmentToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['HorizontalLineSegmentTool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['HorizontalLineSegmentTool']
            self.graphicsView.toHorizontalLineSegmentToolMode()

        self.log.debug("Exiting toHorizontalLineSegmentToolMode()")

    def toOctaveFanToolMode(self):
        """Changes the tool mode to be the OctaveFanTool."""

        self.log.debug("Entered toOctaveFanToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['OctaveFanTool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['OctaveFanTool']
            self.graphicsView.toOctaveFanToolMode()

        self.log.debug("Exiting toOctaveFanToolMode()")

    def toFibFanToolMode(self):
        """Changes the tool mode to be the FibFanTool."""

        self.log.debug("Entered toFibFanToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['FibFanTool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['FibFanTool']
            self.graphicsView.toFibFanToolMode()

        self.log.debug("Exiting toFibFanToolMode()")

    def toGannFanToolMode(self):
        """Changes the tool mode to be the GannFanTool."""

        self.log.debug("Entered toGannFanToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['GannFanTool']:
            
            self.toolMode = PriceBarChartWidget.ToolMode['GannFanTool']
            self.graphicsView.toGannFanToolMode()

        self.log.debug("Exiting toGannFanToolMode()")

    def toVimsottariDasaToolMode(self):
        """Changes the tool mode to be the VimsottariDasaTool."""

        self.log.debug("Entered toVimsottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['VimsottariDasaTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['VimsottariDasaTool']
            self.graphicsView.toVimsottariDasaToolMode()

        self.log.debug("Exiting toVimsottariDasaToolMode()")

    def toAshtottariDasaToolMode(self):
        """Changes the tool mode to be the AshtottariDasaTool."""

        self.log.debug("Entered toAshtottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['AshtottariDasaTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['AshtottariDasaTool']
            self.graphicsView.toAshtottariDasaToolMode()

        self.log.debug("Exiting toAshtottariDasaToolMode()")

    def toYoginiDasaToolMode(self):
        """Changes the tool mode to be the YoginiDasaTool."""

        self.log.debug("Entered toYoginiDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartWidget.ToolMode['YoginiDasaTool']:
            self.toolMode = PriceBarChartWidget.ToolMode['YoginiDasaTool']
            self.graphicsView.toYoginiDasaToolMode()

        self.log.debug("Exiting toYoginiDasaToolMode()")

    def toDwisaptatiSamaDasaToolMode(self):
        """Changes the tool mode to be the DwisaptatiSamaDasaTool."""

        self.log.debug("Entered toDwisaptatiSamaDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['DwisaptatiSamaDasaTool']:
            
            self.toolMode = \
                PriceBarChartWidget.ToolMode['DwisaptatiSamaDasaTool']
            self.graphicsView.toDwisaptatiSamaDasaToolMode()

        self.log.debug("Exiting toDwisaptatiSamaDasaToolMode()")

    def toShattrimsaSamaDasaToolMode(self):
        """Changes the tool mode to be the ShattrimsaSamaDasaTool."""

        self.log.debug("Entered toShattrimsaSamaDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['ShattrimsaSamaDasaTool']:
            
            self.toolMode = \
                PriceBarChartWidget.ToolMode['ShattrimsaSamaDasaTool']
            self.graphicsView.toShattrimsaSamaDasaToolMode()

        self.log.debug("Exiting toShattrimsaSamaDasaToolMode()")

    def toDwadasottariDasaToolMode(self):
        """Changes the tool mode to be the DwadasottariDasaTool."""

        self.log.debug("Entered toDwadasottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['DwadasottariDasaTool']:
            
            self.toolMode = \
                PriceBarChartWidget.ToolMode['DwadasottariDasaTool']
            self.graphicsView.toDwadasottariDasaToolMode()

        self.log.debug("Exiting toDwadasottariDasaToolMode()")

    def toChaturaseetiSamaDasaToolMode(self):
        """Changes the tool mode to be the ChaturaseetiSamaDasaTool."""

        self.log.debug("Entered toChaturaseetiSamaDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['ChaturaseetiSamaDasaTool']:
            
            self.toolMode = \
                PriceBarChartWidget.ToolMode['ChaturaseetiSamaDasaTool']
            self.graphicsView.toChaturaseetiSamaDasaToolMode()

        self.log.debug("Exiting toChaturaseetiSamaDasaToolMode()")

    def toSataabdikaDasaToolMode(self):
        """Changes the tool mode to be the SataabdikaDasaTool."""

        self.log.debug("Entered toSataabdikaDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['SataabdikaDasaTool']:
            
            self.toolMode = \
                PriceBarChartWidget.ToolMode['SataabdikaDasaTool']
            self.graphicsView.toSataabdikaDasaToolMode()

        self.log.debug("Exiting toSataabdikaDasaToolMode()")

    def toShodasottariDasaToolMode(self):
        """Changes the tool mode to be the ShodasottariDasaTool."""

        self.log.debug("Entered toShodasottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['ShodasottariDasaTool']:
            
            self.toolMode = \
                PriceBarChartWidget.ToolMode['ShodasottariDasaTool']
            self.graphicsView.toShodasottariDasaToolMode()

        self.log.debug("Exiting toShodasottariDasaToolMode()")

    def toPanchottariDasaToolMode(self):
        """Changes the tool mode to be the PanchottariDasaTool."""

        self.log.debug("Entered toPanchottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['PanchottariDasaTool']:
            
            self.toolMode = \
                PriceBarChartWidget.ToolMode['PanchottariDasaTool']
            self.graphicsView.toPanchottariDasaToolMode()

        self.log.debug("Exiting toPanchottariDasaToolMode()")

    def toShashtihayaniDasaToolMode(self):
        """Changes the tool mode to be the ShashtihayaniDasaTool."""

        self.log.debug("Entered toShashtihayaniDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
               PriceBarChartWidget.ToolMode['ShashtihayaniDasaTool']:
            
            self.toolMode = \
                PriceBarChartWidget.ToolMode['ShashtihayaniDasaTool']
            self.graphicsView.toShashtihayaniDasaToolMode()

        self.log.debug("Exiting toShashtihayaniDasaToolMode()")

    def _handleMouseLocationUpdate(self, x, y):
        """Handles mouse location changes in the QGraphicsView.  
        Arguments:

        x - float value of the mouse's X coordinate position, in scene
        coordinates.
        y - float value of the mouse's Y coordinate position, in scene
        coordinates.
        """

        # Update labels that tell where the mouse pointer is.
        self.updateMouseLocationLabels(x, y)

        # Emit a signal so that other widgets/entities can know
        # the timestamp where the mouse pointer is.
        dt = self.graphicsScene.sceneXPosToDatetime(x)
        self.currentTimestampChanged.emit(dt)

    def _handleSelectionChanged(self):
        """Handles when the QGraphicsScene has it's selection of
        QGraphicsItems changed.

        This function obtains the selected items, and if there is only
        one PriceBarGraphicsItem selected, then it displays the
        information about that pricebar in the labels at the top of
        the widget.
        """

        selectedItems = self.graphicsScene.selectedItems()

        numPriceBarGraphicsItemsSelected = 0
        lastPriceBarGraphicsItem = None
        
        for item in selectedItems:
            if isinstance(item, PriceBarGraphicsItem):
                numPriceBarGraphicsItemsSelected += 1
                lastPriceBarGraphicsItem = item

        self.log.debug("Number of PriceBarGraphicsItems selected is: {}".\
                       format(numPriceBarGraphicsItemsSelected))

        # Only update the labels with price/time information if there
        # was only one PriceBarGraphicsItem selected.  This is done to
        # avoid confusion in the event that a second
        # PriceBarGraphicsItem is selected and the user didn't notice
        # that it was (to prevent the wrong information from being
        # interpreted).
        if numPriceBarGraphicsItemsSelected == 1:
            priceBar = lastPriceBarGraphicsItem.getPriceBar()
            self.updateSelectedPriceBarLabels(priceBar)
        else:
            self.updateSelectedPriceBarLabels(None)
            

    def _scaleLookbackMultiplePriceBarPrice(self, 
                                            highestViewPrice,
                                            lowestViewPrice,
                                            highestPriceBarPrice,
                                            lowestPriceBarPrice,
                                            priceBarPriceToScale):

        """Helper function for LookbackMultiple to calculate a scaled
        price value.

        The price value to scale is the 'priceBarPriceToScale' value,
        and this method will return a new price that is that value
        scaled according to the QGraphicsView's price range.

        This method helps us by allowing us to place 
        LookbackMultiplePriceBars/LookbackMultiplePriceBarGraphicsItems 
        into the QGraphicsScene at locations that will fit nicely 
        within the visible portion of the QGraphicsView.

        Arguments:
        highestViewPrice - float value holding the highest price 
                           that is visible within the QGraphicsView.

        lowestViewPrice - float value holding the lowest price 
                          that is visible within the QGraphicsView.

        highestPriceBarPrice - float value holding the highest price within
                               all the pricebars in the set that is 
                               being analyzed.

        lowestPriceBarPrice - float value holding the lowest price within
                              all the pricebars in the set that is 
                              being analyzed.

        priceBarPriceToScale - float value that contains the 
                               price before scaling.  This value is 
                               converted to a new price via scaling.
        """

        debugLogEnabled = False
        if self.log.isEnabledFor(logging.DEBUG) == True:
            debugLogEnabled = True

        # Override the debugLogEnabled flag.
        debugLogEnabled = False

        if debugLogEnabled == True:
            self.log.debug("Entered _scaleLookbackMultiplePriceBarPrice()")
    
            self.log.debug("highestViewPrice == {}".format(highestViewPrice))
            self.log.debug("lowestViewPrice  == {}".format(lowestViewPrice))
            self.log.debug("highestPriceBarPrice == {}".\
                           format(highestPriceBarPrice))
            self.log.debug("lowestPriceBarPrice == {}".\
                           format(lowestPriceBarPrice))
            self.log.debug("priceBarPriceToScale == {}".\
                           format(priceBarPriceToScale))


        viewPriceRange = highestViewPrice - lowestViewPrice

        if debugLogEnabled == True:
            self.log.debug("viewPriceRange  == {}".\
                           format(viewPriceRange))

        priceBarPriceRange = highestPriceBarPrice - lowestPriceBarPrice

        if debugLogEnabled == True:
            self.log.debug("priceBarPriceRange == {}".\
                           format(priceBarPriceRange))
            
        ratioOfPriceRange = \
            (priceBarPriceToScale - lowestPriceBarPrice) / priceBarPriceRange

        if debugLogEnabled == True:
            self.log.debug("ratioOfPriceRange == {}".format(ratioOfPriceRange))

        newViewPrice = (ratioOfPriceRange * viewPriceRange) + lowestViewPrice

        if debugLogEnabled == True:
            self.log.debug("newViewPrice == {}".format(newViewPrice))
            self.log.debug("Exiting _scaleLookbackMultiplePriceBarPrice()")

        return newViewPrice


class PriceBarChartGraphicsScene(QGraphicsScene):
    """QGraphicsScene holding all the pricebars and artifacts.
    We inherit QGraphicsScene to allow for future feature additions.
    """

    # Signal emitted when there is an addition of a
    # PriceBarChartArtifactGraphicsItem.
    priceBarChartArtifactGraphicsItemAdded = \
        QtCore.pyqtSignal(PriceBarChartArtifactGraphicsItem)
        
    # Signal emitted when there is a removal of a
    # PriceBarChartArtifactGraphicsItem.
    priceBarChartArtifactGraphicsItemRemoved = \
        QtCore.pyqtSignal(PriceBarChartArtifactGraphicsItem)

    # Signal emitted when there is an addition or removal of a
    # PriceBarChartArtifactGraphicsItem.
    priceBarChartChanged = QtCore.pyqtSignal()

    # Signal emitted when a status message should be printed.
    statusMessageUpdate = QtCore.pyqtSignal(str)
    
    # Signal emitted when the user desires to change astro chart 1.
    astroChart1Update = QtCore.pyqtSignal(datetime.datetime)
    
    # Signal emitted when the user desires to change astro chart 2.
    astroChart2Update = QtCore.pyqtSignal(datetime.datetime)
    
    # Signal emitted when the user desires to change astro chart 3.
    astroChart3Update = QtCore.pyqtSignal(datetime.datetime)

    # Signal emitted when the user desires to view a datetime.datetime
    # in JHora.
    jhoraLaunch = QtCore.pyqtSignal(datetime.datetime)
    
    # Signal emitted when the user desires to view a datetime.datetime
    # in Astrolog.
    astrologLaunch = QtCore.pyqtSignal(datetime.datetime)


    def __init__(self, parent=None):
        """Pass-through to the QGraphicsScene constructor."""

        super().__init__(parent)
        
        # Logger
        self.log = logging.getLogger("pricebarchart.PriceBarChartGraphicsScene")

        # Flag to enable the conversion algorithm utilizing CBOT intraday
        # minute bars stacked together (to only display active trading hours).
        self.cbotIntradayStackedBarsEnabled = False

        # Flag to enable the conversion algorithm utilizing NYSE intraday
        # minute bars stacked together (to only display active trading hours).
        self.nyseIntradayStackedBarsEnabled = False

        # Flag to enable the conversion algorithm utilizing trading
        # days only.  (Monday through Friday, weekends ignored).
        self.ignoreWeekendsEnabled = False
        #self.ignoreWeekendsEnabled = True

        # Holds the scaling object which is used for scaling-related
        # calculations.
        self.scaling = PriceBarChartScaling()
        
        # Holds the BirthInfo object.  This is used in calculating
        # information related to astrology.
        self.birthInfo = None
        
        # Holds the timezone as a datetime.tzinfo object.  This is
        # used in conversions of scene position X value to
        # datetime.datetime.
        self.timezone = pytz.utc

        # Set the indexing method to be QGraphicsScene.NoIndex.
        # We need to do this to prevent segmentation faults in Qt's
        # use of a BspTreeIndex.
        self.setItemIndexMethod(QGraphicsScene.NoIndex)

        # Holds references to the highest, lowest, earliest and latest
        # PriceBars.  This is so we don't re-compute it every time we
        # need it.  The values are set when PriceBars are loaded or cleared.
        self.highestPriceBar = None
        self.lowestPriceBar = None
        self.earliestPriceBar = None
        self.latestPriceBar = None
        
        # Adding or removing an artifact graphics item counts as
        # something changed.
        self.priceBarChartArtifactGraphicsItemAdded.\
            connect(self.priceBarChartChanged)
        self.priceBarChartArtifactGraphicsItemRemoved.\
            connect(self.priceBarChartChanged)

    def setScaling(self, scaling):
        """Sets the PriceBarChartScaling scaling object used for this
        trading entity.  This scaling object is used for various
        scaling-related calculations.  This function does not apply
        scaling to the QGraphicsView.
        """

        self.scaling = scaling

    def getScaling(self):
        """Returns PriceBarChartScaling object being used for scaling.
        """

        return self.scaling
    
    def setBirthInfo(self, birthInfo):
        """Sets the birth info for this trading entity.
        
        Arguments:

        birthInfo - BirthInfo object.
        """

        self.birthInfo = birthInfo

        # Go through all the current items, and for every time that
        # needs a current BirthInfo, then set the birthInfo in that
        # item.

        graphicsItems = self.items()
        for item in graphicsItems:
            if isinstance(item, PriceTimeInfoGraphicsItem):
                # Setting birthInfo on this object will cause the
                # whole widget to update it's internal text and info
                # accordingly.
                item.setBirthInfo(self.birthInfo)

    def getBirthInfo(self):
        """Returns the birthInfo for this trading entity as a BirthInfo object.
        """

        return self.birthInfo
    
    def setTimezone(self, timezone):
        """Sets the timezone used.  This is used for converting mouse
        X location to a datetime.datetime object.
        
        Arguments:
            
        timezone - A datetime.tzinfo object holding the timezone for the
                   pricebars in this widget.
        """

        self.timezone = timezone

    def sceneXPosToJulianDay(self, sceneXPos):
        """Returns a float julian day for the given X position in
        scene coordinates.

        Arguments:

        sceneXPos - float value holding the X position in scene coordinates.

        Returns:
        float holding the julian day equivalent timestamp.
        """

        if self.cbotIntradayStackedBarsEnabled == True:
            # Epoc datetime.
            # If this is changed, it must match the baseline value
            # used in julianDayToSceneXPos().
            baseline = datetime.datetime(year=1968, month=1, day=1,
                                         hour=0, minute=0, second=0,
                                         tzinfo=self.timezone)
            
            # tradingDay is set to hours in a trading day, as a part of a
            # whole day.  I.e.   17 trading hours / 24 hours == 0.708333.
            tradingDay = 0.70833333333
            totalTradingDayHours = 17.0
            
            flooredSceneXPos = math.floor(sceneXPos)
            fractionalPortion = sceneXPos - flooredSceneXPos
            
            td = datetime.timedelta(days=flooredSceneXPos)
            dt = baseline + td

            jd = Ephemeris.datetimeToJulianDay(dt)
            
            if 0.0 <= fractionalPortion < 0.4264705882352941:
                # In range: [00:00, 07:15).
                hours = fractionalPortion * totalTradingDayHours
                partOfDayJd = hours / 24
                
                jd += partOfDayJd
                 
            elif 0.4264705882352941 <= fractionalPortion < 0.6470588235294118:
                # In range: [09:30, 13:15).
                hours = fractionalPortion * totalTradingDayHours

                # Numer of hours in range [07:15, 09:30) where no
                # trading happens.
                closedMarketDuration = 9.5 - 7.25
                
                partOfDayJd = (closedMarketDuration + hours) / 24
                
                jd += partOfDayJd
                 
            elif 0.6470588235294118 <= fractionalPortion < 1.0:
                # In range: [18:00, 24:00).

                # Numer of hours in range [13:15, 18:00) where no
                # trading happens.
                closedMarketDuration = 18.0 - 13.25
                
                # Hours between 
                hours = fractionalPortion * totalTradingDayHours
                partOfDayJd = (closedMarketDuration + hours) / 24

                jd += partOfDayJd
                 
            else:
                # Should never get here.
                raise ValueError("Invalid part of day: {}".format(partOfDay))
            
        elif self.nyseIntradayStackedBarsEnabled == True:
            # Epoc datetime.
            # If this is changed, it must match the baseline value
            # used in julianDayToSceneXPos().
            baseline = datetime.datetime(year=1968, month=1, day=1,
                                         hour=0, minute=0, second=0,
                                         tzinfo=self.timezone)
            
            # tradingDay is set to hours in a trading day, as a part of a
            # whole day.
            #
            # Since we get pricebar timestamps at both 9:30 and 16:00,
            # the total duration we'll use is not quite 6.5 hours, but
            # one extra minute about that.
            #
            # Thus, we use: 6.5 hours * 60 minutes + 1 = 391 minutes.
            # 
            # So for the trading day:
            # (391 minutes / 60) / 24 hours == 0.27152777777777776.
            tradingDay = 0.27152777777777776
            totalTradingDayMinutes = (6.5 * 60) + 1
            totalTradingDayHours = totalTradingDayMinutes / 60.0
            
            flooredSceneXPos = math.floor(sceneXPos)
            fractionalPortion = sceneXPos - flooredSceneXPos
            
            td = datetime.timedelta(days=flooredSceneXPos)
            dt = baseline + td
            
            jd = Ephemeris.datetimeToJulianDay(dt)

            # The timestamps of the pricebars are always within the
            # range: [09:30, 16:01).
            # This is in range of a day [9.5, 16.00666666666666).
            hours = fractionalPortion * totalTradingDayHours
            
            # Numer of hours in range [00:00, 09:30) where no
            # trading happens.
            closedMarketDuration = 9.5 - 0.0
            
            partOfDayJd = (closedMarketDuration + hours) / 24
            
            jd += partOfDayJd
            
        elif self.ignoreWeekendsEnabled == True:
            # Set an arbitrary Monday at midnight as our epoc.
            epocDt = datetime.datetime(year=1900, month=1, day=1,
                                         hour=0, minute=0, second=0,
                                         tzinfo=self.timezone)
            epocJd = Ephemeris.datetimeToJulianDay(epocDt)

            # These values are floats.
            numWeeks = math.floor(sceneXPos / 5)
            julianDaysFromMondayMidnight = sceneXPos % 5

            # Do conversion to Julian Day.
            jd = epocJd + (numWeeks * 7) + julianDaysFromMondayMidnight
            
        else:
            # Julian day 2159350.5 is Jan 1, 1200.  (This is arbitrary.)
            epocOffset = 2159350.5
            jd = sceneXPos + epocOffset

        return jd

    def julianDayToSceneXPos(self, jd):
        """Returns the X position in scene coordinates that maps to
        the given julian day.

        Arguments:
        jd - float value holding the julian day timestamp.

        Returns:
        float value holding the X position in scene coordinates.
        """

        if self.cbotIntradayStackedBarsEnabled == True:
            # Epoc datetime.
            # If this is changed, it must match the baseline value
            # used in sceneXPosToJulianDay().
            baseline = datetime.datetime(year=1968, month=1, day=1,
                                         hour=0, minute=0, second=0,
                                         tzinfo=self.timezone)
            
            # tradingDay is set to hours in a trading day, as a part of a
            # whole day.  I.e.   17 trading hours / 24 hours == 0.708333.
            tradingDay = 0.70833333333
            totalTradingDayHours = 17.0
            
            dt = Ephemeris.julianDayToDatetime(jd, self.timezone)
            td = dt.utcoffset()
            
            secondsInDay = 86400
            fractionOfDayUtcOffset = \
                ((td.days * 3600 * 24) + td.seconds) / secondsInDay

            # This will yield a value in range [0.0, 1.0), for the
            # part of the day elapsed.
            #
            # The numbers used below are obtained via:
            # 1.0 day / 24 hours = 0.041666666666666664
            # 1.0 day / (24 hours * 60 min) = 0.0006944444444444444
            # 1.0 day / (24 hours * 60 min * 60 secs) = 0.00001157407407407407
            jdOfDayElapsed = \
                (dt.hour   * 0.041666666666666664) + \
                (dt.minute * 0.0006944444444444444) + \
                (dt.second * 0.00001157407407407407)
            
            partOfDay = jdOfDayElapsed
            
            fractionalPortion = 0.0

            # Scale up to fill the missing space.
            if 0.0 <= partOfDay < 0.3020833333333:
                # In range: [00:00, 07:15).
                hours = partOfDay * 24
                fractionalPortion = hours / totalTradingDayHours
        
            elif 0.3958333333333333 <= partOfDay < 0.5520833333333334:
                # In range: [09:30, 13:15).

                # Fractional part of the day that the market is closed.
                # 2.25 hours out of 24 hours.
                closedMarketPartOfDay = 2.25 / 24.0
                
                hours = (partOfDay - closedMarketPartOfDay) * 24
                fractionalPortion = hours / totalTradingDayHours
                
            elif 0.75 <= partOfDay < 1.0:
                # In range: [18:00, 24:00).

                # Fractional part of the day that the market is closed.
                # (2.25 hours + 4.75 hours) out of 24 hours.
                closedMarketPartOfDay = (2.25 + 4.75) / 24.0
                
                hours = (partOfDay - closedMarketPartOfDay) * 24
                fractionalPortion = hours / totalTradingDayHours
                
            else:
                # Invalid partOfDay.
                errMsg = \
                    "Julian day is not within normal trading hours.  " + \
                    "Value given was: {} or {}".\
                    format(jd, Ephemeris.julianDayToDatetime(jd, self.timezone))
                self.log.error(errMsg)
                raise ValueError(errMsg)
                fractionalPortion = 0.0

            dt = Ephemeris.julianDayToDatetime(jd, self.timezone)
            dt = dt.replace(hour=0, minute=0, second=0, microsecond=0)
            td = dt - baseline
            
            sceneXPos = td.days + fractionalPortion
            
        elif self.nyseIntradayStackedBarsEnabled == True:
            # Epoc datetime.
            # If this is changed, it must match the baseline value
            # used in sceneXPosToJulianDay().
            baseline = datetime.datetime(year=1968, month=1, day=1,
                                         hour=0, minute=0, second=0,
                                         tzinfo=self.timezone)
            
            # tradingDay is set to hours in a trading day, as a part of a
            # whole day.
            #
            # Since we get pricebar timestamps at both 9:30 and 16:00,
            # the total duration we'll use is not quite 6.5 hours, but
            # one extra minute about that.
            #
            # Thus, we use: 6.5 hours * 60 minutes + 1 = 391 minutes.
            # 
            # So for the trading day:
            # (391 minutes / 60) / 24 hours == 0.27152777777777776.
            tradingDay = 0.27152777777777776
            totalTradingDayMinutes = (6.5 * 60) + 1
            totalTradingDayHours = totalTradingDayMinutes / 60.0
            
            dt = Ephemeris.julianDayToDatetime(jd, self.timezone)
            td = dt.utcoffset()
            
            secondsInDay = 86400
            fractionOfDayUtcOffset = \
                ((td.days * 3600 * 24) + td.seconds) / secondsInDay

            # This will yield a value in range [0.0, 1.0), for the
            # part of the day elapsed.
            #
            # The numbers used below are obtained via:
            # 1.0 day / 24 hours = 0.041666666666666664
            # 1.0 day / (24 hours * 60 min) = 0.0006944444444444444
            # 1.0 day / (24 hours * 60 min * 60 secs) = 0.00001157407407407407
            jdOfDayElapsed = \
                (dt.hour   * 0.041666666666666664) + \
                (dt.minute * 0.0006944444444444444) + \
                (dt.second * 0.00001157407407407407)
            
            partOfDay = jdOfDayElapsed
            
            fractionalPortion = 0.0
            
            # Scale up to fill the missing space.
            if 0.0 <= partOfDay < 0.3958333333333333:
                # In range: [00:00, 09:30).
                errMsg = \
                    "Julian day is not within normal trading hours.  " + \
                    "Value given was: {} or {}".\
                    format(jd, Ephemeris.julianDayToDatetime(jd, self.timezone))
                self.log.error(errMsg)
                raise ValueError(errMsg)
                fractionalPortion = 0.0
            
            elif 0.3958333333333333 <= partOfDay < 0.6669444444444445:
                # In range: [09:30, 16:01).
                
                # Fractional part of the day that the market is closed.
                # 9.5 hours out of 24 hours.
                closedMarketPartOfDay = 9.5 / 24.0
                
                hours = (partOfDay - closedMarketPartOfDay) * 24
                fractionalPortion = hours / totalTradingDayHours
                
            elif 0.6669444444444445 <= partOfDay < 1.0:
                # In range: [16:01, 24:00).
                errMsg = \
                    "Julian day is not within normal trading hours.  " + \
                    "Value given was: {} or {}".\
                    format(jd, Ephemeris.julianDayToDatetime(jd, self.timezone))
                self.log.error(errMsg)
                raise ValueError(errMsg)
                fractionalPortion = 0.0
            else:
                # Invalid partOfDay.
                errMsg = \
                    "Julian day is not within normal trading hours.  " + \
                    "Value given was: {} or {}".\
                    format(jd, Ephemeris.julianDayToDatetime(jd, self.timezone))
                self.log.error(errMsg)
                raise ValueError(errMsg)
                fractionalPortion = 0.0
            
            dt = Ephemeris.julianDayToDatetime(jd, self.timezone)
            dt = dt.replace(hour=0, minute=0, second=0, microsecond=0)
            td = dt - baseline
            
            sceneXPos = td.days + fractionalPortion
            
        elif self.ignoreWeekendsEnabled == True:
            # Set an arbitrary Monday at midnight as our epoc.
            epocDt = datetime.datetime(year=1900, month=1, day=1,
                                         hour=0, minute=0, second=0,
                                         tzinfo=self.timezone)
            epocJd = Ephemeris.datetimeToJulianDay(epocDt)
            
            
            julianDaysFromMondayMidnight = jd - epocJd
            
            numWeeks = math.floor(julianDaysFromMondayMidnight / 7)
            tradingDaysFromMondayMidnight = julianDaysFromMondayMidnight % 7
            
            if tradingDaysFromMondayMidnight >= 5:
                errMsg = \
                    "Julian day is not a weekday trading day (M-F).  " + \
                    "Value given was: {} or {}".\
                    format(jd, Ephemeris.datetimeToDayStr(\
                    Ephemeris.julianDayToDatetime(jd, self.timezone)))
                self.log.error(errMsg)
                raise ValueError(errMsg)
            
            sceneXPos = (numWeeks * 5) + tradingDaysFromMondayMidnight
            
        else:
            # Julian day 2159350.5 is Jan 1, 1200.  (This is arbitrary.)
            epocOffset = 2159350.5
            sceneXPos = jd - epocOffset
            
        return sceneXPos
    
    def sceneXPosToDatetime(self, sceneXPos):
        """Returns a datetime.datetime object for the given X position in
        scene coordinates.

        Arguments:

        sceneXPos - float value holding the X position in scene coordinates.

        Returns:

        datetime.datetime object holding the timestamp of the input X
        position.  This datetime.datetime object has its timezone set to
        whatever was set in setTimezone() previously.  If nothing was set
        before, then the default timezone is pytz.utc.
        """

        jd = self.sceneXPosToJulianDay(sceneXPos)
        
        dt = Ephemeris.julianDayToDatetime(jd, self.timezone)

        return dt
    
    def sceneYPosToPrice(self, sceneYPos):
        """Returns a price value for the given Y position in scene
        coordinates.

        Arguments:

        sceneYPos - float value holding the Y position in scene
        coordinates.

        Returns:

        float value for the price that this Y position represents.
        """

        # Make sure I don't return a negative 0.0.
        if (sceneYPos != 0.0):
            return float(-1.0 * sceneYPos)
        else:
            return float(sceneYPos)

    def datetimeToSceneXPos(self, dt):
        """Returns the conversion from datetime.datetime object to what we
        chosen the X coordinate values to be.

        Arguments:

        dt - datetime.datetime object that holds a timestamp.

        Returns:

        float value for the X position that would match up with this timestamp.
        """

        jd = Ephemeris.datetimeToJulianDay(dt)
        sceneXPos = self.julianDayToSceneXPos(jd)
            
        return sceneXPos

    def priceToSceneYPos(self, price):
        """Returns the conversion from price to what we have chosen the Y
        coordinate values to be.

        Arguments:

        price - float value holding the price value.

        Returns:

        float value for the Y position that would match up with this price.
        """

        # Below ensures the value returned is not -0.0 (negative 0.0).
        if (price != 0.0):
            return float(-1.0 * price)
        else:
            return float(price)


    def convertPriceToScaledValue(self, price):
        """Converts the given price value to a scaled value,
        using the set scaling object.

        Arguments:
        price - float value for the price to convert to a scaled value.

        Returns:
        float value representing the scaled value of the given price.
        """

        scaledValue = price / self.scaling.getUnitsOfPrice()

        return scaledValue
        
    def convertScaledValueToPrice(self, scaledValue):
        """Converts the given scaled value to a price, using the set
        scaling object.

        Arguments:
        scaledValue - float value to convert to a price value.

        Returns:
        float value representing the price.
        """

        price = scaledValue * self.scaling.getUnitsOfPrice()

        return price
        
    def convertDatetimeToScaledValue(self, dt):
        """Converts the given datetime to the scaled value, using the
        set scaling object.  This returned value is the scaled value
        relative to the birth time in self.birthInfo.  

        Arguments:
        dt - datetime.datetime object for the timestamp to convert to
             a scaled value.

        Returns:
        float value representing the scaled value of the
        given timestamp, from the birth timestamp.
        """

        birthDatetime = self.getBirthDatetime()
        birthJd = Ephemeris.datetimeToJulianDay(birthDatetime)

        currDatetime = dt
        currJd = Ephemeris.datetimeToJulianDay(currDatetime)

        jdDiff = currJd - birthJd

        scaledValue = jdDiff / self.scaling.getUnitsOfTime()
        
        return scaledValue
        
    def convertScaledValueToDatetime(self, scaledValue, tzInfo=None):
        """Converts the given scaled value to it's equivalent datetime using the
        set scaling object.  

        Arguments:
        scaledValue - float value representing a scaled value that is to be
                      converted to a timestamp value.
        tzInfo - pytz.timezone object for the timezone to use for
                 the datetime object returned.  If tzInfo is None, then
                 the previously set timezone of this trading
                 entity (self.timezone) is used.

        Returns:
        datetime.datetime object representing the timestamp for the
        given scaled value.
        """

        birthDatetime = self.getBirthDatetime()
        birthJd = Ephemeris.datetimeToJulianDay(birthDatetime)
        
        jdDiff = scaledValue * self.scaling.getUnitsOfTime()
        jd = birthJd + jdDiff
        
        if tzInfo == None:
            tzInfo = self.timezone
            
        dt = Ephemeris.julianDayToDatetime(jd, tzInfo)

        return dt

    def getBirthPrice(self):
        """Returns the open price at birth.  We assume here that the
        first pricebar we have is the first pricebar of this trading
        entity.

        Returns:
        float value for the birth price.  0.0 is returned if
        there are no pricebars found.
        """

        openPrice = 0.0
        earliestPriceBar = self.getEarliestPriceBar()
        
        if earliestPriceBar != None:
            openPrice = earliestPriceBar.open

        return openPrice
        
    def getBirthDatetime(self, tzInfo=None):
        """Returns the datetime.datetime for the timestamp at birth.

        Arguments:
        tzInfo - pytz.timezone object that is the timezone to
                 return the datetime in.  If tzInfo is None,
                 then the previously set timezone of this
                 trading entity (self.timezone) is used.
        
        Returns:
        datetime.datetime for the birth timestamp.
        """

        birthInfo = self.birthInfo
        
        if tzInfo == None:
            tzInfo = self.timezone
        
        if self.birthInfo == None:
            self.log.warn("Birth info is not set.  " +
                          "Scaling calculations may not be accurate.")
                          
            birthInfo = BirthInfo()
            
        birthDatetime = birthInfo.getBirthUtcDatetime()
        birthJd = Ephemeris.datetimeToJulianDay(birthDatetime)
        dt = Ephemeris.julianDayToDatetime(birthJd, tzInfo)
        
        return dt
        
    def getBirthScaledPoint(self):
        """Returns a QPointF for the birth price and time, converted
        to independent unit values, and scaled appropriately using the
        self.scaling scaling object.

        There are two ways to set the Y for time:
          - Assume that the open price is the point.
          - Assume that zero price is this point.
        
        In this function, the first method is used.

        Returns:
        QPointF for the birth point in scaled unit-less values.
        """

        price = self.getBirthPrice()

        # Time at birth is assumed to be 0.
        jd = 0.0
        
        # Do scaling.
        scaledPriceValue = price / self.scaling.getUnitsOfPrice()
        scaledTimeValue = jd / self.scaling.getUnitsOfTime()

        return QPointF(scaledTimeValue, scaledPriceValue)

    def getBirthScaledPointOrigin(self):
        """Returns a QPointF for the birth price and time, converted
        to independent unit values, and scaled appropriately using the
        self.scaling scaling object.

        There are two ways to set the Y for time:
          - Assume that the open price is the point.
          - Assume that zero price is this point.
        
        In this function, the second method is used.
        
        Returns:
        QPointF for the birth point in scaled unit-less values.
        """

        # Regardless of scaling, the origin birth point will be (0, 0).
        return QPointF(0.0, 0.0)
        
    def convertScenePointToScaledPoint(self, pointF):
        """Converts the given QPointF from the QGraphicsScene to a
        scaled QPointF using the price and time scaling in
        self.scaling.  Scaled X is relative to the birth time.  Birth
        time is scaled X value 0.

        Arguments:
        pointF - QPointF object holding the QGraphicsScene point that
                 the caller wants to convert to a scaled QPointF.

        Returns:
        QPointF holding a scaled QPointF equivalent to the given input point.
        """

        sceneX = pointF.x()
        sceneY = pointF.y()

        # The below was originally used, but it doesn't work because
        # we get an exception when using high scaling values:
        #
        # ValueError: year is out of range
        #
        #dt = self.sceneXPosToDatetime(sceneX)
        #price = self.sceneYPosToPrice(sceneY)
        #scaledX = self.convertDatetimeToScaledValue(dt)
        #scaledY = self.convertPriceToScaledValue(price)

        # Instead, we will just do the multiply ourselves, manually,
        # and not use the ephemeris.
        
        # Determine the scaled X value.
        birthDatetime = self.getBirthDatetime()
        birthJd = Ephemeris.datetimeToJulianDay(birthDatetime)
        currJd = self.sceneXPosToJulianDay(sceneX)
        jdDiff = currJd - birthJd
        scaledX = jdDiff / self.scaling.getUnitsOfTime()
        
        # Determine the scaled Y value.
        scaledY = sceneY / self.scaling.getUnitsOfPrice()
        
        return QPointF(scaledX, scaledY)

    def convertScaledPointToScenePoint(self, pointF):
        """Converts the given QPoint as a scaled QPointF, to a QPointF
        that is represented in the QGraphicsScene.

        Arguments:
        pointF - QPointF object holding a scaled point that the user
                 wants to convert to a QGraphicsScene point.

        Returns:
        QPointF holding a QPointF in a QGraphicsScene that is equivalent
        to the given input point.
        """

        scaledX = pointF.x()
        scaledY = pointF.y()

        # The below was originally used, but it doesn't work because
        # we get an exception when using high scaling values:
        #
        # ValueError: year is out of range
        #
        #dt = self.convertScaledValueToDatetime(scaledX)
        #price = self.convertScaledValueToPrice(scaledY)
        #sceneX = self.datetimeToSceneXPos(dt)
        #sceneY = self.priceToSceneYPos(price)
        
        # Instead, we will just do the multiply ourselves, manually,
        # and not use the ephemeris.
         
        # Determine the scene X value.
        birthDatetime = self.getBirthDatetime()
        birthJd = Ephemeris.datetimeToJulianDay(birthDatetime)
        jdDiff = scaledX * self.scaling.getUnitsOfTime()
        jd = birthJd + jdDiff
        
        sceneX = self.julianDayToSceneXPos(jd)
         
        # Determine the scene Y value.
        sceneY = self.convertScaledValueToPrice(scaledY)
        
        return QPointF(sceneX, sceneY)

    def clearCachedPriceBars(self):
        """Clears what we pre-determined was the highest, lowest,
        earliest and latest PriceBars.  These will be recalculated the
        next time the user wants the reference to the specific PriceBar.
        """
        
        self.highestPriceBar = None
        self.lowestPriceBar = None
        self.earliestPriceBar = None
        self.latestPriceBar = None
        
    def getEarliestPriceBar(self):
        """Goes through all the PriceBars, looking at the one that has
        the earliest timestamp.  This pricebar is returned.
        
        Returns:
        PriceBar - PriceBar object that has the earliest timestamp.
        """

        # Use pre-determined value if available.
        if self.earliestPriceBar != None:
            return self.earliestPriceBar
        
        earliestPriceBar = None
        
        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):
                pb = item.getPriceBar()

                if earliestPriceBar == None:
                    earliestPriceBar = pb
                elif pb.timestamp < earliestPriceBar.timestamp:
                    earliestPriceBar = pb

        # Cache for later usage.
        self.earliestPriceBar = earliestPriceBar
                    
        return earliestPriceBar

    def getLatestPriceBar(self):
        """Goes through all the PriceBars, looking at the one that has
        the latest timestamp.  This pricebar is returned.
        
        Returns:
        PriceBar - PriceBar object that has the latest timestamp.
        """

        # Use pre-determined value if available.
        if self.latestPriceBar != None:
            return self.latestPriceBar
        
        latestPriceBar = None
        
        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):
                pb = item.getPriceBar()

                if latestPriceBar == None:
                    latestPriceBar = pb
                elif pb.timestamp > latestPriceBar.timestamp:
                    latestPriceBar = pb

        # Cache for later usage.
        self.latestPriceBar = latestPriceBar
        
        return latestPriceBar

    def getHighestPriceBar(self):
        """Goes through all the PriceBars, looking at the one that has
        the highest high price.  This pricebar is returned.
        
        Returns:
        PriceBar - PriceBar object for the highest pricebar in price.
        """

        # Use pre-determined value if available.
        if self.highestPriceBar != None:
            return self.highestPriceBar
        
        highestPriceBar = None
        
        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):
                pb = item.getPriceBar()

                if highestPriceBar == None:
                    highestPriceBar = pb
                elif pb.hasHigherHighThan(highestPriceBar):
                    highestPriceBar = pb
                    
        # Cache for later usage.
        self.highestPriceBar = highestPriceBar

        return highestPriceBar

    def getLowestPriceBar(self):
        """Goes through all the PriceBars, looking at the one that has
        the lowest low price.  This pricebar is returned.
        
        Returns:
        PriceBar - PriceBar object for the lowest pricebar in price.
        """

        # Use pre-determined value if available.
        if self.lowestPriceBar != None:
            return self.lowestPriceBar
        
        lowestPriceBar = None
        
        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):
                pb = item.getPriceBar()

                if lowestPriceBar == None:
                    lowestPriceBar = pb
                elif pb.hasLowerLowThan(lowestPriceBar):
                    lowestPriceBar = pb
        
        # Cache for later usage.
        self.lowestPriceBar = lowestPriceBar

        return lowestPriceBar

    def getEarliestLookbackMultiplePriceBar(self):
        """Goes through all the LookbackMultiplePriceBars, 
        looking at the one that has the earliest timestamp.  
        This LookbackMultiplePriceBar is returned.
        
        Returns:
        LookbackMultiplePriceBar - LookbackMultiplePriceBar object that has the 
                                   earliest timestamp.
        """

        earliestLookbackMultiplePriceBar = None
        
        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                lmpb = item.getLookbackMultiplePriceBar()

                if earliestLookbackMultiplePriceBar == None:
                    earliestLookbackMultiplePriceBar = lmpb
                elif lmpb.timestamp < earliestLookbackMultiplePriceBar.timestamp:
                    earliestLookbackMultiplePriceBar = lmpb

        return earliestLookbackMultiplePriceBar

    def getLatestLookbackMultiplePriceBar(self):
        """Goes through all the LookbackMultiplePriceBars, 
        looking at the one that has the latest timestamp.  
        This LookbackMultiplePriceBar is returned.
        
        Returns:
        LookbackMultiplePriceBar - LookbackMultiplePriceBar object that has the 
                                   latest timestamp.
        """

        latestLookbackMultiplePriceBar = None
        
        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                lmpb = item.getLookbackMultiplePriceBar()

                if latestLookbackMultiplePriceBar == None:
                    latestLookbackMultiplePriceBar = lmpb
                elif lmpb.timestamp > latestLookbackMultiplePriceBar.timestamp:
                    latestLookbackMultiplePriceBar = lmpb

        return latestLookbackMultiplePriceBar

    def getHighestLookbackMultiplePriceBar(self):
        """Goes through all the LookbackMultiplePriceBars, looking at
        the one that has the highest high price.  This
        LookbackMultiplePriceBar is returned.
        
        Returns:
        LookbackMultiplePriceBar - LookbackMultiplePriceBar object containing the 
                                   highest high price.
        """

        highestLookbackMultiplePriceBar = None
        
        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                lmpb = item.getLookbackMultiplePriceBar()

                if highestLookbackMultiplePriceBar == None:
                    highestLookbackMultiplePriceBar = lmpb
                elif lmpb.hasHigherHighThan(highestLookbackMultiplePriceBar):
                    highestLookbackMultiplePriceBar = lmpb
                    
        return highestLookbackMultiplePriceBar

    def getLowestLookbackMultiplePriceBar(self):
        """Goes through all the LookbackMultiplePriceBars, looking at
        the one that has the lowest low price.  This
        LookbackMultiplePriceBar is returned.
        
        Returns:
        LookbackMultiplePriceBar - LookbackMultiplePriceBar object containing the 
                                   lowest low price.
        """

        lowestLookbackMultiplePriceBar = None
        
        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                lmpb = item.getLookbackMultiplePriceBar()

                if lowestLookbackMultiplePriceBar == None:
                    lowestLookbackMultiplePriceBar = lmpb
                elif lmpb.hasLowerLowThan(lowestLookbackMultiplePriceBar):
                    lowestLookbackMultiplePriceBar = lmpb
                    
        return lowestLookbackMultiplePriceBar

    def getClosestPriceBarOHLCPoint(self, pointF):
        """Goes through all the PriceBars, looking at the QPointF of
        the open, high, low, and close of each bar (in price and
        time), and tests it to locate the point out of all the bars
        that is the closest to 'pointF'.

        WARNING: This may not do what you expect to do!  The reason is
        because our current scaling for time (x coordinate) is 1 unit
        of x per day.  Our price scaling (y coordinate) is 1 unit of
        price per y.  This means the 'qgraphicsview' scaling of x and
        y (in appearance) is misleading when compared to actual
        coordinates.  So the algorithm works correctly, but may not
        produce expected results due to a huge skew in scaling.  If
        this is not what you want, then consider using
        getClosestPriceBarOHLCViewPoint().
        
        Returns:
        QPointF - Point that is a scene pos of a open, high, low,
                  or close of a PriceBar, where it is the closest
                  to the given 'pointF'.
        """

        self.log.debug("Entered getClosestPriceBarOHLCPoint()")
        
        # QPointF for the closest point.
        closestPoint = None

        # Smallest length of line from pointF to desired point.
        smallestLength = None
        
        # PriceBarGraphicsItem that is the closest.
        closestPriceBarGraphicsItem = None
        
        # Allocate lines ahead of time so we don't have
        # to create and destroy a whole bunch of them in the loop.
        lineToOpen = QLineF()
        lineToHigh = QLineF()
        lineToLow = QLineF()
        lineToClose = QLineF()

        graphicsItems = self.items()

        self.log.debug("PointF is: ({}, {})".format(pointF.x(), pointF.y()))
                       
        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):
                # Get the points of the open, high, low, and close of
                # this PriceBarGraphicsItem.
                openPointF = item.getPriceBarOpenScenePoint()
                highPointF = item.getPriceBarHighScenePoint()
                lowPointF = item.getPriceBarLowScenePoint()
                closePointF = item.getPriceBarCloseScenePoint()

                #self.log.debug("openPointF is: ({}, {})".
                #               format(openPointF.x(), openPointF.y()))
                #self.log.debug("highPointF is: ({}, {})".
                #               format(highPointF.x(), highPointF.y()))
                #self.log.debug("lowPointF is: ({}, {})".
                #               format(lowPointF.x(), lowPointF.y()))
                #self.log.debug("closePointF is: ({}, {})".
                #               format(closePointF.x(), closePointF.y()))

                # Create lines so we can get the lengths between the points.
                lineToOpen.setPoints(pointF, openPointF)
                lineToHigh.setPoints(pointF, highPointF)
                lineToLow.setPoints(pointF, lowPointF)
                lineToClose.setPoints(pointF, closePointF)

                lineToOpenLength = lineToOpen.length()
                lineToHighLength = lineToHigh.length()
                lineToLowLength = lineToLow.length()
                lineToCloseLength = lineToClose.length()
                
                #self.log.debug("lineToOpenLength is: {}".\
                #               format(lineToOpenLength))
                #self.log.debug("lineToHighLength is: {}".\
                #               format(lineToHighLength))
                #self.log.debug("lineToLowLength is: {}".\
                #               format(lineToLowLength))
                #self.log.debug("lineToCloseLength is: {}".\
                #               format(lineToCloseLength))

                # Set the initial smallestLength as the first point if
                # it is not set already.
                if smallestLength == None:
                    closestPoint = openPointF
                    smallestLength = lineToOpen.length()
                    closestPriceBarGraphicsItem = item

                # Test the open, high, low, and close points to see if
                # they are now the closest to pointF.
                if lineToOpenLength < smallestLength:
                    closestPoint = openPointF
                    smallestLength = lineToOpenLength
                    closestPriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: " +
                    #               "({}, {})".format(closestPoint.x(),
                    #                                 closestPoint.y()))

                if lineToHighLength < smallestLength:
                    closestPoint = highPointF
                    smallestLength = lineToHighLength
                    closestPriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: " +
                    #               "({}, {})".format(closestPoint.x(),
                    #                                 closestPoint.y()))

                if lineToLowLength < smallestLength:
                    closestPoint = lowPointF
                    smallestLength = lineToLowLength
                    closestPriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: " +
                    #               "({}, {})".format(closestPoint.x(),
                    #                                 closestPoint.y()))

                if lineToCloseLength < smallestLength:
                    closestPoint = closePointF
                    smallestLength = lineToCloseLength
                    closestPriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: " +
                    #               "({}, {})".format(closestPoint.x(),
                    #                                 closestPoint.y()))
                    
        self.log.debug("Closest point is: ({}, {})".format(closestPoint.x(),
                                                           closestPoint.y()))

        self.log.debug("Exiting getClosestPriceBarOHLCPoint()")
        
        return closestPoint

    def getClosestPriceBarOHLCViewPoint(self, pointF):
        """Goes through all the PriceBars, looking at the QPointF of
        the open, high, low, and close of each pricebar (in price and
        time), and tests it to locate the point out of all the bars
        that is the closest to 'pointF' in the GraphicsView.  This
        utilizes the graphics view scaling to see what is closest.  

        Arguments:
        pointF - QPointF object that is a point in scene
        coordinates.  This point is used as a reference point to
        calculate distances to the open, high, low, and close points
        of the price bars.
        
        Returns:
        QPointF - Point in scene coordinates of the closest pricebar's
        open, high, low, or close (in price and time), when computed
        using scaled view coordinates.
        """
        
        self.log.debug("Entered getClosestPriceBarOHLCViewPoint()")
        
        # QPointF for the closest point.
        closestPoint = None

        # Smallest length of line from pointF to desired point.
        smallestLength = None
        
        # PriceBarGraphicsItem that is the closest.
        closestPriceBarGraphicsItem = None

        # Scaling object to use.
        scaling = self.scaling
        
        self.log.debug("PointF is: ({}, {})".format(pointF.x(), pointF.y()))

        viewScaledPointF = QPointF(pointF.x() * scaling.getViewScalingX(),
                                   pointF.y() * scaling.getViewScalingY())
        
        self.log.debug("View-scaled PointF is: ({}, {})".\
                       format(viewScaledPointF.x(), viewScaledPointF.y()))

        # Allocate the points and lines ahead of time so we don't have
        # to create and destroy a whole bunch of them in the loop.
        viewScaledOpenPointF = QPointF()
        viewScaledHighPointF = QPointF()
        viewScaledLowPointF = QPointF()
        viewScaledClosePointF = QPointF()
        lineToOpen = QLineF()
        lineToHigh = QLineF()
        lineToLow = QLineF()
        lineToClose = QLineF()

        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):
                # Get the points of the open, high, low, and close of
                # this PriceBarGraphicsItem.
                openPointF = item.getPriceBarOpenScenePoint()
                highPointF = item.getPriceBarHighScenePoint()
                lowPointF = item.getPriceBarLowScenePoint()
                closePointF = item.getPriceBarCloseScenePoint()

                #self.log.debug("openPointF is: ({}, {})".
                #               format(openPointF.x(), openPointF.y()))
                #self.log.debug("highPointF is: ({}, {})".
                #               format(highPointF.x(), highPointF.y()))
                #self.log.debug("lowPointF is: ({}, {})".
                #               format(lowPointF.x(), lowPointF.y()))
                #self.log.debug("closePointF is: ({}, {})".
                #               format(closePointF.x(), closePointF.y()))

                viewScaledOpenPointF.\
                    setX(openPointF.x() * scaling.getViewScalingX())
                viewScaledOpenPointF.\
                    setY(openPointF.y() * scaling.getViewScalingY())
                
                viewScaledHighPointF.\
                    setX(highPointF.x() * scaling.getViewScalingX())
                viewScaledHighPointF.\
                    setY(highPointF.y() * scaling.getViewScalingY())
                
                viewScaledLowPointF.\
                    setX(lowPointF.x() * scaling.getViewScalingX())
                viewScaledLowPointF.\
                    setY(lowPointF.y() * scaling.getViewScalingY())
                
                viewScaledClosePointF.\
                    setX(closePointF.x() * scaling.getViewScalingX())
                viewScaledClosePointF.\
                    setY(closePointF.y() * scaling.getViewScalingY())

                #self.log.debug("viewScaledOpenPointF is: ({}, {})".
                #               format(viewScaledOpenPointF.x(),
                #                      viewScaledOpenPointF.y()))
                #self.log.debug("viewScaledHighPointF is: ({}, {})".
                #               format(viewScaledHighPointF.x(),
                #                      viewScaledHighPointF.y()))
                #self.log.debug("viewScaledLowPointF is: ({}, {})".
                #               format(viewScaledLowPointF.x(),
                #                      viewScaledLowPointF.y()))
                #self.log.debug("viewScaledClosePointF is: ({}, {})".
                #               format(viewScaledClosePointF.x(),
                #                      viewScaledClosePointF.y()))

                # Create lines so we can get the lengths between the points.
                lineToOpen.setPoints(viewScaledPointF, viewScaledOpenPointF)
                lineToHigh.setPoints(viewScaledPointF, viewScaledHighPointF)
                lineToLow.setPoints(viewScaledPointF, viewScaledLowPointF)
                lineToClose.setPoints(viewScaledPointF, viewScaledClosePointF)

                lineToOpenLength = lineToOpen.length()
                lineToHighLength = lineToHigh.length()
                lineToLowLength = lineToLow.length()
                lineToCloseLength = lineToClose.length()
                
                #self.log.debug("lineToOpenLength is: {}".\
                #               format(lineToOpenLength))
                #self.log.debug("lineToHighLength is: {}".\
                #               format(lineToHighLength))
                #self.log.debug("lineToLowLength is: {}".\
                #               format(lineToLowLength))
                #self.log.debug("lineToCloseLength is: {}".\
                #               format(lineToCloseLength))

                # Set the initial smallestLength as the first point if
                # it is not set already.
                if smallestLength == None:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = openPointF
                    smallestLength = lineToOpen.length()
                    closestPriceBarGraphicsItem = item

                # Test the open, high, low, and close points to see if
                # they are now the closest to pointF.
                if lineToOpenLength < smallestLength:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = openPointF
                    smallestLength = lineToOpenLength
                    closestPriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: ({}, {})".\
                    #               format(closestPoint.x(),
                    #                      closestPoint.y()))

                if lineToHighLength < smallestLength:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = highPointF
                    smallestLength = lineToHighLength
                    closestPriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: ({}, {})".\
                    #               format(closestPoint.x(),
                    #                      closestPoint.y()))

                if lineToLowLength < smallestLength:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = lowPointF
                    smallestLength = lineToLowLength
                    closestPriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: ({}, {})".\
                    #               format(closestPoint.x(),
                    #                      closestPoint.y()))

                if lineToCloseLength < smallestLength:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = closePointF
                    smallestLength = lineToCloseLength
                    closestPriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: ({}, {})".\
                    #               format(closestPoint.x(),
                    #                      closestPoint.y()))
                    
        self.log.debug("Closest point is: ({}, {})".\
                       format(closestPoint.x(), closestPoint.y()))

        self.log.debug("Exiting getClosestPriceBarOHLCViewPoint()")
        
        return closestPoint
        
        
    def getClosestPriceBarX(self, pointF):
        """Gets the X position value of the closest PriceBar (on the X
        axis) to the given QPointF position.

        Arguments:
        pointF - QPointF to do the lookup on.

        Returns:
        float value for the X value.  If there are no PriceBars, then it
        returns the X given in the input pointF.
        """

        # Get all the QGraphicsItems.
        graphicsItems = self.items()

        closestPriceBarX = None
        currClosestDistance = None

        # Go through the PriceBarGraphicsItems and find the closest one in
        # X coordinates.
        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):

                x = item.getPriceBarHighScenePoint().x()
                distance = abs(pointF.x() - x)

                if closestPriceBarX == None:
                    closestPriceBarX = x
                    currClosestDistance = distance
                elif (currClosestDistance != None) and \
                        (distance < currClosestDistance):

                    closestPriceBarX = x
                    currClosestDistance = distance
                    
        if closestPriceBarX == None:
            closestPriceBarX = pointF.x()

        return closestPriceBarX

    def getClosestPriceBarOHLCY(self, pointF):
        """Gets the Y position value of the closest open, high, low,
        or close price on all the PriceBars (on the Y axis) to the
        given QPointF position.

        Arguments:
        pointF - QPointF to do the lookup on.

        Returns:
        float value for the Y value.  If there are no PriceBars, then it
        returns the Y given in the input pointF.
        """

        # Get all the QGraphicsItems.
        graphicsItems = self.items()

        closestPriceBarY = None
        currClosestDistance = None

        # Go through the PriceBarGraphicsItems and find the closest one in
        # Y coordinates.
        for item in graphicsItems:
            if isinstance(item, PriceBarGraphicsItem):

                # High price's Y.
                y = item.getPriceBarHighScenePoint().y()
                distance = abs(pointF.y() - y)
                
                if closestPriceBarY == None:
                    closestPriceBarY = y
                    currClosestDistance = distance
                elif (currClosestDistance != None) and \
                        (distance < currClosestDistance):

                    closestPriceBarY = y
                    currClosestDistance = distance

                # Low price's Y.
                y = item.getPriceBarLowScenePoint().y()
                distance = abs(pointF.y() - y)

                if closestPriceBarY == None:
                    closestPriceBarY = y
                    currClosestDistance = distance
                elif (currClosestDistance != None) and \
                        (distance < currClosestDistance):

                    closestPriceBarY = y
                    currClosestDistance = distance
                    
        if closestPriceBarY == None:
            closestPriceBarY = pointF.y()

        return closestPriceBarY

    def getClosestLookbackMultiplePriceBarOHLCPoint(self, pointF):
        """Goes through all the LookbackMultiplePriceBars, looking at the 
        QPointF of the open, high, low, and close of each bar (in price and
        time), and tests it to locate the point out of all the bars
        that is the closest to 'pointF'.

        WARNING: This may not do what you expect to do!  The reason is
        because our current scaling for time (x coordinate) is 1 unit
        of x per day.  Our price scaling (y coordinate) is 1 unit of
        price per y.  This means the 'qgraphicsview' scaling of x and
        y (in appearance) is misleading when compared to actual
        coordinates.  So the algorithm works correctly, but may not
        produce expected results due to a huge skew in scaling.  If
        this is not what you want, then consider using
        getClosestLookbackMultiplePriceBarOHLCViewPoint().
        
        Returns:
        QPointF - Point that is a scene pos of a open, high, low,
                  or close of a LookbackMultiplePriceBar, where it is the closest
                  to the given 'pointF'.
        """

        self.log.debug("Entered getClosestLookbackMultiplePriceBarOHLCPoint()")
        
        # QPointF for the closest point.
        closestPoint = None

        # Smallest length of line from pointF to desired point.
        smallestLength = None
        
        # LookbackMultiplePriceBarGraphicsItem that is the closest.
        closestLookbackMultiplePriceBarGraphicsItem = None
        
        # Allocate lines ahead of time so we don't have
        # to create and destroy a whole bunch of them in the loop.
        lineToOpen = QLineF()
        lineToHigh = QLineF()
        lineToLow = QLineF()
        lineToClose = QLineF()

        graphicsItems = self.items()

        self.log.debug("PointF is: ({}, {})".format(pointF.x(), pointF.y()))
                       
        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                # Get the points of the open, high, low, and close of
                # this LookbackMultiplePriceBarGraphicsItem.
                openPointF = item.getLookbackMultiplePriceBarOpenScenePoint()
                highPointF = item.getLookbackMultiplePriceBarHighScenePoint()
                lowPointF = item.getLookbackMultiplePriceBarLowScenePoint()
                closePointF = item.getLookbackMultiplePriceBarCloseScenePoint()

                #self.log.debug("openPointF is: ({}, {})".
                #               format(openPointF.x(), openPointF.y()))
                #self.log.debug("highPointF is: ({}, {})".
                #               format(highPointF.x(), highPointF.y()))
                #self.log.debug("lowPointF is: ({}, {})".
                #               format(lowPointF.x(), lowPointF.y()))
                #self.log.debug("closePointF is: ({}, {})".
                #               format(closePointF.x(), closePointF.y()))

                # Create lines so we can get the lengths between the points.
                lineToOpen.setPoints(pointF, openPointF)
                lineToHigh.setPoints(pointF, highPointF)
                lineToLow.setPoints(pointF, lowPointF)
                lineToClose.setPoints(pointF, closePointF)

                lineToOpenLength = lineToOpen.length()
                lineToHighLength = lineToHigh.length()
                lineToLowLength = lineToLow.length()
                lineToCloseLength = lineToClose.length()
                
                #self.log.debug("lineToOpenLength is: {}".\
                #               format(lineToOpenLength))
                #self.log.debug("lineToHighLength is: {}".\
                #               format(lineToHighLength))
                #self.log.debug("lineToLowLength is: {}".\
                #               format(lineToLowLength))
                #self.log.debug("lineToCloseLength is: {}".\
                #               format(lineToCloseLength))

                # Set the initial smallestLength as the first point if
                # it is not set already.
                if smallestLength == None:
                    closestPoint = openPointF
                    smallestLength = lineToOpen.length()
                    closestLookbackMultiplePriceBarGraphicsItem = item

                # Test the open, high, low, and close points to see if
                # they are now the closest to pointF.
                if lineToOpenLength < smallestLength:
                    closestPoint = openPointF
                    smallestLength = lineToOpenLength
                    closestLookbackMultiplePriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: " +
                    #               "({}, {})".format(closestPoint.x(),
                    #                                 closestPoint.y()))

                if lineToHighLength < smallestLength:
                    closestPoint = highPointF
                    smallestLength = lineToHighLength
                    closestLookbackMultiplePriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: " +
                    #               "({}, {})".format(closestPoint.x(),
                    #                                 closestPoint.y()))

                if lineToLowLength < smallestLength:
                    closestPoint = lowPointF
                    smallestLength = lineToLowLength
                    closestLookbackMultiplePriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: " +
                    #               "({}, {})".format(closestPoint.x(),
                    #                                 closestPoint.y()))

                if lineToCloseLength < smallestLength:
                    closestPoint = closePointF
                    smallestLength = lineToCloseLength
                    closestLookbackMultiplePriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: " +
                    #               "({}, {})".format(closestPoint.x(),
                    #                                 closestPoint.y()))
                    
        if closestPoint == None:
            # If the closestPoint is still None, then that means there are 
            # no LookbackMultiplePriceBars.  
            # In this case, use pointF as the closestPoint.
            closestPoint = pointF

            self.log.debug("There are no LookbackMultiplePriceBars, " + \
                           "so useing pointF as the closest point.")
        else:
            self.log.debug("Closest point is: ({}, {})".format(closestPoint.x(),
                                                               closestPoint.y()))

        self.log.debug("Exiting getClosestLookbackMultiplePriceBarOHLCPoint()")
        
        return closestPoint

    def getClosestLookbackMultiplePriceBarOHLCViewPoint(self, pointF):
        """Goes through all the LookbackMultiplePriceBars, looking at the QPointF of
        the open, high, low, and close of each pricebar (in price and
        time), and tests it to locate the point out of all the bars
        that is the closest to 'pointF' in the GraphicsView.  This
        utilizes the graphics view scaling to see what is closest.  

        Arguments:
        pointF - QPointF object that is a point in scene
        coordinates.  This point is used as a reference point to
        calculate distances to the open, high, low, and close points
        of the price bars.
        
        Returns:
        QPointF - Point in scene coordinates of the closest pricebar's
        open, high, low, or close (in price and time), when computed
        using scaled view coordinates.
        """
        
        self.log.debug("Entered getClosestLookbackMultiplePriceBarOHLCViewPoint()")
        
        # QPointF for the closest point.
        closestPoint = None

        # Smallest length of line from pointF to desired point.
        smallestLength = None
        
        # LookbackMultiplePriceBarGraphicsItem that is the closest.
        closestLookbackMultiplePriceBarGraphicsItem = None

        # Scaling object to use.
        scaling = self.scaling
        
        self.log.debug("PointF is: ({}, {})".format(pointF.x(), pointF.y()))

        viewScaledPointF = QPointF(pointF.x() * scaling.getViewScalingX(),
                                   pointF.y() * scaling.getViewScalingY())
        
        self.log.debug("View-scaled PointF is: ({}, {})".\
                       format(viewScaledPointF.x(), viewScaledPointF.y()))

        # Allocate the points and lines ahead of time so we don't have
        # to create and destroy a whole bunch of them in the loop.
        viewScaledOpenPointF = QPointF()
        viewScaledHighPointF = QPointF()
        viewScaledLowPointF = QPointF()
        viewScaledClosePointF = QPointF()
        lineToOpen = QLineF()
        lineToHigh = QLineF()
        lineToLow = QLineF()
        lineToClose = QLineF()

        graphicsItems = self.items()

        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                # Get the points of the open, high, low, and close of
                # this LookbackMultiplePriceBarGraphicsItem.
                openPointF = item.getLookbackMultiplePriceBarOpenScenePoint()
                highPointF = item.getLookbackMultiplePriceBarHighScenePoint()
                lowPointF = item.getLookbackMultiplePriceBarLowScenePoint()
                closePointF = item.getLookbackMultiplePriceBarCloseScenePoint()

                #self.log.debug("openPointF is: ({}, {})".
                #               format(openPointF.x(), openPointF.y()))
                #self.log.debug("highPointF is: ({}, {})".
                #               format(highPointF.x(), highPointF.y()))
                #self.log.debug("lowPointF is: ({}, {})".
                #               format(lowPointF.x(), lowPointF.y()))
                #self.log.debug("closePointF is: ({}, {})".
                #               format(closePointF.x(), closePointF.y()))

                viewScaledOpenPointF.\
                    setX(openPointF.x() * scaling.getViewScalingX())
                viewScaledOpenPointF.\
                    setY(openPointF.y() * scaling.getViewScalingY())
                
                viewScaledHighPointF.\
                    setX(highPointF.x() * scaling.getViewScalingX())
                viewScaledHighPointF.\
                    setY(highPointF.y() * scaling.getViewScalingY())
                
                viewScaledLowPointF.\
                    setX(lowPointF.x() * scaling.getViewScalingX())
                viewScaledLowPointF.\
                    setY(lowPointF.y() * scaling.getViewScalingY())
                
                viewScaledClosePointF.\
                    setX(closePointF.x() * scaling.getViewScalingX())
                viewScaledClosePointF.\
                    setY(closePointF.y() * scaling.getViewScalingY())

                #self.log.debug("viewScaledOpenPointF is: ({}, {})".
                #               format(viewScaledOpenPointF.x(),
                #                      viewScaledOpenPointF.y()))
                #self.log.debug("viewScaledHighPointF is: ({}, {})".
                #               format(viewScaledHighPointF.x(),
                #                      viewScaledHighPointF.y()))
                #self.log.debug("viewScaledLowPointF is: ({}, {})".
                #               format(viewScaledLowPointF.x(),
                #                      viewScaledLowPointF.y()))
                #self.log.debug("viewScaledClosePointF is: ({}, {})".
                #               format(viewScaledClosePointF.x(),
                #                      viewScaledClosePointF.y()))

                # Create lines so we can get the lengths between the points.
                lineToOpen.setPoints(viewScaledPointF, viewScaledOpenPointF)
                lineToHigh.setPoints(viewScaledPointF, viewScaledHighPointF)
                lineToLow.setPoints(viewScaledPointF, viewScaledLowPointF)
                lineToClose.setPoints(viewScaledPointF, viewScaledClosePointF)

                lineToOpenLength = lineToOpen.length()
                lineToHighLength = lineToHigh.length()
                lineToLowLength = lineToLow.length()
                lineToCloseLength = lineToClose.length()
                
                #self.log.debug("lineToOpenLength is: {}".\
                #               format(lineToOpenLength))
                #self.log.debug("lineToHighLength is: {}".\
                #               format(lineToHighLength))
                #self.log.debug("lineToLowLength is: {}".\
                #               format(lineToLowLength))
                #self.log.debug("lineToCloseLength is: {}".\
                #               format(lineToCloseLength))

                # Set the initial smallestLength as the first point if
                # it is not set already.
                if smallestLength == None:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = openPointF
                    smallestLength = lineToOpen.length()
                    closestLookbackMultiplePriceBarGraphicsItem = item

                # Test the open, high, low, and close points to see if
                # they are now the closest to pointF.
                if lineToOpenLength < smallestLength:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = openPointF
                    smallestLength = lineToOpenLength
                    closestLookbackMultiplePriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: ({}, {})".\
                    #               format(closestPoint.x(),
                    #                      closestPoint.y()))

                if lineToHighLength < smallestLength:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = highPointF
                    smallestLength = lineToHighLength
                    closestLookbackMultiplePriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: ({}, {})".\
                    #               format(closestPoint.x(),
                    #                      closestPoint.y()))

                if lineToLowLength < smallestLength:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = lowPointF
                    smallestLength = lineToLowLength
                    closestLookbackMultiplePriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: ({}, {})".\
                    #               format(closestPoint.x(),
                    #                      closestPoint.y()))

                if lineToCloseLength < smallestLength:
                    # Here we are keeping the scene coordinate, not the
                    # view-scaled one.
                    closestPoint = closePointF
                    smallestLength = lineToCloseLength
                    closestLookbackMultiplePriceBarGraphicsItem = item
                    #self.log.debug("New closest point is now: ({}, {})".\
                    #               format(closestPoint.x(),
                    #                      closestPoint.y()))
                    

        if closestPoint == None:
            # If the closestPoint is still None, then that means there are 
            # no LookbackMultiplePriceBars.  
            # In this case, use pointF as the closestPoint.
            closestPoint = pointF

            self.log.debug("There are no LookbackMultiplePriceBars, " + \
                           "so useing pointF as the closest point.")
        else:    
            self.log.debug("Closest point is: ({}, {})".\
                           format(closestPoint.x(), closestPoint.y()))

        self.log.debug("Exiting getClosestLookbackMultiplePriceBarOHLCViewPoint()")
        
        return closestPoint
        
        
    def getClosestLookbackMultiplePriceBarX(self, pointF):
        """Gets the X position value of the closest LookbackMultiplePriceBar (on the X
        axis) to the given QPointF position.

        Arguments:
        pointF - QPointF to do the lookup on.

        Returns:
        float value for the X value.  If there are no LookbackMultiplePriceBars, then it
        returns the X given in the input pointF.
        """

        # Get all the QGraphicsItems.
        graphicsItems = self.items()

        closestLookbackMultiplePriceBarX = None
        currClosestDistance = None

        # Go through the LookbackMultiplePriceBarGraphicsItems and find the closest one in
        # X coordinates.
        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):

                x = item.getLookbackMultiplePriceBarHighScenePoint().x()
                distance = abs(pointF.x() - x)

                if closestLookbackMultiplePriceBarX == None:
                    closestLookbackMultiplePriceBarX = x
                    currClosestDistance = distance
                elif (currClosestDistance != None) and \
                        (distance < currClosestDistance):

                    closestLookbackMultiplePriceBarX = x
                    currClosestDistance = distance
                    
        if closestLookbackMultiplePriceBarX == None:
            closestLookbackMultiplePriceBarX = pointF.x()

        return closestLookbackMultiplePriceBarX

    def getClosestLookbackMultiplePriceBarOHLCY(self, pointF):
        """Gets the Y position value of the closest open, high, low,
        or close price on all the LookbackMultiplePriceBars (on the Y axis) to the
        given QPointF position.

        Arguments:
        pointF - QPointF to do the lookup on.

        Returns:
        float value for the Y value.  If there are no LookbackMultiplePriceBars, then it
        returns the Y given in the input pointF.
        """

        # Get all the QGraphicsItems.
        graphicsItems = self.items()

        closestLookbackMultiplePriceBarY = None
        currClosestDistance = None

        # Go through the LookbackMultiplePriceBarGraphicsItems and find the closest one in
        # Y coordinates.
        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):

                # High price's Y.
                y = item.getLookbackMultiplePriceBarHighScenePoint().y()
                distance = abs(pointF.y() - y)
                
                if closestLookbackMultiplePriceBarY == None:
                    closestLookbackMultiplePriceBarY = y
                    currClosestDistance = distance
                elif (currClosestDistance != None) and \
                        (distance < currClosestDistance):

                    closestLookbackMultiplePriceBarY = y
                    currClosestDistance = distance

                # Low price's Y.
                y = item.getLookbackMultiplePriceBarLowScenePoint().y()
                distance = abs(pointF.y() - y)

                if closestLookbackMultiplePriceBarY == None:
                    closestLookbackMultiplePriceBarY = y
                    currClosestDistance = distance
                elif (currClosestDistance != None) and \
                        (distance < currClosestDistance):

                    closestLookbackMultiplePriceBarY = y
                    currClosestDistance = distance
                    
        if closestLookbackMultiplePriceBarY == None:
            closestLookbackMultiplePriceBarY = pointF.y()

        return closestLookbackMultiplePriceBarY

    def getClosestPriceBarAndLookbackMultiplePriceBarOHLCPoint(self, pointF):
        """Goes through all the PriceBars and LookbackMultiplePriceBars, 
        looking at the QPointF of the open, high, low, and close of 
        each bar (in price and time), and tests it to locate 
        the point out of all the bars that is the closest to 'pointF'.

        WARNING: This may not do what you expect to do!  The reason is
        because our current scaling for time (x coordinate) is 1 unit
        of x per day.  Our price scaling (y coordinate) is 1 unit of
        price per y.  This means the 'qgraphicsview' scaling of x and
        y (in appearance) is misleading when compared to actual
        coordinates.  So the algorithm works correctly, but may not
        produce expected results due to a huge skew in scaling.  If
        this is not what you want, then consider using
        getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint().
        
        Returns:
        QPointF - Point that is a scene pos of a open, high, low,
                  or close of a PriceBar or a LookbackMultiplePriceBar, 
                  where it is the closest to the given 'pointF'.
        """

        self.log.debug("Entered getClosestPriceBarAndLookbackMultiplePriceBarOHLCPoint()")

        # Returned QPointF object.
        rv = None

        # Get the point for PriceBars and the point for LookbackMultiplePriceBars.
        closestPriceBarPointF = \
            self.getClosestPriceBarOHLCPoint(pointF)
        closestLookbackMultiplePriceBarPointF = \
            self.getClosestLookbackMultiplePriceBarOHLCPoint(pointF)

        # Special case:
        # 
        # If there are no LookbackMultiplePriceBars, then 
        # getClosestLookbackMultiplePriceBarOHLCPoint would 
        # return the pointF, which is 
        # not what we want.  Handle that here.
        if self.getNumLookbackMultiplePriceBarGraphicsItems() == 0:
            rv = closestPriceBarPointF
        else:
            # Compare the lengths of each closest one and 
            # return the point that is closest.
            lengthToPriceBarPointF = \
                QLineF(pointF, closestPriceBarPointF).length()
            lengthToLookbackMultiplePriceBarPointF = \
                QLineF(pointF, closestLookbackMultiplePriceBarPointF).length()
            
            if lengthToPriceBarPointF <= lengthToLookbackMultiplePriceBarPointF:
                rv = closestPriceBarPointF
            else:
                rv = closestLookbackMultiplePriceBarPointF

        self.log.debug("Exiting getClosestPriceBarAndLookbackMultiplePriceBarOHLCPoint()")
        
        return rv
    
    def getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint(self, pointF):
        """Goes through all the PriceBars and LookbackMultiplePriceBars,
        looking at the QPointF of the open, high, low, and close of each
        bar (in price and time), and tests it to locate the point out of
        all the bars that is the closest to 'pointF' in the
        GraphicsView.  This utilizes the graphics view scaling to see
        what is closest.

        Arguments:
        pointF - QPointF object that is a point in scene
        coordinates.  This point is used as a reference point to
        calculate distances to the open, high, low, and close points
        of the bars.
        
        Returns:
        QPointF - Point in scene coordinates of the closest 
        PriceBar or LookbackMultiplePriceBars
        open, high, low, or close (in price and time), when computed
        using scaled view coordinates.
        """
        
        self.log.debug("Entered getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint()")

        # Returned QPointF object.
        rv = None

        # Scaling object to use.
        scaling = self.scaling
        
        self.log.debug("PointF is: ({}, {})".format(pointF.x(), pointF.y()))

        viewScaledPointF = QPointF(pointF.x() * scaling.getViewScalingX(),
                                   pointF.y() * scaling.getViewScalingY())
        
        self.log.debug("View-scaled PointF is: ({}, {})".\
                       format(viewScaledPointF.x(), viewScaledPointF.y()))

        # Get the point for PriceBars and the point for LookbackMultiplePriceBars.
        closestPriceBarPointF = \
            self.getClosestPriceBarOHLCViewPoint(pointF)
        closestLookbackMultiplePriceBarPointF = \
            self.getClosestLookbackMultiplePriceBarOHLCViewPoint(pointF)
            
        closestPriceBarViewScaledPointF = QPointF()
        closestPriceBarViewScaledPointF.\
            setX(closestPriceBarPointF.x() * \
                 scaling.getViewScalingX())
        closestPriceBarViewScaledPointF.\
            setY(closestPriceBarPointF.y() * \
                 scaling.getViewScalingY())

        closestLookbackMultiplePriceBarViewScaledPointF = QPointF()
        closestLookbackMultiplePriceBarViewScaledPointF.\
            setX(closestLookbackMultiplePriceBarPointF.x() * \
                 scaling.getViewScalingX())
        closestLookbackMultiplePriceBarViewScaledPointF.\
            setY(closestLookbackMultiplePriceBarPointF.y() * \
                 scaling.getViewScalingY())

        # Special case:
        # 
        # If there are no LookbackMultiplePriceBars, then 
        # getClosestLookbackMultiplePriceBarOHLCViewPoint 
        # would return the pointF, 
        # which is not what we want.  Handle that here.
        if self.getNumLookbackMultiplePriceBarGraphicsItems() == 0:
            rv = closestPriceBarPointF
        else:
            # Compare the lengths of each closest one and 
            # return the point that is closest.
            lengthToPriceBarPointF = \
                QLineF(viewScaledPointF, 
                       closestPriceBarViewScaledPointF).length()
            lengthToLookbackMultiplePriceBarPointF = \
                QLineF(viewScaledPointF, 
                       closestLookbackMultiplePriceBarViewScaledPointF).length()
            
            if lengthToPriceBarPointF <= lengthToLookbackMultiplePriceBarPointF:
                rv = closestPriceBarPointF
            else:
                rv = closestLookbackMultiplePriceBarPointF

        self.log.debug("Exiting getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint()")
        
        return rv


    def getClosestPriceBarAndLookbackMultiplePriceBarX(self, pointF):
        """Goes through all the PriceBar and LookbackMultiplePriceBar
        and gets the X position value of the closest PriceBar or
        LookbackMultiplePriceBar (on the X axis) to the given QPointF
        position.

        Arguments:
        pointF - QPointF to do the lookup on.

        Returns:
        float value for the X value.  If there are no 
        PriceBars or LookbackMultiplePriceBars, then it
        returns the X given in the input pointF.
        """

        # Get the closest X for PriceBars and LookbackMultiplePriceBars, 
        # separately.
        closestPriceBarX = \
            self.getClosestPriceBarX(pointF)
        closestLookbackMultiplePriceBarX = \
            self.getClosestLookbackMultiplePriceBarX(pointF)

        # Special case:
        # 
        # If there are no LookbackMultiplePriceBars, then 
        # getClosestLookbackMultiplePriceBarX() would 
        # return the pointF's x, which is not what we want.  
        # Handle that here.
        if self.getNumLookbackMultiplePriceBarGraphicsItems() == 0:
            rv = closestPriceBarX
        else:
            # Get the distances of each to compare.
            closestPriceBarDistanceX = \
                abs(pointF.x() - closestPriceBarX)
            closestLookbackMultiplePriceBarDistanceX = \
                abs(pointF.x() - closestLookbackMultiplePriceBarX)
            
            if closestPriceBarDistanceX <= \
                closestLookbackMultiplePriceBarDistanceX:
                
                rv = closestPriceBarX

            else:
                rv = closestLookbackMultiplePriceBarX

        return rv

    def getClosestPriceBarAndLookbackMultiplePriceBarOHLCY(self, pointF):
        """Goes through all the PriceBar and LookbackMultiplePriceBar
        and gets the Y position value of the closest PriceBar or
        LookbackMultiplePriceBar (on the Y axis) to the given QPointF
        position.

        Arguments:
        pointF - QPointF to do the lookup on.

        Returns:
        float value for the Y value.  If there are no 
        PriceBars or LookbackMultiplePriceBars, then it
        returns the Y given in the input pointF.
        """

        # Get the closest Y for PriceBars and LookbackMultiplePriceBars, 
        # separately.
        closestPriceBarY = \
            self.getClosestPriceBarOHLCY(pointF)
        closestLookbackMultiplePriceBarY = \
            self.getClosestLookbackMultiplePriceBarOHLCY(pointF)

        # Special case:
        # 
        # If there are no LookbackMultiplePriceBars, then 
        # getClosestLookbackMultiplePriceBarOHLCY() would 
        # return the pointF's y, which is not what we want.  
        # Handle that here.
        if self.getNumLookbackMultiplePriceBarGraphicsItems() == 0:
            rv = closestPriceBarY
        else:
            # Get the distances of each to compare.
            closestPriceBarDistanceY = \
                abs(pointF.y() - closestPriceBarY)
            closestLookbackMultiplePriceBarDistanceY = \
                abs(pointF.y() - closestLookbackMultiplePriceBarY)
            
            if closestPriceBarDistanceY <= \
                closestLookbackMultiplePriceBarDistanceY:
                
                rv = closestPriceBarY

            else:
                rv = closestLookbackMultiplePriceBarY

        return rv

    def getNumLookbackMultiplePriceBarGraphicsItems(self):
        """Returns the number of LookbackMultiplePriceBarGraphicsItems 
        in the scene.
        """
        
        count = 0

        graphicsItems = self.items()
        for item in graphicsItems:
            if isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                count += 1
        
        return count

    def setAstroChart1(self, x):
        """Emits the astroChart1Update signal so that an external
        astrology chart can be plotted with a timestamp.

        Arguments:
        
        x - float value for the X position in the QGraphicsScene.  The
            X value represents a certain timestamp (unconverted).
            This function will do the necessary conversion from X
            value to datetime.datetime timestamp.
        """

        # Convert from X to datetime.datetime.
        dt = self.sceneXPosToDatetime(x)
        
        # Emit the desired signal so that the astrology chart can be
        # plotted for this datetime.datetime.
        self.astroChart1Update.emit(dt)
        
    def setAstroChart2(self, x):
        """Emits the astroChart2Update signal so that an external
        astrology chart can be plotted with a timestamp.

        Arguments:
        
        x - float value for the X position in the QGraphicsScene.  The
            X value represents a certain timestamp (unconverted).
            This function will do the necessary conversion from X
            value to datetime.datetime timestamp.
        """

        # Convert from X to datetime.datetime.
        dt = self.sceneXPosToDatetime(x)
        
        # Emit the desired signal so that the astrology chart can be
        # plotted for this datetime.datetime.
        self.astroChart2Update.emit(dt)
        
    def setAstroChart3(self, x):
        """Emits the astroChart3Update signal so that an external
        astrology chart can be plotted with a timestamp.

        Arguments:
        
        x - float value for the X position in the QGraphicsScene.  The
            X value represents a certain timestamp (unconverted).
            This function will do the necessary conversion from X
            value to datetime.datetime timestamp.
        """

        # Convert from X to datetime.datetime.
        dt = self.sceneXPosToDatetime(x)
        
        # Emit the desired signal so that the astrology chart can be
        # plotted for this datetime.datetime.
        self.astroChart3Update.emit(dt)
        
    def openJHora(self, x):
        """Opens the JHora application with the timestamp represented
        by the X coordinate value.  This function uses the birth
        location/timezone set in self.birthInfo.
        
        Arguments:
        x - float value for the X position in the QGraphicsScene.  The
            X value represents a certain timestamp (unconverted).
            This function will do the necessary conversion from X
            value to datetime.datetime timestamp.
        """

        # Convert from X to datetime.datetime.
        dt = self.sceneXPosToDatetime(x)
        
        # Emit the desired signal so that the JHora can be launched
        # for this datetime.datetime.
        self.jhoraLaunch.emit(dt)

    def openAstrolog(self, x):
        """Opens the Astrolog application with the timestamp represented
        by the X coordinate value.  This function uses the birth
        location/timezone set in self.birthInfo.
        
        Arguments:
        x - float value for the X position in the QGraphicsScene.  The
            X value represents a certain timestamp (unconverted).
            This function will do the necessary conversion from X
            value to datetime.datetime timestamp.
        """

        # Convert from X to datetime.datetime.
        dt = self.sceneXPosToDatetime(x)
        
        # Emit the desired signal so that the Astrolog can be launched
        # for this datetime.datetime.
        self.astrologLaunch.emit(dt)

class PriceBarChartGraphicsView(QGraphicsView):
    """QGraphicsView that visualizes the main QGraphicsScene.
    We inherit QGraphicsView because we may want to add 
    custom syncrhonized functionality in other widgets later."""


    # Tool modes that this widget can be in.
    ToolMode = {"ReadOnlyPointerTool"      : 0,
                "PointerTool"              : 1,
                "HandTool"                 : 2,
                "ZoomInTool"               : 3,
                "ZoomOutTool"              : 4,
                "BarCountTool"             : 5,
                "TimeMeasurementTool"      : 6,
                "TimeModalScaleTool"       : 7,
                "PriceModalScaleTool"      : 8,
                "TextTool"                 : 9,
                "PriceTimeInfoTool"        : 10,
                "PriceMeasurementTool"     : 11,
                "TimeRetracementTool"      : 12,
                "PriceRetracementTool"     : 13,
                "PriceTimeVectorTool"      : 14,
                "LineSegment1Tool"          : 15,
                "OctaveFanTool"            : 16,
                "FibFanTool"               : 17,
                "GannFanTool"              : 18,
                "VimsottariDasaTool"       : 19,
                "AshtottariDasaTool"       : 20,
                "YoginiDasaTool"           : 21,
                "DwisaptatiSamaDasaTool"   : 22,
                "ShattrimsaSamaDasaTool"   : 23,
                "DwadasottariDasaTool"     : 24,
                "ChaturaseetiSamaDasaTool" : 25,
                "SataabdikaDasaTool"       : 26,
                "ShodasottariDasaTool"     : 27,
                "PanchottariDasaTool"      : 28,
                "ShashtihayaniDasaTool"    : 29,
                "PlanetLongitudeMovementMeasurementTool"      : 30,
                "LineSegment2Tool"         : 31,
                "VerticalLineSegmentTool"  : 32,
                "HorizontalLineSegmentTool": 33,
                }

    # Signal emitted when the mouse moves within the QGraphicsView.
    # The position emitted is in QGraphicsScene x, y, float coordinates.
    mouseLocationUpdate = QtCore.pyqtSignal(float, float)

    # Signal emitted when a status message should be printed.
    statusMessageUpdate = QtCore.pyqtSignal(str)
    
    def __init__(self, parent=None):
        """Pass-through to the QGraphicsView constructor."""

        super().__init__(parent)

        # Logger
        self.log = \
            logging.getLogger("pricebarchart.PriceBarChartGraphicsView")
        self.log.debug("Entered __init__()")

        # Save the current transformation matrix of the view.
        self.transformationMatrix = None

        # Save the current viewable portion of the scene.
        self.viewableSceneRectF = self.mapToScene(self.rect()).boundingRect()

        # Holds the tool mode that this widget is currently in.
        self.toolMode = \
            PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']

        # Anchor variable we will use for click-drag, etc.
        self.dragAnchorPointF = QPointF()

        # Variable used for storing mouse clicks (used in the various
        # modes for various purposes).
        self.clickOnePointF = None
        self.clickTwoPointF = None
        self.clickThreePointF = None

        # Variable used for storing the last mouse position, in scene
        # coordinates (QPointF).
        self.lastMousePosScene = None

        # Boolean flag indicating that either vertical or horizontal dashed
        # lines should be drawn where the mouse cursor is currently at.
        self.verticalDashedLineEnabled = False
        self.horizontalDashedLineEnabled = False
        
        # Variable used for storing the vertical and horizontal dashed lines 
        # drawn when in in any tool mode.
        self.verticalDashedLineGraphicsItem = None
        self.horizontalDashedLineGraphicsItem = None

        # Variable used for storing the new BarCountGraphicsItem,
        # as it is modified in BarCountToolMode.
        self.barCountGraphicsItem = None

        # Variable used for storing the new TimeMeasurementGraphicsItem,
        # as it is modified in TimeMeasurementToolMode.
        self.timeMeasurementGraphicsItem = None

        # Variable used for storing the new TimeModalScaleGraphicsItem,
        # as it is modified in TimeModalScaleToolMode.
        self.timeModalScaleGraphicsItem = None

        # Variable used for storing the new PriceModalScaleGraphicsItem,
        # as it is modified in PriceModalScaleToolMode.
        self.priceModalScaleGraphicsItem = None

        # Variable used for storing the new PlanetLongitudeMovementMeasurementGraphicsItem,
        # as it is modified in PlanetLongitudeMovementMeasurementToolMode.
        self.planetLongitudeMovementMeasurementGraphicsItem = None

        # Variable used for storing the new TextGraphicsItem,
        # as it is modified in TextToolMode.
        self.textGraphicsItem = None
        
        # Variable used for storing the new PriceTimeInfoGraphicsItem,
        # as it is modified in PriceTimeInfoToolMode.
        self.priceTimeInfoGraphicsItem = None

        # Variable used for storing the new PriceMeasurementGraphicsItem,
        # as it is modified in PriceMeasurementToolMode.
        self.priceMeasurementGraphicsItem = None

        # Variable used for storing the new TimeRetracementGraphicsItem,
        # as it is modified in TimeRetracementToolMode.
        self.timeRetracementGraphicsItem = None

        # Variable used for storing the new PriceRetracementGraphicsItem,
        # as it is modified in PriceRetracementToolMode.
        self.priceRetracementGraphicsItem = None

        # Variable used for storing the new PriceTimeVectorGraphicsItem,
        # as it is modified in PriceTimeVectorToolMode.
        self.priceTimeVectorGraphicsItem = None

        # Variable used for storing the new LineSegmentGraphicsItem,
        # as it is modified in LineSegment1ToolMode.
        self.lineSegment1GraphicsItem = None

        # Variable used for storing the new LineSegmentGraphicsItem,
        # as it is modified in LineSegment2ToolMode.
        self.lineSegment2GraphicsItem = None

        # Variable used for storing the new VerticalLineSegmentGraphicsItem,
        # as it is modified in VerticalLineSegmentToolMode.
        self.verticalLineSegmentGraphicsItem = None

        # Variable used for storing the new HorizontalLineSegmentGraphicsItem,
        # as it is modified in HorizontalLineSegmentToolMode.
        self.horizontalLineSegmentGraphicsItem = None

        # Variable used for storing the new OctaveFanGraphicsItem,
        # as it is modified in OctaveFanToolMode.
        self.octaveFanGraphicsItem = None

        # Variable used for storing the new FibFanGraphicsItem,
        # as it is modified in FibFanToolMode.
        self.fibFanGraphicsItem = None

        # Variable used for storing the new GannFanGraphicsItem,
        # as it is modified in GannFanToolMode.
        self.gannFanGraphicsItem = None

        # Variable used for storing the new VimsottariDasaGraphicsItem,
        # as it is modified in VimsottariDasaToolMode.
        self.vimsottariDasaGraphicsItem = None

        # Variable used for storing the new AshtottariDasaGraphicsItem,
        # as it is modified in AshtottariDasaToolMode.
        self.ashtottariDasaGraphicsItem = None

        # Variable used for storing the new YoginiDasaGraphicsItem,
        # as it is modified in YoginiDasaToolMode.
        self.yoginiDasaGraphicsItem = None

        # Variable used for storing the new DwisaptatiSamaDasaGraphicsItem,
        # as it is modified in DwisaptatiSamaDasaToolMode.
        self.dwisaptatiSamaDasaGraphicsItem = None

        # Variable used for storing the new ShattrimsaSamaDasaGraphicsItem,
        # as it is modified in ShattrimsaSamaDasaToolMode.
        self.shattrimsaSamaDasaGraphicsItem = None

        # Variable used for storing the new DwadasottariDasaGraphicsItem,
        # as it is modified in DwadasottariDasaToolMode.
        self.dwadasottariDasaGraphicsItem = None

        # Variable used for storing the new ChaturaseetiSamaDasaGraphicsItem,
        # as it is modified in ChaturaseetiSamaDasaToolMode.
        self.chaturaseetiSamaDasaGraphicsItem = None

        # Variable used for storing the new SataabdikaDasaGraphicsItem,
        # as it is modified in SataabdikaDasaToolMode.
        self.sataabdikaDasaGraphicsItem = None

        # Variable used for storing the new ShodasottariDasaGraphicsItem,
        # as it is modified in ShodasottariDasaToolMode.
        self.shodasottariDasaGraphicsItem = None

        # Variable used for storing the new PanchottariDasaGraphicsItem,
        # as it is modified in PanchottariDasaToolMode.
        self.panchottariDasaGraphicsItem = None

        # Variable used for storing the new ShashtihayaniDasaGraphicsItem,
        # as it is modified in ShashtihayaniDasaToolMode.
        self.shashtihayaniDasaGraphicsItem = None

        # Variable used for storing that snapping to the closest pricebar
        # time or price is enabled.
        #
        # Used in:
        #   - BarCountTool
        #   - TimeMeasurementTool
        #   - PriceMeasurementTool
        #   - TimeModalScaleTool
        #   - PriceModalScaleTool
        #   - PlanetLongitudeMovementMeasurementToolMode
        #   - PriceTimeInfoTool
        #   - TimeRetracementTool
        #   - PriceRetracementTool
        #   - PriceTimeVectorTool
        #   - LineSegment1Tool
        #   - LineSegment2Tool
        #   - VerticalLineSegmentTool
        #   - HorizontalLineSegmentTool
        #   - OctaveFanTool
        #   - FibFanTool
        #   - GannFanTool
        #   - VimsottariDasaTool
        #   - AshtottariDasaTool
        #   - YoginiDasaTool
        #   - DwisaptatiSamaDasaTool
        #   - ShattrimsaSamaDasaTool
        #   - DwadasottariDasaTool
        #   - ChaturaseetiSamaDasaTool
        #   - SataabdikaDasaTool
        #   - ShodasottariDasaTool
        #   - PanchottariDasaTool
        #   - ShashtihayaniDasaTool
        #
        # Note: For these tools below, the snap will work with 
        # both PriceBars and LookbackMultiplePriceBars:
        #
        #   - PriceTimeInfoTool
        #   - LineSegment1Tool
        #   - LineSegment2Tool
        #   - VerticalLineSegmentTool
        #
        self.snapEnabledFlag = True

        # Variable used for holding the PriceBarChartSettings.
        self.priceBarChartSettings = PriceBarChartSettings()
        
        # Get the QSetting key for the zoom scaling amounts.
        self.zoomScaleFactorSettingsKey = \
            SettingsKeys.zoomScaleFactorSettingsKey 

        #self.setTransformationAnchor(QGraphicsView.NoAnchor)
        self.setResizeAnchor(QGraphicsView.AnchorUnderMouse)
        self.setInteractive(True)

        # Set some rendering settings so things draw nicely.
        self.setRenderHints(QPainter.Antialiasing | 
                            QPainter.TextAntialiasing | 
                            QPainter.SmoothPixmapTransform)

        # Set to FullViewportUpdate update mode.
        #
        # The default is normally QGraphicsView.MinimalViewportUpdate, but
        # this caused us to have missing parts of artifacts and missing
        # parts of pricebars.  And while performance isn't as great in
        # the FullViewportUpdate mode, we dont' have many things dynamically
        # updating and changing, so it isn't too big of an issue.
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        #self.setViewportUpdateMode(QGraphicsView.MinimalViewportUpdate)

    def setPriceBarChartSettings(self, priceBarChartSettings):
        """Stores the reference to PriceBarChartSettings to be used in
        creating new QGraphicsItems.
        """
        
        self.priceBarChartSettings = priceBarChartSettings
        
    def setGraphicsItemFlagsPerCurrToolMode(self, item):
        """Sets the QGraphicsItem flags of the given QGraphicsItem,
        according to what the flags should be set to for the current
        tool mode.

        Arguments:

        item - QGraphicsItem that needs its flags set.
        """

        #self.log.debug("setGraphicsItemFlagsPerCurrToolMode(): " +
        #               "toolMode == {}.  ".format(self.toolMode) +
        #               "type(item) == {}.  ".format(type(item)) +
        #               "item is of type PriceBarGraphicsItem: {}.  ".\
        #               format(isinstance(item, PriceBarGraphicsItem)) +
        #               "item is of type PriceBarChartArtifactGraphicsItem: " +
        #               "{}.".
        #               format(isinstance(item,
        #                                 PriceBarChartArtifactGraphicsItem)))
                       
        if self.toolMode == \
               PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                flags = QGraphicsItem.GraphicsItemFlags(QGraphicsItem.
                                                        ItemIsSelectable)
                item.setFlags(flags)
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                flags = QGraphicsItem.\
                    GraphicsItemFlags(QGraphicsItem.ItemIsSelectable)
                item.setFlags(flags)
                
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PointerTool']:
             
            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setReadOnlyFlag(False)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(False)

                flags = QGraphicsItem.\
                    GraphicsItemFlags(QGraphicsItem.ItemIsMovable +
                                      QGraphicsItem.ItemIsSelectable)
                item.setFlags(flags)
                
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HandTool']:
             
            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomInTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
             
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomOutTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['BarCountTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeMeasurementTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeModalScaleTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceModalScaleTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PlanetLongitudeMovementMeasurementTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TextTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeInfoTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceMeasurementTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeRetracementTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceRetracementTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeVectorTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment1Tool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment2Tool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VerticalLineSegmentTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HorizontalLineSegmentTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['OctaveFanTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['FibFanTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['GannFanTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VimsottariDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['AshtottariDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['YoginiDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwisaptatiSamaDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShattrimsaSamaDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwadasottariDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ChaturaseetiSamaDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['SataabdikaDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShodasottariDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PanchottariDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShashtihayaniDasaTool']:

            if isinstance(item, PriceBarGraphicsItem) or \
               isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))
            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                item.setReadOnlyFlag(True)
                item.setFlags(QGraphicsItem.GraphicsItemFlags(0))

                
    def toReadOnlyPointerToolMode(self):
        """Changes the tool mode to be the ReadOnlyPointerTool.
        
        This has the following effects on QGraphicsItem flags:
          - All PriceBarGraphicsItems are selectable.
          - All PriceBarGraphicsItems are not movable.
          - All LookbackMultiplePriceBarGraphicsItem are selectable.
          - All LookbackMultiplePriceBarGraphicsItem are not movable.
          - All PriceBarChartArtifactGraphicsItem are selectable.
          - All PriceBarChartArtifactGraphicsItem are not movable.
        """

        self.log.debug("Entered toReadOnlyPointerToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.RubberBandDrag)

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)

        self.log.debug("Exiting toReadOnlyPointerToolMode()")

    def toPointerToolMode(self):
        """Changes the tool mode to be the PointerTool.
        
        This has the following effects on QGraphicsItem flags:
          - All PriceBarGraphicsItems are not selectable.
          - All PriceBarGraphicsItems are not movable.
          - All LookbackMultiplePriceBarGraphicsItem are not selectable.
          - All LookbackMultiplePriceBarGraphicsItem are not movable.
          - All PriceBarChartArtifactGraphicsItem are selectable.
          - All PriceBarChartArtifactGraphicsItem are movable.
        """

        self.log.debug("Entered toPointerToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartGraphicsView.ToolMode['PointerTool']:
            self.toolMode = PriceBarChartGraphicsView.ToolMode['PointerTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.RubberBandDrag)

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
            
        self.log.debug("Exiting toPointerToolMode()")

    def toHandToolMode(self):
        """Changes the tool mode to be the HandTool."""

        self.log.debug("Entered toHandToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartGraphicsView.ToolMode['HandTool']:
            self.toolMode = PriceBarChartGraphicsView.ToolMode['HandTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.ScrollHandDrag)

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)

        self.log.debug("Exiting toHandToolMode()")

    def toZoomInToolMode(self):
        """Changes the tool mode to be the ZoomInTool."""

        self.log.debug("Entered toZoomInToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartGraphicsView.ToolMode['ZoomInTool']:
            self.toolMode = PriceBarChartGraphicsView.ToolMode['ZoomInTool']

            self.setDragMode(QGraphicsView.NoDrag)
            self.setCursor(QCursor(Qt.ArrowCursor))

            if self.underMouse():
                pixmap = QPixmap(":/images/rluu/zoomIn.png")
                self.setCursor(QCursor(pixmap))

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toZoomInToolMode()")

    def toZoomOutToolMode(self):
        """Changes the tool mode to be the ZoomOutTool."""

        self.log.debug("Entered toZoomOutToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != PriceBarChartGraphicsView.ToolMode['ZoomOutTool']:
            self.toolMode = PriceBarChartGraphicsView.ToolMode['ZoomOutTool']

            self.setDragMode(QGraphicsView.NoDrag)
            self.setCursor(QCursor(Qt.ArrowCursor))

            if self.underMouse():
                pixmap = QPixmap(":/images/rluu/zoomOut.png")
                self.setCursor(QCursor(pixmap))

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toZoomOutToolMode()")

    def toBarCountToolMode(self):
        """Changes the tool mode to be the BarCountTool."""

        self.log.debug("Entered toBarCountToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['BarCountTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['BarCountTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.barCountGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toBarCountToolMode()")

    def toTimeMeasurementToolMode(self):
        """Changes the tool mode to be the TimeMeasurementTool."""

        self.log.debug("Entered toTimeMeasurementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['TimeMeasurementTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['TimeMeasurementTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.timeMeasurementGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toTimeMeasurementToolMode()")

    def toTimeModalScaleToolMode(self):
        """Changes the tool mode to be the TimeModalScaleTool."""

        self.log.debug("Entered toTimeModalScaleToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['TimeModalScaleTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['TimeModalScaleTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.timeModalScaleGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toTimeModalScaleToolMode()")

    def toPriceModalScaleToolMode(self):
        """Changes the tool mode to be the PriceModalScaleTool."""

        self.log.debug("Entered toPriceModalScaleToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['PriceModalScaleTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['PriceModalScaleTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.priceModalScaleGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toPriceModalScaleToolMode()")

    def toPlanetLongitudeMovementMeasurementToolMode(self):
        """Changes the tool mode to be the PlanetLongitudeMovementMeasurementTool."""

        self.log.debug("Entered toPlanetLongitudeMovementMeasurementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['PlanetLongitudeMovementMeasurementTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['PlanetLongitudeMovementMeasurementTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.planetLongitudeMovementMeasurementGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toPlanetLongitudeMovementMeasurementToolMode()")

    def toTextToolMode(self):
        """Changes the tool mode to be the TextTool."""

        self.log.debug("Entered toTextToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['TextTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['TextTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.textGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toTextToolMode()")

    def toPriceTimeInfoToolMode(self):
        """Changes the tool mode to be the PriceTimeInfoTool."""

        self.log.debug("Entered toPriceTimeInfoToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['PriceTimeInfoTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['PriceTimeInfoTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.priceTimeInfoGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toPriceTimeInfoToolMode()")

    def toPriceMeasurementToolMode(self):
        """Changes the tool mode to be the PriceMeasurementTool."""

        self.log.debug("Entered toPriceMeasurementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['PriceMeasurementTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['PriceMeasurementTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.priceMeasurementGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toPriceMeasurementToolMode()")

    def toTimeRetracementToolMode(self):
        """Changes the tool mode to be the TimeRetracementTool."""

        self.log.debug("Entered toTimeRetracementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['TimeRetracementTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['TimeRetracementTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.timeRetracementGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toTimeRetracementToolMode()")

    def toPriceRetracementToolMode(self):
        """Changes the tool mode to be the PriceRetracementTool."""

        self.log.debug("Entered toPriceRetracementToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['PriceRetracementTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['PriceRetracementTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.priceRetracementGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toPriceRetracementToolMode()")

    def toPriceTimeVectorToolMode(self):
        """Changes the tool mode to be the PriceTimeVectorTool."""

        self.log.debug("Entered toPriceTimeVectorToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['PriceTimeVectorTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['PriceTimeVectorTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.priceTimeVectorGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toPriceTimeVectorToolMode()")

    def toLineSegment1ToolMode(self):
        """Changes the tool mode to be the LineSegment1Tool."""

        self.log.debug("Entered toLineSegment1ToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['LineSegment1Tool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['LineSegment1Tool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.lineSegment1GraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toLineSegment1ToolMode()")

    def toLineSegment2ToolMode(self):
        """Changes the tool mode to be the LineSegment2Tool."""

        self.log.debug("Entered toLineSegment2ToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['LineSegment2Tool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['LineSegment2Tool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.lineSegment2GraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toLineSegment2ToolMode()")

    def toVerticalLineSegmentToolMode(self):
        """Changes the tool mode to be the VerticalLineSegmentTool."""

        self.log.debug("Entered toVerticalLineSegmentToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['VerticalLineSegmentTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['VerticalLineSegmentTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.verticalLineSegmentGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toVerticalLineSegmentToolMode()")

    def toHorizontalLineSegmentToolMode(self):
        """Changes the tool mode to be the HorizontalLineSegmentTool."""

        self.log.debug("Entered toHorizontalLineSegmentToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['HorizontalLineSegmentTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['HorizontalLineSegmentTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.horizontalLineSegmentGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toHorizontalLineSegmentToolMode()")

    def toOctaveFanToolMode(self):
        """Changes the tool mode to be the OctaveFanTool."""

        self.log.debug("Entered toOctaveFanToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['OctaveFanTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['OctaveFanTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.clickThreePointF = None
            self.octaveFanGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toOctaveFanToolMode()")

    def toFibFanToolMode(self):
        """Changes the tool mode to be the FibFanTool."""

        self.log.debug("Entered toFibFanToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['FibFanTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['FibFanTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.clickThreePointF = None
            self.fibFanGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toFibFanToolMode()")

    def toGannFanToolMode(self):
        """Changes the tool mode to be the GannFanTool."""

        self.log.debug("Entered toGannFanToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['GannFanTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['GannFanTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.clickThreePointF = None
            self.gannFanGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toGannFanToolMode()")

    def toVimsottariDasaToolMode(self):
        """Changes the tool mode to be the VimsottariDasaTool."""

        self.log.debug("Entered toVimsottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['VimsottariDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['VimsottariDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.vimsottariDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toVimsottariDasaToolMode()")

    def toAshtottariDasaToolMode(self):
        """Changes the tool mode to be the AshtottariDasaTool."""

        self.log.debug("Entered toAshtottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['AshtottariDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['AshtottariDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.ashtottariDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toAshtottariDasaToolMode()")

    def toYoginiDasaToolMode(self):
        """Changes the tool mode to be the YoginiDasaTool."""

        self.log.debug("Entered toYoginiDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['YoginiDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['YoginiDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.yoginiDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toYoginiDasaToolMode()")

    def toDwisaptatiSamaDasaToolMode(self):
        """Changes the tool mode to be the DwisaptatiSamaDasaTool."""

        self.log.debug("Entered toDwisaptatiSamaDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['DwisaptatiSamaDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['DwisaptatiSamaDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.dwisaptatiSamaDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toDwisaptatiSamaDasaToolMode()")

    def toShattrimsaSamaDasaToolMode(self):
        """Changes the tool mode to be the ShattrimsaSamaDasaTool."""

        self.log.debug("Entered toShattrimsaSamaDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['ShattrimsaSamaDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['ShattrimsaSamaDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.shattrimsaSamaDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toShattrimsaSamaDasaToolMode()")

    def toDwadasottariDasaToolMode(self):
        """Changes the tool mode to be the DwadasottariDasaTool."""

        self.log.debug("Entered toDwadasottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['DwadasottariDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['DwadasottariDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.dwadasottariDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toDwadasottariDasaToolMode()")

    def toChaturaseetiSamaDasaToolMode(self):
        """Changes the tool mode to be the ChaturaseetiSamaDasaTool."""

        self.log.debug("Entered toChaturaseetiSamaDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['ChaturaseetiSamaDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['ChaturaseetiSamaDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.chaturaseetiSamaDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toChaturaseetiSamaDasaToolMode()")

    def toSataabdikaDasaToolMode(self):
        """Changes the tool mode to be the SataabdikaDasaTool."""

        self.log.debug("Entered toSataabdikaDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['SataabdikaDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['SataabdikaDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.sataabdikaDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toSataabdikaDasaToolMode()")

    def toShodasottariDasaToolMode(self):
        """Changes the tool mode to be the ShodasottariDasaTool."""

        self.log.debug("Entered toShodasottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['ShodasottariDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['ShodasottariDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.shodasottariDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toShodasottariDasaToolMode()")

    def toPanchottariDasaToolMode(self):
        """Changes the tool mode to be the PanchottariDasaTool."""

        self.log.debug("Entered toPanchottariDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['PanchottariDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['PanchottariDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.panchottariDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toPanchottariDasaToolMode()")

    def toShashtihayaniDasaToolMode(self):
        """Changes the tool mode to be the ShashtihayaniDasaTool."""

        self.log.debug("Entered toShashtihayaniDasaToolMode()")

        # Only do something if it is not currently in this mode.
        if self.toolMode != \
                PriceBarChartGraphicsView.ToolMode['ShashtihayaniDasaTool']:

            self.toolMode = \
                PriceBarChartGraphicsView.ToolMode['ShashtihayaniDasaTool']

            self.setCursor(QCursor(Qt.ArrowCursor))
            self.setDragMode(QGraphicsView.NoDrag)

            # Clear out internal working variables.
            self.clickOnePointF = None
            self.clickTwoPointF = None
            self.shashtihayaniDasaGraphicsItem = None

            scene = self.scene()
            if scene != None:
                scene.clearSelection()

                items = scene.items()
                for item in items:
                    self.setGraphicsItemFlagsPerCurrToolMode(item)
                    
        self.log.debug("Exiting toShashtihayaniDasaToolMode()")

    def createContextMenu(self, clickPosF, readOnlyFlag):
        """Creates a context menu for a right-click somewhere in
        the QGraphicsView, and returns it.

        Arguments:
        clickPosF - QPointF object of the right-click location,
            in scene coordinates.
        readOnlyFlag - bool value that indicates whether or not to
            bring up the menu options for the readonly
            mode or not.
        """

        scene = self.scene()

        # See if the user has right clicked on a QGraphicsItem.
        items = []
        if scene != None:
            items = scene.items(clickPosF,
                                Qt.ContainsItemBoundingRect,
                                Qt.AscendingOrder)

        # Here count the number of items at this position that
        # we care about for creating a context menu for.
        debugLogStr = ""
        numContextSubMenuItems = 0

        menu = QMenu(self)
        menu.setTitle("PriceBarChartGraphicsView context menu")
        parent = None

        
        for item in items:
            if isinstance(item, PriceBarGraphicsItem):
                debugLogStr += \
                    "PriceBarGraphicsItem with PriceBar: " + \
                    item.priceBar.toString() + ". "
                
                numContextSubMenuItems += 1

                # Add the menu for this item.  We create the menu this
                # way so that 'submenu' is owned by 'menu'.
                submenu = menu.addMenu("")
                
                # Append actions and update the submenu title.
                item.appendActionsToContextMenu(submenu,
                                                readOnlyMode=readOnlyFlag)

            elif isinstance(item, LookbackMultiplePriceBarGraphicsItem):
                debugLogStr += \
                    "LookbackMultiplePriceBarGraphicsItem with " + \
                    "LookbackMultiplePriceBar: " + \
                    item.getLookbackMultiplePriceBar().toString() + ". "
                
                numContextSubMenuItems += 1

                # Add the menu for this item.  We create the menu this
                # way so that 'submenu' is owned by 'menu'.
                submenu = menu.addMenu("")
                
                # Append actions and update the submenu title.
                item.appendActionsToContextMenu(submenu,
                                                readOnlyMode=readOnlyFlag)

            elif isinstance(item, PriceBarChartArtifactGraphicsItem):
                debugLogStr += \
                    "PriceBarChartArtifactGraphicsItem with " + \
                    "artifact info: " + item.artifact.toString() + ". "

                numContextSubMenuItems += 1

                # Add the menu for this item.  We create the menu this
                # way so that 'submenu' is owned by 'menu'.
                submenu = menu.addMenu("")
                
                # Append actions and update the submenu title.
                item.appendActionsToContextMenu(submenu,
                                                readOnlyMode=readOnlyFlag)
            else:
                self.log.debug("Non-PriceBar, " + \
                               "Non-LookbackMultiplePriceBar " + \
                               "and Non-artifact item.")


        self.log.debug("{} items under scene clickPosF({}, {}): {}".\
                       format(numContextSubMenuItems,
                              clickPosF.x(),
                              clickPosF.y(),
                              debugLogStr))

        # Add context menu options that are available for all locations.
        menu.addSeparator()

        # Here I am creating QActions that will handle the QMenu
        # option selection, but for setting astro times, I have to
        # jump through a few hoops to be able to pass the
        # information about the recent right-click that caused the
        # context menu to come up.  Maybe there's a better way to
        # do this.
        setAstro1Action = QAction("Set timestamp on Astro Chart 1", parent)
        setAstro2Action = QAction("Set timestamp on Astro Chart 2", parent)
        setAstro3Action = QAction("Set timestamp on Astro Chart 3", parent)
        openJHoraAction = QAction("Open JHora with timestamp", parent)
        openAstrologAction = QAction("Open Astrolog with timestamp", parent)

        # Store in each of the actions, a tuple containing:
        #   - The method to invoke within the slot that gets run.
        #   - The argument to the method that will get invoked within
        #     the slot that gets run.
        setAstro1Action.setData((self._handleSetAstro1Action, clickPosF))
        setAstro2Action.setData((self._handleSetAstro2Action, clickPosF))
        setAstro3Action.setData((self._handleSetAstro3Action, clickPosF))
        openJHoraAction.setData((self._handleOpenJHoraAction, clickPosF))
        openAstrologAction.setData((self._handleOpenAstrologAction, clickPosF))

        # Define a method to add to each instance of these QAction
        # that we have instantiated.  This method will be the slot
        # that is called when the QAction is triggered.
        #
        def handleActionTriggered(self):
            """
            This is a hack.
            
            This method basically just invokes another method providing an
            argument.  I need this method because we do not have a way to
            connect the 'triggered' signal of QAction to another method
            that takes arguments because the 'triggered' signal does
            not allow us to pass arguments to its connected slot.
            
            Arguments:
                 self - The reference to the QAction instance that has
                        this method bound to its instance.
                        Assumes that self.setData() was called, and that the
                        data set in the QVariant there stores a tuple
                        containing:
                        
                          - The method to invoke.
                          - The argument to that method.
            """

            # Get the tuple that was stored in the QAction as a QVariant.
            tup = self.data()

            # Extract the method to invoke, and the argument to that method.
            methodToInvoke = tup[0]
            argument = tup[1]
            
            # Invoke the method.
            methodToInvoke(argument)
            
        # Add the method to the QAction instances.
        setAstro1Action.handleActionTriggered = \
            types.MethodType(handleActionTriggered,
                             setAstro1Action)
        setAstro2Action.handleActionTriggered = \
            types.MethodType(handleActionTriggered,
                             setAstro2Action)
        setAstro3Action.handleActionTriggered = \
            types.MethodType(handleActionTriggered,
                             setAstro3Action)
        openJHoraAction.handleActionTriggered = \
            types.MethodType(handleActionTriggered,
                             openJHoraAction)
        openAstrologAction.handleActionTriggered = \
            types.MethodType(handleActionTriggered,
                             openAstrologAction)
        
        # Connect the triggered signal to the slot we appended
        # to the instances.
        setAstro1Action.triggered.\
            connect(setAstro1Action.handleActionTriggered)
        setAstro2Action.triggered.\
            connect(setAstro2Action.handleActionTriggered)
        setAstro3Action.triggered.\
            connect(setAstro3Action.handleActionTriggered)
        openJHoraAction.triggered.\
            connect(openJHoraAction.handleActionTriggered)
        openAstrologAction.triggered.\
            connect(openAstrologAction.handleActionTriggered)

        menu.addAction(setAstro1Action)
        menu.addAction(setAstro2Action)
        menu.addAction(setAstro3Action)
        menu.addAction(openJHoraAction)
        menu.addAction(openAstrologAction)

        return menu
    
    def _handleSetAstro1Action(self, clickPosF):
        """Handles when the user triggers a QAction for setting the
        astro chart.
        """

        scene = self.scene()

        # The scene X position represents the time.
        if scene != None: 
            self.scene().setAstroChart1(clickPosF.x())
        
    def _handleSetAstro2Action(self, clickPosF):
        """Handles when the user triggers a QAction for setting the
        astro chart.
        """

        scene = self.scene()

        # The scene X position represents the time.
        if scene != None: 
            self.scene().setAstroChart2(clickPosF.x())
        
    def _handleSetAstro3Action(self, clickPosF):
        """Handles when the user triggers a QAction for setting the
        astro chart.
        """

        scene = self.scene()

        # The scene X position represents the time.
        if scene != None: 
            self.scene().setAstroChart3(clickPosF.x())
        
    def _handleOpenJHoraAction(self, clickPosF):
        """Causes the timestamp of this GraphicsItem to be opened in
        JHora.
        """

        scene = self.scene()

        # The GraphicsItem's scene X position represents the time.
        if scene != None: 
            self.scene().openJHora(clickPosF.x())
        
    def _handleOpenAstrologAction(self, clickPosF):
        """Causes the timestamp of this GraphicsItem to be opened in
        Astrolog.
        """

        scene = self.scene()

        # The GraphicsItem's scene X position represents the time.
        if scene != None: 
            self.scene().openAstrolog(clickPosF.x())
        
    def wheelEvent(self, qwheelevent):
        """Triggered when the mouse wheel is scrolled."""

        self.log.debug("Entered wheelEvent()")

        # Save the old transformation anchor and change the current on
        # to anchor under the mouse.  We will put it back at the end
        # of this method.
        oldViewportAnchor = self.transformationAnchor()
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        
        # Get the QSetting key for the zoom scaling amounts.
        settings = QSettings()
        scaleFactor = \
            settings.value(self.zoomScaleFactorSettingsKey, \
                           SettingsKeys.zoomScaleFactorSettingsDefValue,
                           type=float)
                       
        self.log.debug("Before, Scaling: dx == {}, dy == {}".\
                       format(self.transform().m11(),
                              self.transform().m22()))
                              
        # Actually do the scaling of the view.
        # In Qt5, 'delta()' was deprecated.
        if (hasattr(qwheelevent, 'delta') and qwheelevent.delta() > 0) or \
           (hasattr(qwheelevent, 'angleDelta') and qwheelevent.angleDelta().y() > 0):
                    
            # Zoom in.
            self.scale(scaleFactor, scaleFactor)
        else:
            # Zoom out.
            self.scale(1.0 / scaleFactor, 1.0 / scaleFactor)

        self.log.debug("After,  Scaling: dx == {}, dy == {}".\
                       format(self.transform().m11(),
                              self.transform().m22()))
        
        # Put the old transformation anchor back.
        self.setTransformationAnchor(oldViewportAnchor)
        
        self.log.debug("Exiting wheelEvent()")

    def keyPressEvent(self, qkeyevent):
        """Overwrites the QGraphicsView.keyPressEvent() function.
        Called when a key is pressed.
        """

        self.log.debug("Entered keyPressEvent()")

        # Handle key functionality relevant to all tool modes.
        if self.toolMode in PriceBarChartGraphicsView.ToolMode.values():

            if qkeyevent.key() == Qt.Key_V:
                self.log.debug("V key was pressed.")

                # Invert the flag that indicates that a 
                # dashed vertical line should be drawn where the 
                # mouse cursor is.
                self.verticalDashedLineEnabled = \
                    not self.verticalDashedLineEnabled

                self.log.debug("self.verticalDashedLineEnabled is now {}".\
                               format(self.verticalDashedLineEnabled))

                if self.verticalDashedLineEnabled == False:

                    # Drawing the vertical dashed line is no longer enabled, so
                    # remove the vertical dashed line item.

                    self.statusMessageUpdate.emit("Vertical dashed line disabled.")

                    if self.verticalDashedLineGraphicsItem != None and \
                            self.verticalDashedLineGraphicsItem.scene() != None:

                        self.log.debug("Removing item.")
                        self.scene().removeItem(self.verticalDashedLineGraphicsItem)

                    self.verticalDashedLineGraphicsItem = None

                    # No need to emit any signals that an item is removed
                    # because this item is transient and has no backing
                    # artifact object.

                elif self.verticalDashedLineEnabled == True:

                    # Vertical dashed line is enabled, so create/update it.

                    self.statusMessageUpdate.emit("Vertical dashed line enabled.")

                    if self.verticalDashedLineGraphicsItem == None:

                        self.log.debug("Adding item.")

                        # Create the vertical dashed line.
                        self.verticalDashedLineGraphicsItem = \
                            TransientDashedLineSegmentGraphicsItem()
                        self.verticalDashedLineGraphicsItem.\
                            loadSettingsFromPriceBarChartSettings(\
                                self.priceBarChartSettings)
    
                        self.scene().addItem(self.verticalDashedLineGraphicsItem)
    
                        self.verticalDashedLineGraphicsItem.\
                            setFlags(QGraphicsItem.GraphicsItemFlags(0))

                    # Gather information for setting the line's location 
                    # and start/end points.

                    # Get the lowest and highest prices among both PriceBars and 
                    # LookbackMultiplePriceBars.
                    lowestPrice = self.scene().getLowestPriceBar().low
                    highestPrice = self.scene().getHighestPriceBar().high
    
                    lowestLookbackMultiplePriceBar = \
                        self.scene().getLowestLookbackMultiplePriceBar()
                    if lowestLookbackMultiplePriceBar != None:
                        lmpbLowestPrice = lowestLookbackMultiplePriceBar.low
                        if lmpbLowestPrice < lowestPrice:
                            lowestPrice = lmpbLowestPrice
    
                    highestLookbackMultiplePriceBar = \
                        self.scene().getHighestLookbackMultiplePriceBar()
                    if highestLookbackMultiplePriceBar != None:
                        lmpbHighestPrice = highestLookbackMultiplePriceBar.high
                        if lmpbHighestPrice > highestPrice:
                            highestPrice = lmpbHighestPrice
    
                    lowY = self.scene().priceToSceneYPos(lowestPrice)
                    highY = self.scene().priceToSceneYPos(highestPrice)

                    posX = None
                    if self.lastMousePosScene != None:
                        posX = self.lastMousePosScene.x()
                    else:
                        # No last mouse position, so just use the X position 
                        # of an arbitrary PriceBar in the scene.
                        dt = self.scene().getHighestPriceBar().timestamp
                        posX = self.scene().datetimeToSceneXPos(dt)

                    lowPointF = QPointF(posX, lowY)
                    highPointF = QPointF(posX, highY)
    
                    # Set the position and start/end points.
                    self.verticalDashedLineGraphicsItem.setPos(lowPointF)
                    self.verticalDashedLineGraphicsItem.setStartPointF(lowPointF)
                    self.verticalDashedLineGraphicsItem.setEndPointF(highPointF)

                    # No need to emit any signals that an item is changed
                    # because this item is transient and has no backing
                    # artifact object.

            elif qkeyevent.key() == Qt.Key_H:
                self.log.debug("H key was pressed.")

                # Invert the flag that indicates that a 
                # dashed horizontal line should be drawn where the 
                # mouse cursor is.
                self.horizontalDashedLineEnabled = \
                    not self.horizontalDashedLineEnabled

                if self.horizontalDashedLineEnabled == False:

                    # Drawing the horizontal dashed line is no longer enabled, so
                    # remove the horizontal dashed line item.

                    self.statusMessageUpdate.emit("Horizontal dashed line disabled.")

                    if self.horizontalDashedLineGraphicsItem != None and \
                            self.horizontalDashedLineGraphicsItem.scene() != None:

                        self.log.debug("Removing item.")
                        self.scene().removeItem(self.horizontalDashedLineGraphicsItem)

                    self.horizontalDashedLineGraphicsItem = None

                    # No need to emit any signals that an item is removed
                    # because this item is transient and has no backing
                    # artifact object.

                elif self.horizontalDashedLineEnabled == True:

                    # Horizontal dashed line is enabled, so create/update it.

                    self.statusMessageUpdate.emit("Horizontal dashed line enabled.")

                    if self.horizontalDashedLineGraphicsItem == None:
                        # Create the horizontal dashed line.
                        self.horizontalDashedLineGraphicsItem = \
                            TransientDashedLineSegmentGraphicsItem()
                        self.horizontalDashedLineGraphicsItem.\
                            loadSettingsFromPriceBarChartSettings(\
                                self.priceBarChartSettings)
    
                        self.scene().addItem(self.horizontalDashedLineGraphicsItem)
    
                        self.horizontalDashedLineGraphicsItem.\
                            setFlags(QGraphicsItem.GraphicsItemFlags(0))

                    # Gather information for setting the line's location 
                    # and start/end points.
                    
                    # Get the earliest and latest timestamps among both PriceBars 
                    # and LookbackMultiplePriceBars.
                    earliestDt = self.scene().getEarliestPriceBar().timestamp
                    latestDt = self.scene().getLatestPriceBar().timestamp
    
                    earliestLookbackMultiplePriceBar = \
                        self.scene().getEarliestLookbackMultiplePriceBar()
                    if earliestLookbackMultiplePriceBar != None:
                        lmpbEarliestDt = \
                            earliestLookbackMultiplePriceBar.timestamp
                        if lmpbEarliestDt < earliestDt:
                            earliestDt = lmpbEarliestDt
    
                    latestLookbackMultiplePriceBar = \
                        self.scene().getLatestLookbackMultiplePriceBar()
                    if latestLookbackMultiplePriceBar != None:
                        lmpbLatestDt = \
                            latestLookbackMultiplePriceBar.timestamp
                        if lmpbLatestDt > latestDt:
                            latestDt = lmpbLatestDt
    
                    earliestX = self.scene().datetimeToSceneXPos(earliestDt)
                    latestX = self.scene().datetimeToSceneXPos(latestDt)
    
                    posY = None
                    if self.lastMousePosScene != None:
                        posY = self.lastMousePosScene.y()
                    else:
                        # No last mouse position, so just use the Y position 
                        # of an arbitrary PriceBar in the scene.
                        highPrice = self.scene().getLatestPriceBar().high
                        posY = self.scene().priceToSceneYPos(highPrice)
    
                    earliestPointF = QPointF(earliestX, posY)
                    latestPointF = QPointF(latestX, posY)

                    # Set the position and start/end points.
                    self.horizontalDashedLineGraphicsItem.setPos(earliestPointF)
                    self.horizontalDashedLineGraphicsItem.setStartPointF(earliestPointF)
                    self.horizontalDashedLineGraphicsItem.setEndPointF(latestPointF)
    
                    # No need to emit any signals that an item is changed
                    # because this item is transient and has no backing
                    # artifact object.


        # Handle key functionality relevant to each particular tool mode.

        if self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Unselect any selected items.
                self.log.debug("Escape key pressed while in " +
                               "'ReadOnlyPointerTool' mode")
                self.scene().clearSelection()
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PointerTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Unselect any selected items.
                self.log.debug("Escape key pressed while in 'PointerTool' mode")
                self.scene().clearSelection()
            elif qkeyevent.matches(QKeySequence.Delete):
                # Get the items that are selected, and out of those,
                # remove the PriceBarChartArtifactGraphicsItems.
                self.log.debug("Delete key pressed while in 'PointerTool' mode")
                
                scene = self.scene()
                selectedItems = scene.selectedItems()

                for item in selectedItems:
                    if isinstance(item, PriceBarChartArtifactGraphicsItem):

                        self.log.debug("Removing item with artifact: " +
                                       item.getArtifact().getInternalName())
                        if item.scene() != None:
                            scene.removeItem(item)
        
                        # Emit signal to show that an item is removed.
                        # This sets the dirty flag.
                        scene.priceBarChartArtifactGraphicsItemRemoved.\
                            emit(item)
            else:
                # See what item type(s) are selected and take action
                # based on that.

                scene = self.scene()
                selectedItems = scene.selectedItems()

                for item in selectedItems:
                    if isinstance(item, TimeModalScaleGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "TimeModalScaleGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "TimeModalScaleGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "TimeModalScaleGraphicsItem reversed")
                    elif isinstance(item, PriceModalScaleGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "PriceModalScaleGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "PriceModalScaleGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "PriceModalScaleGraphicsItem reversed")
                    elif isinstance(item, OctaveFanGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "OctaveFanGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "OctaveFanGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "OctaveFanGraphicsItem reversed")
                    elif isinstance(item, VimsottariDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "VimsottariDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "VimsottariDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "VimsottariDasaGraphicsItem reversed")
                    elif isinstance(item, AshtottariDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "AshtottariDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "AshtottariDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "AshtottariDasaGraphicsItem reversed")
                    elif isinstance(item, YoginiDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "YoginiDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "YoginiDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "YoginiDasaGraphicsItem reversed")
                    elif isinstance(item, DwisaptatiSamaDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "DwisaptatiSamaDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "DwisaptatiSamaDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "DwisaptatiSamaDasaGraphicsItem reversed")
                    elif isinstance(item, ShattrimsaSamaDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "ShattrimsaSamaDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "ShattrimsaSamaDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "ShattrimsaSamaDasaGraphicsItem reversed")
                    elif isinstance(item, DwadasottariDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "DwadasottariDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "DwadasottariDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "DwadasottariDasaGraphicsItem reversed")
                    elif isinstance(item, ChaturaseetiSamaDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "ChaturaseetiSamaDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "ChaturaseetiSamaDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "ChaturaseetiSamaDasaGraphicsItem reversed")
                    elif isinstance(item, SataabdikaDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "SataabdikaDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "SataabdikaDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "SataabdikaDasaGraphicsItem reversed")
                    elif isinstance(item, ShodasottariDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "ShodasottariDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "ShodasottariDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "ShodasottariDasaGraphicsItem reversed")
                    elif isinstance(item, PanchottariDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "PanchottariDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "PanchottariDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "PanchottariDasaGraphicsItem reversed")
                    elif isinstance(item, ShashtihayaniDasaGraphicsItem):
                        if qkeyevent.key() == Qt.Key_S:
                            item.rotateUp()
                            self.statusMessageUpdate.emit(\
                                "ShashtihayaniDasaGraphicsItem rotated UP")
                        elif qkeyevent.key() == Qt.Key_G:
                            item.rotateDown()
                            self.statusMessageUpdate.emit(\
                                "ShashtihayaniDasaGraphicsItem rotated DOWN")
                        elif qkeyevent.key() == Qt.Key_R:
                            item.reverse()
                            self.statusMessageUpdate.emit(\
                                "ShashtihayaniDasaGraphicsItem reversed")

                # Pass the key event upwards in case it applies to
                # something else (like a parent widget).
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HandTool']:

            super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomInTool']:

            super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomOutTool']:

            super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['BarCountTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited bar count item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.barCountGraphicsItem != None:
                    if self.barCountGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.barCountGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.barCountGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeMeasurementTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.timeMeasurementGraphicsItem != None:
                    if self.timeMeasurementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.timeMeasurementGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.timeMeasurementGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeModalScaleTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.timeModalScaleGraphicsItem != None:
                    if self.timeModalScaleGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.timeModalScaleGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.timeModalScaleGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceModalScaleTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.priceModalScaleGraphicsItem != None:
                    if self.priceModalScaleGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceModalScaleGraphicsItem)
                    
                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.priceModalScaleGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PlanetLongitudeMovementMeasurementTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.planetLongitudeMovementMeasurementGraphicsItem != None:
                    if self.planetLongitudeMovementMeasurementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.planetLongitudeMovementMeasurementGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.planetLongitudeMovementMeasurementGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TextTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.textGraphicsItem != None:
                    if self.textGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.textGraphicsItem)

                self.textGraphicsItem = None
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeInfoTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.priceTimeInfoGraphicsItem != None:
                    if self.priceTimeInfoGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceTimeInfoGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.priceTimeInfoGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceMeasurementTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.priceMeasurementGraphicsItem != None:
                    if self.priceMeasurementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceMeasurementGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.priceMeasurementGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeRetracementTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.timeRetracementGraphicsItem != None:
                    if self.timeRetracementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.timeRetracementGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.timeRetracementGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceRetracementTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.priceRetracementGraphicsItem != None:
                    if self.priceRetracementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceRetracementGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.priceRetracementGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeVectorTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.priceTimeVectorGraphicsItem != None:
                    if self.priceTimeVectorGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceTimeVectorGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.priceTimeVectorGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment1Tool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.lineSegment1GraphicsItem != None:
                    if self.lineSegment1GraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.lineSegment1GraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.lineSegment1GraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment2Tool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.lineSegment2GraphicsItem != None:
                    if self.lineSegment2GraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.lineSegment2GraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.lineSegment2GraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VerticalLineSegmentTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.verticalLineSegmentGraphicsItem != None:
                    if self.verticalLineSegmentGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.verticalLineSegmentGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.verticalLineSegmentGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HorizontalLineSegmentTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.horizontalLineSegmentGraphicsItem != None:
                    if self.horizontalLineSegmentGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.horizontalLineSegmentGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.horizontalLineSegmentGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['OctaveFanTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.octaveFanGraphicsItem != None:
                    if self.octaveFanGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.octaveFanGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.clickThreePointF = None
                self.octaveFanGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['FibFanTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.fibFanGraphicsItem != None:
                    if self.fibFanGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.fibFanGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.clickThreePointF = None
                self.fibFanGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['GannFanTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.gannFanGraphicsItem != None:
                    if self.gannFanGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.gannFanGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.clickThreePointF = None
                self.gannFanGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VimsottariDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.vimsottariDasaGraphicsItem != None:
                    if self.vimsottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.vimsottariDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.vimsottariDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['AshtottariDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.ashtottariDasaGraphicsItem != None:
                    if self.ashtottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.ashtottariDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.ashtottariDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['YoginiDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.yoginiDasaGraphicsItem != None:
                    if self.yoginiDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.yoginiDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.yoginiDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwisaptatiSamaDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.dwisaptatiSamaDasaGraphicsItem != None:
                    if self.dwisaptatiSamaDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.dwisaptatiSamaDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.dwisaptatiSamaDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShattrimsaSamaDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.shattrimsaSamaDasaGraphicsItem != None:
                    if self.shattrimsaSamaDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.shattrimsaSamaDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.shattrimsaSamaDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwadasottariDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.dwadasottariDasaGraphicsItem != None:
                    if self.dwadasottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.dwadasottariDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.dwadasottariDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ChaturaseetiSamaDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.chaturaseetiSamaDasaGraphicsItem != None:
                    if self.chaturaseetiSamaDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.chaturaseetiSamaDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.chaturaseetiSamaDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['SataabdikaDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.sataabdikaDasaGraphicsItem != None:
                    if self.sataabdikaDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.sataabdikaDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.sataabdikaDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShodasottariDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.shodasottariDasaGraphicsItem != None:
                    if self.shodasottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.shodasottariDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.shodasottariDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PanchottariDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.panchottariDasaGraphicsItem != None:
                    if self.panchottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.panchottariDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.panchottariDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShashtihayaniDasaTool']:

            if qkeyevent.key() == Qt.Key_Escape:
                # Escape key causes any currently edited item to
                # be removed and cleared out.  Temporary variables used
                # are cleared out too.
                if self.shashtihayaniDasaGraphicsItem != None:
                    if self.shashtihayaniDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.shashtihayaniDasaGraphicsItem)

                self.clickOnePointF = None
                self.clickTwoPointF = None
                self.shashtihayaniDasaGraphicsItem = None
            elif qkeyevent.key() == Qt.Key_Q:
                # Turn on snap functionality.
                self.snapEnabledFlag = True
                self.log.debug("Snap mode enabled.")
                self.statusMessageUpdate.emit("Snap mode enabled")
            elif qkeyevent.key() == Qt.Key_W:
                # Turn off snap functionality.
                self.snapEnabledFlag = False
                self.log.debug("Snap mode disabled.")
                self.statusMessageUpdate.emit("Snap mode disabled")
            else:
                super().keyPressEvent(qkeyevent)

        else:
            # For any other mode we don't have specific functionality for,
            # just pass the event to the parent to handle.
            super().keyPressEvent(qkeyevent)

        
        self.log.debug("Exiting keyPressEvent()")

        
    def mousePressEvent(self, qmouseevent):
        """Triggered when the mouse is pressed in this widget."""

        self.log.debug("Entered mousePressEvent()")

        # Get the click position in scene coordinates for debugging purposes.
        clickPosF = self.mapToScene(qmouseevent.pos())
        self.log.debug("Click pos in scene coordinates is: ({}, {})".\
                       format(clickPosF.x(), clickPosF.y()))
        if self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']:
            
            self.log.debug("Current toolMode is: ReadOnlyPointerTool")

            if qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                # Open a context menu at this location, in readonly mode.
                clickPosF = self.mapToScene(qmouseevent.pos())
                menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                menu.exec_(qmouseevent.globalPos())
            else:
                self.log.debug("Passing mouse press event to super().")
                super().mousePressEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PointerTool']:

            self.log.debug("Current toolMode is: PointerTool")
            
            if qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                # Open a context menu at this location, in non-readonly mode.
                clickPosF = self.mapToScene(qmouseevent.pos())
                menu = self.createContextMenu(clickPosF, readOnlyFlag=False)
                menu.exec_(qmouseevent.globalPos())
            else:
                self.log.debug("Passing mouse press event to super().")
                super().mousePressEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HandTool']:

            self.log.debug("Current toolMode is: HandTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                self.log.debug("Passing mouse press event to super().")
                # Panning the QGraphicsView.
                super().mousePressEvent(qmouseevent)
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                # Open a context menu at this location, in readonly mode.
                clickPosF = self.mapToScene(qmouseevent.pos())
                menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                menu.exec_(qmouseevent.globalPos())

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomInTool']:

            self.log.debug("Current toolMode is: ZoomInTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                # New center
                newCenterPointF = self.mapToScene(qmouseevent.pos())

                # Get the QSetting key for the zoom scaling amounts.
                settings = QSettings()
                scaleFactor = \
                    settings.value(self.zoomScaleFactorSettingsKey, \
                        SettingsKeys.zoomScaleFactorSettingsDefValue,
                        type=float)

                # Actually do the scaling of the view.
                self.scale(scaleFactor, scaleFactor)

                # Center on the new center.
                self.centerOn(newCenterPointF)
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                # Open a context menu at this location, in readonly mode.
                clickPosF = self.mapToScene(qmouseevent.pos())
                menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                menu.exec_(qmouseevent.globalPos())

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomOutTool']:
            
            self.log.debug("Current toolMode is: ZoomOutTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                # New center
                newCenterPointF = self.mapToScene(qmouseevent.pos())

                # Get the QSetting key for the zoom scaling amounts.
                settings = QSettings()
                scaleFactor = \
                    settings.value(self.zoomScaleFactorSettingsKey, \
                        SettingsKeys.zoomScaleFactorSettingsDefValue,
                        type=float)

                # Actually do the scaling of the view.
                self.scale(1.0 / scaleFactor, 1.0 / scaleFactor)

                # Center on the new center.
                self.centerOn(newCenterPointF)
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                # Open a context menu at this location, in readonly mode.
                clickPosF = self.mapToScene(qmouseevent.pos())
                menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                menu.exec_(qmouseevent.globalPos())

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['BarCountTool']:
            
            self.log.debug("Current toolMode is: BarCountTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the BarCountGraphicsItem and initialize it to
                    # the mouse location.
                    self.barCountGraphicsItem = BarCountGraphicsItem()
                    self.barCountGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.barCountGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
        
                    self.barCountGraphicsItem.setPos(self.clickOnePointF)
                    self.barCountGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.barCountGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.barCountGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.barCountGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.barCountGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "barCountGraphicsItem != None.")
                    
                    # Set the end point of the BarCountGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    self.barCountGraphicsItem.setEndPointF(self.clickTwoPointF)

                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.barCountGraphicsItem.getArtifact()
                    
                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.barCountGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.barCountGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.barCountGraphicsItem.sceneBoundingRect()
                    self.log.debug("barCountGraphicsItem " +
                                   "officially added.  " +
                                   "pos is: {}.  ".\
                                   format(self.barCountGraphicsItem.pos()) +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                    
                    # This tool will work differently than the other
                    # measurement tools.  
                    #
                    # Instead of clearing out the working variables here,
                    # we retain them so that we can 
                    # continue to append new BarCountGraphicsItems
                    # using the same start point, until the user does a
                    # right-click.  

                    # Create the BarCountGraphicsItem and initialize it to
                    # the mouse location.
                    self.barCountGraphicsItem = BarCountGraphicsItem()
                    self.barCountGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.barCountGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
        
                    self.barCountGraphicsItem.setPos(self.clickOnePointF)
                    self.barCountGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.barCountGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.scene().addItem(self.barCountGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.barCountGraphicsItem)

                    # Now clear out self.clickTwoPointF so that
                    # we fall in this same if case again if the user left
                    # clicks.
                    self.clickTwoPointF = None

                else:
                    self.log.warn("Unexpected state reached.")

            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.barCountGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "barCountGraphicsItem != None.")
                    
                    # Right-click during setting the BarCountGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.barCountGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.barCountGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.barCountGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.barCountGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "barCountGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeMeasurementTool']:
            
            self.log.debug("Current toolMode is: TimeMeasurementTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the TimeMeasurementGraphicsItem and
                    # initialize it to the mouse location.
                    self.timeMeasurementGraphicsItem = \
                        TimeMeasurementGraphicsItem()
                    self.timeMeasurementGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)
        
                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.timeMeasurementGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
        
                    self.timeMeasurementGraphicsItem.setPos(self.clickOnePointF)
                    self.timeMeasurementGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.timeMeasurementGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.timeMeasurementGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.timeMeasurementGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.timeMeasurementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeMeasurementGraphicsItem != None.")
                    
                    # Set the end point of the TimeMeasurementGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    self.timeMeasurementGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.timeMeasurementGraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.timeMeasurementGraphicsItem.getArtifact()
                                                
                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.timeMeasurementGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.timeMeasurementGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.timeMeasurementGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("timeMeasurementGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                                   
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.timeMeasurementGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.timeMeasurementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeMeasurementGraphicsItem != None.")
                    
                    # Right-click during setting the TimeMeasurementGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.timeMeasurementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.timeMeasurementGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.timeMeasurementGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.timeMeasurementGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeMeasurementGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeModalScaleTool']:
            
            self.log.debug("Current toolMode is: TimeModalScaleTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the TimeModalScaleGraphicsItem and
                    # initialize it to the mouse location.
                    self.timeModalScaleGraphicsItem = \
                        TimeModalScaleGraphicsItem()
                    self.timeModalScaleGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.timeModalScaleGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.timeModalScaleGraphicsItem.setPos(self.clickOnePointF)
                    self.timeModalScaleGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.timeModalScaleGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.timeModalScaleGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.timeModalScaleGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.timeModalScaleGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeModalScaleGraphicsItem != None.")
                    
                    # Set the end point of the TimeModalScaleGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.timeModalScaleGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.timeModalScaleGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.timeModalScaleGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.timeModalScaleGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.timeModalScaleGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.timeModalScaleGraphicsItem.sceneBoundingRect()
                    self.log.debug("timeModalScaleGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.timeModalScaleGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.timeModalScaleGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeModalScaleGraphicsItem != None.")
                    
                    # Right-click during setting the TimeModalScaleGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.timeModalScaleGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.timeModalScaleGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.timeModalScaleGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.timeModalScaleGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeModalScaleGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceModalScaleTool']:
            
            self.log.debug("Current toolMode is: PriceModalScaleTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar price Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        y = self.scene().getClosestPriceBarOHLCY(infoPointF)

                        # Use this Y value.
                        self.clickOnePointF.setY(y)
                    
                    # Create the PriceModalScaleGraphicsItem and
                    # initialize it to the mouse location.
                    self.priceModalScaleGraphicsItem = \
                        PriceModalScaleGraphicsItem()
                    self.priceModalScaleGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted horizontal lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.priceModalScaleGraphicsItem.\
                        setDrawHorizontalDottedLinesFlag(True)
                    
                    self.priceModalScaleGraphicsItem.setPos(self.clickOnePointF)
                    self.priceModalScaleGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.priceModalScaleGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.priceModalScaleGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.priceModalScaleGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.priceModalScaleGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceModalScaleGraphicsItem != None.")
                    
                    # Set the end point of the PriceModalScaleGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar price Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        y = self.scene().getClosestPriceBarOHLCY(infoPointF)

                        # Use this Y value.
                        self.clickTwoPointF.setY(y)
                    
                    newEndPointF = \
                        QPointF(self.clickOnePointF.x(),
                                self.clickTwoPointF.y())
                    self.priceModalScaleGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.priceModalScaleGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted horizontal lines at the tick areas.
                    self.priceModalScaleGraphicsItem.\
                        setDrawHorizontalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.priceModalScaleGraphicsItem.getArtifact()
                                                
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.priceModalScaleGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.priceModalScaleGraphicsItem.sceneBoundingRect()
                    self.log.debug("priceModalScaleGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceModalScaleGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.priceModalScaleGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceModalScaleGraphicsItem != None.")
                    
                    # Right-click during setting the PriceModalScaleGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.priceModalScaleGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceModalScaleGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceModalScaleGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.priceModalScaleGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceModalScaleGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PlanetLongitudeMovementMeasurementTool']:
            
            self.log.debug("Current toolMode is: PlanetLongitudeMovementMeasurementTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the PlanetLongitudeMovementMeasurementGraphicsItem and
                    # initialize it to the mouse location.
                    self.planetLongitudeMovementMeasurementGraphicsItem = \
                        PlanetLongitudeMovementMeasurementGraphicsItem()
                    self.planetLongitudeMovementMeasurementGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)
        
                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.planetLongitudeMovementMeasurementGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
        
                    self.planetLongitudeMovementMeasurementGraphicsItem.setPos(self.clickOnePointF)
                    self.planetLongitudeMovementMeasurementGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.planetLongitudeMovementMeasurementGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.planetLongitudeMovementMeasurementGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.planetLongitudeMovementMeasurementGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.planetLongitudeMovementMeasurementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "planetLongitudeMovementMeasurementGraphicsItem != None.")
                    
                    # Set the end point of the PlanetLongitudeMovementMeasurementGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    self.planetLongitudeMovementMeasurementGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.planetLongitudeMovementMeasurementGraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.planetLongitudeMovementMeasurementGraphicsItem.getArtifact()
                                                
                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.planetLongitudeMovementMeasurementGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.planetLongitudeMovementMeasurementGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.planetLongitudeMovementMeasurementGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("planetLongitudeMovementMeasurementGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                                   
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.planetLongitudeMovementMeasurementGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.planetLongitudeMovementMeasurementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "planetLongitudeMovementMeasurementGraphicsItem != None.")
                    
                    # Right-click during setting the 
                    # PlanetLongitudeMovementMeasurementGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.planetLongitudeMovementMeasurementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.planetLongitudeMovementMeasurementGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.planetLongitudeMovementMeasurementGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.planetLongitudeMovementMeasurementGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "planetLongitudeMovementMeasurementGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TextTool']:
            
            self.log.debug("Current toolMode is: TextTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")

                # Create the TextGraphicsItem and initialize it to the
                # mouse location.
                self.textGraphicsItem = TextGraphicsItem()
                self.textGraphicsItem.\
                    loadSettingsFromPriceBarChartSettings(\
                    self.priceBarChartSettings)
                self.textGraphicsItem.setPos(self.mapToScene(qmouseevent.pos()))

                # Now create and run a edit dialog for typing in the text.
                dialog = \
                    PriceBarChartTextArtifactEditDialog(\
                        self.textGraphicsItem.getArtifact(),
                        self.scene(),
                        readOnlyFlag=False)
                rv = dialog.exec_()
                
                # If the user accepts the dialog, then add the item,
                # otherwise, delete and remove.
                if rv == QDialog.Accepted:
                    self.log.debug("PriceBarChartTextArtifactEditDialog " +
                                   "accepted.")
                    self.textGraphicsItem.setArtifact(dialog.getArtifact())
                    self.scene().addItem(self.textGraphicsItem)

                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.textGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.textGraphicsItem)
                else:
                    self.log.debug("PriceBarChartTextArtifactEditDialog " +
                                   "rejected.")

                self.textGraphicsItem = None
                
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                # Open a context menu at this location, in readonly mode.
                clickPosF = self.mapToScene(qmouseevent.pos())
                menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                menu.exec_(qmouseevent.globalPos())
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeInfoTool']:
            
            self.log.debug("Current toolMode is: PriceTimeInfoTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")

                if self.clickOnePointF == None:
                    
                    self.log.debug("clickOnePointF is None.")

                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # First click sets the position and everything.
                    # Assumes that the text is above the point.
        
                    # Create the PriceTimeInfoGraphicsItem
                    self.priceTimeInfoGraphicsItem = PriceTimeInfoGraphicsItem()
                    self.priceTimeInfoGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                        self.priceBarChartSettings)

                    # Set the flag that indicates that we should draw
                    # a line from the text to the infoPointF.  This is
                    # set to false once we've fully set the item.
                    self.priceTimeInfoGraphicsItem.\
                        setDrawLineToInfoPointFFlag(True)
                    
                    # Set the conversion object as the scene so that it
                    # can do initial calculations for the text to display.
                    self.priceTimeInfoGraphicsItem.\
                        setConvertObj(self.scene())
                    
                    # Location of the graphics item.  This is calculated
                    # below, based on where the used clicked.
                    pos = QPointF()
                
                    # If snap is enabled, then find the closest high, low,
                    # open or close QPointF to the place clicked.
                    infoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # PriceBar or LookbackMultiplePriceBar price 
                    # to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest PriceBar or " + \
                                       "LookbackMultiplePriceBar X and Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPoint = \
                            self.scene().\
                            getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint(infoPointF)
                        infoPointF = closestPoint
                            
                        # Set this also as the first click point,
                        # as if the user clicked perfectly.
                        self.clickOnePointF = infoPointF

                    # Get and modify the artifact.
                    artifact = self.priceTimeInfoGraphicsItem.getArtifact()
                    artifact.setInfoPointF(infoPointF)

                    # Now set the artifact again so we can get an updated
                    # boundingRect size.
                    self.priceTimeInfoGraphicsItem.setArtifact(artifact)
                    boundingRect = self.priceTimeInfoGraphicsItem.boundingRect()

                    # Determine what y pos would be for this new item,
                    # assuming the text will be above the infoPointF.
                    self.priceTimeInfoGraphicsItem.\
                        setTextLabelEdgeYLocation(infoPointF.y())

                    # Set the BirthInfo.
                    birthInfo = self.scene().getBirthInfo()
                    self.priceTimeInfoGraphicsItem.setBirthInfo(birthInfo)
                    
                    # Add the item to the scene.
                    self.scene().addItem(self.priceTimeInfoGraphicsItem)
                    
                elif self.clickOnePointF != None and \
                       self.clickTwoPointF == None and \
                       self.priceTimeInfoGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceTimeInfoGraphicsItem != None.")
                    
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())
                    
                    # Turn off the flag that indicates that we should
                    # draw a line from the text to the infoPointF.  It
                    # will now only draw that line when we have the
                    # item selected.
                    self.priceTimeInfoGraphicsItem.\
                        setDrawLineToInfoPointFFlag(False)
                    
                    # Set the position of the item by calling the set
                    # function for the Y location of the edge of the
                    # text.
                    posY = self.clickTwoPointF.y()
                    self.priceTimeInfoGraphicsItem.\
                        setTextLabelEdgeYLocation(posY)

                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.priceTimeInfoGraphicsItem)
                    
                    # Done settings values, so clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceTimeInfoGraphicsItem = None
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.priceTimeInfoGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceTimeInfoGraphicsItem != None.")
                    
                    # Right-click during setting the priceTimeInfoGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.priceTimeInfoGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceTimeInfoGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceTimeInfoGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.priceTimeInfoGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceTimeInfoGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceMeasurementTool']:
            
            self.log.debug("Current toolMode is: PriceMeasurementTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        y = self.scene().getClosestPriceBarOHLCY(infoPointF)
                        
                        # Use this Y value.
                        self.clickOnePointF.setY(y)
                    
                    # Create the PriceMeasurementGraphicsItem and
                    # initialize it to the mouse location.
                    self.priceMeasurementGraphicsItem = \
                        PriceMeasurementGraphicsItem()
                    self.priceMeasurementGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)
        
                    # Set the flag that indicates we should draw
                    # dotted horizontal lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.priceMeasurementGraphicsItem.\
                        setDrawHorizontalDottedLinesFlag(True)
        
                    self.priceMeasurementGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.priceMeasurementGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.priceMeasurementGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.priceMeasurementGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.priceMeasurementGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.priceMeasurementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceMeasurementGraphicsItem != None.")
                    
                    # Set the end point of the PriceMeasurementGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        y = self.scene().getClosestPriceBarOHLCY(infoPointF)
                        
                        # Use this Y value.
                        self.clickTwoPointF.setY(y)
                    
                    self.priceMeasurementGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.priceMeasurementGraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.priceMeasurementGraphicsItem.getArtifact()
                                                
                    # Unset the flag that indicates we should draw
                    # dotted horizontal lines at the tick areas.
                    self.priceMeasurementGraphicsItem.\
                        setDrawHorizontalDottedLinesFlag(False)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.priceMeasurementGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.priceMeasurementGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("priceMeasurementGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                                   
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceMeasurementGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.priceMeasurementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceMeasurementGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # PriceMeasurementGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.priceMeasurementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceMeasurementGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceMeasurementGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.priceMeasurementGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceMeasurementGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeRetracementTool']:
            
            self.log.debug("Current toolMode is: TimeRetracementTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the TimeRetracementGraphicsItem and
                    # initialize it to the mouse location.
                    self.timeRetracementGraphicsItem = \
                        TimeRetracementGraphicsItem()
                    self.timeRetracementGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)
        
                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.timeRetracementGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
        
                    self.timeRetracementGraphicsItem.setPos(self.clickOnePointF)
                    self.timeRetracementGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.timeRetracementGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.timeRetracementGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.timeRetracementGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.timeRetracementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeRetracementGraphicsItem != None.")
                    
                    # Set the end point of the TimeRetracementGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    self.timeRetracementGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.timeRetracementGraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.timeRetracementGraphicsItem.getArtifact()
                                                
                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.timeRetracementGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.timeRetracementGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.timeRetracementGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("timeRetracementGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                                   
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.timeRetracementGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.timeRetracementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeRetracementGraphicsItem != None.")
                    
                    # Right-click during setting the TimeRetracementGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.timeRetracementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.timeRetracementGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.timeRetracementGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.timeRetracementGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "timeRetracementGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceRetracementTool']:
            
            self.log.debug("Current toolMode is: PriceRetracementTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar price Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        y = self.scene().getClosestPriceBarOHLCY(infoPointF)

                        # Use this Y value.
                        self.clickOnePointF.setY(y)
                    
                    # Create the PriceRetracementGraphicsItem and
                    # initialize it to the mouse location.
                    self.priceRetracementGraphicsItem = \
                        PriceRetracementGraphicsItem()
                    self.priceRetracementGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)
        
                    # Set the flag that indicates we should draw
                    # dotted horizontal lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.priceRetracementGraphicsItem.\
                        setDrawHorizontalDottedLinesFlag(True)
        
                    self.priceRetracementGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.priceRetracementGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.priceRetracementGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.priceRetracementGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.priceRetracementGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.priceRetracementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceRetracementGraphicsItem != None.")
                    
                    # Set the end point of the PriceRetracementGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar price Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        y = self.scene().getClosestPriceBarOHLCY(infoPointF)

                        # Use this Y value.
                        self.clickTwoPointF.setY(y)
                    
                    self.priceRetracementGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.priceRetracementGraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.priceRetracementGraphicsItem.getArtifact()
                                                
                    # Unset the flag that indicates we should draw
                    # dotted horizontal lines at the tick areas.
                    self.priceRetracementGraphicsItem.\
                        setDrawHorizontalDottedLinesFlag(False)
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.priceRetracementGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.priceRetracementGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("priceRetracementGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                                   
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceRetracementGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.priceRetracementGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceRetracementGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # PriceRetracementGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.priceRetracementGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceRetracementGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceRetracementGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.priceRetracementGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceRetracementGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeVectorTool']:
            
            self.log.debug("Current toolMode is: PriceTimeVectorTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X and Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(infoPointF)

                        # Use these X and Y values.
                        self.clickOnePointF.setX(closestPoint.x())
                        self.clickOnePointF.setY(closestPoint.y())
                    
                    # Create the PriceTimeVectorGraphicsItem and
                    # initialize it to the mouse location.
                    self.priceTimeVectorGraphicsItem = \
                        PriceTimeVectorGraphicsItem()
                    self.priceTimeVectorGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)
        
                    self.priceTimeVectorGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.priceTimeVectorGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.priceTimeVectorGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.priceTimeVectorGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.priceTimeVectorGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.priceTimeVectorGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceTimeVectorGraphicsItem != None.")
                    
                    # Set the end point of the PriceTimeVectorGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X and Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(infoPointF)

                        # Use these X and Y values.
                        self.clickTwoPointF.setX(closestPoint.x())
                        self.clickTwoPointF.setY(closestPoint.y())
                    
                    self.priceTimeVectorGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.priceTimeVectorGraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.priceTimeVectorGraphicsItem.getArtifact()
                                                
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.priceTimeVectorGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.priceTimeVectorGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("priceTimeVectorGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                    
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceTimeVectorGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.priceTimeVectorGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceTimeVectorGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # PriceTimeVectorGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.priceTimeVectorGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.priceTimeVectorGraphicsItem)
                        
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.priceTimeVectorGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.priceTimeVectorGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "priceTimeVectorGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment1Tool']:
            
            self.log.debug("Current toolMode is: LineSegment1Tool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # PriceBar or LookbackMultiplePriceBar price 
                    # to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest PriceBar or " + \
                                       "LookbackMultiplePriceBar X and Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPoint = \
                            self.scene().\
                            getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint(infoPointF)

                        # Use these X and Y values.
                        self.clickOnePointF.setX(closestPoint.x())
                        self.clickOnePointF.setY(closestPoint.y())
                    
                    # Create the LineSegment1GraphicsItem and
                    # initialize it to the mouse location.
                    self.lineSegment1GraphicsItem = \
                        LineSegmentGraphicsItem()
                    self.lineSegment1GraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings,
                            lineSegmentNumberType=1)
        
                    self.lineSegment1GraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.lineSegment1GraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.lineSegment1GraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.lineSegment1GraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.lineSegment1GraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.lineSegment1GraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "lineSegment1GraphicsItem != None.")
                    
                    # Set the end point of the LineSegment1GraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # PriceBar or LookbackMultiplePriceBar price 
                    # to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest PriceBar or " + \
                                       "LookbackMultiplePriceBar X and Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPoint = \
                            self.scene().\
                            getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint(infoPointF)

                        # Use these X and Y values.
                        self.clickTwoPointF.setX(closestPoint.x())
                        self.clickTwoPointF.setY(closestPoint.y())
                    
                    self.lineSegment1GraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.lineSegment1GraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.lineSegment1GraphicsItem.getArtifact()
                                                
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.lineSegment1GraphicsItem)
                    
                    sceneBoundingRect = \
                        self.lineSegment1GraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("lineSegment1GraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                    
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.lineSegment1GraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.lineSegment1GraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "lineSegment1GraphicsItem != None.")
                    
                    # Right-click during setting the
                    # LineSegment1GraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.lineSegment1GraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.lineSegment1GraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.lineSegment1GraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.lineSegment1GraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "lineSegment1GraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment2Tool']:
            
            self.log.debug("Current toolMode is: LineSegment2Tool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # PriceBar or LookbackMultiplePriceBar price 
                    # to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest PriceBar or " + \
                                       "LookbackMultiplePriceBar X and Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPoint = \
                            self.scene().\
                            getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint(infoPointF)

                        # Use these X and Y values.
                        self.clickOnePointF.setX(closestPoint.x())
                        self.clickOnePointF.setY(closestPoint.y())
                    
                    # Create the LineSegment2GraphicsItem and
                    # initialize it to the mouse location.
                    self.lineSegment2GraphicsItem = \
                        LineSegmentGraphicsItem()
                    self.lineSegment2GraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings,
                            lineSegmentNumberType=2)
        
                    self.lineSegment2GraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.lineSegment2GraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.lineSegment2GraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.lineSegment2GraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.lineSegment2GraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.lineSegment2GraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "lineSegment2GraphicsItem != None.")
                    
                    # Set the end point of the LineSegment2GraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # PriceBar or LookbackMultiplePriceBar price 
                    # to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest PriceBar or " + \
                                       "LookbackMultiplePriceBar X and Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPoint = \
                            self.scene().\
                            getClosestPriceBarAndLookbackMultiplePriceBarOHLCViewPoint(infoPointF)

                        # Use these X and Y values.
                        self.clickTwoPointF.setX(closestPoint.x())
                        self.clickTwoPointF.setY(closestPoint.y())
                    
                    self.lineSegment2GraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.lineSegment2GraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.lineSegment2GraphicsItem.getArtifact()
                                                
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.lineSegment2GraphicsItem)
                    
                    sceneBoundingRect = \
                        self.lineSegment2GraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("lineSegment2GraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                    
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.lineSegment2GraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.lineSegment2GraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "lineSegment2GraphicsItem != None.")
                    
                    # Right-click during setting the
                    # LineSegment2GraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.lineSegment2GraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.lineSegment2GraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.lineSegment2GraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.lineSegment2GraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "lineSegment2GraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VerticalLineSegmentTool']:
            
            self.log.debug("Current toolMode is: VerticalLineSegmentTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # PriceBar or LookbackMultiplePriceBar timestamp
                    # to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest PriceBar or " + \
                                       "LookbackMultiplePriceBar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPointX = \
                            self.scene().\
                            getClosestPriceBarAndLookbackMultiplePriceBarX(infoPointF)

                        # Use these X and Y values.
                        self.clickOnePointF.setX(closestPointX)
                        self.clickOnePointF.setY(infoPointF.y())
                    
                    # Create the VerticalLineSegmentGraphicsItem and
                    # initialize it to the mouse location.
                    self.verticalLineSegmentGraphicsItem = \
                        VerticalLineSegmentGraphicsItem()
                    self.verticalLineSegmentGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)
        
                    self.verticalLineSegmentGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.verticalLineSegmentGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.verticalLineSegmentGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.verticalLineSegmentGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.verticalLineSegmentGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.verticalLineSegmentGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "verticalLineSegmentGraphicsItem != None.")
                    
                    # Set the end point of the VerticalLineSegmentGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # Use these X and Y values.
                    # 
                    # We use the first click's x value to ensure that this remains 
                    # a vertical line, per the VerticalLineSegmentGraphicsItem.
                    self.clickTwoPointF.setX(self.clickOnePointF.x())
                    self.clickTwoPointF.setY(self.clickTwoPointF.y())
                    
                    self.verticalLineSegmentGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.verticalLineSegmentGraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.verticalLineSegmentGraphicsItem.getArtifact()
                                                
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.verticalLineSegmentGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.verticalLineSegmentGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("verticalLineSegmentGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                    
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.verticalLineSegmentGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.verticalLineSegmentGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "verticalLineSegmentGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # VerticalLineSegmentGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.verticalLineSegmentGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.verticalLineSegmentGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.verticalLineSegmentGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.verticalLineSegmentGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "verticalLineSegmentGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HorizontalLineSegmentTool']:
            
            self.log.debug("Current toolMode is: HorizontalLineSegmentTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF == None")
                
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar price to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar Y.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        closestPriceBarY = \
                            self.scene().getClosestPriceBarOHLCY(infoPointF)

                        # Use these X and Y values.
                        self.clickOnePointF.setX(infoPointF.x())
                        self.clickOnePointF.setY(closestPriceBarY)
                    
                    # Create the HorizontalLineSegmentGraphicsItem and
                    # initialize it to the mouse location.
                    self.horizontalLineSegmentGraphicsItem = \
                        HorizontalLineSegmentGraphicsItem()
                    self.horizontalLineSegmentGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)
        
                    self.horizontalLineSegmentGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.horizontalLineSegmentGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.horizontalLineSegmentGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.horizontalLineSegmentGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.horizontalLineSegmentGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.horizontalLineSegmentGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "horizontalLineSegmentGraphicsItem != None.")
                    
                    # Set the end point of the HorizontalLineSegmentGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # Use these X and Y values.
                    # 
                    # We use the first click's y value to ensure that this remains 
                    # a horizontal line, per the HorizontalLineSegmentGraphicsItem.
                    self.clickTwoPointF.setX(self.clickTwoPointF.x())
                    self.clickTwoPointF.setY(self.clickOnePointF.y())
                    
                    self.horizontalLineSegmentGraphicsItem.\
                        setEndPointF(self.clickTwoPointF)
                    self.horizontalLineSegmentGraphicsItem.normalizeStartAndEnd()
        
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.horizontalLineSegmentGraphicsItem.getArtifact()
                                                
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.horizontalLineSegmentGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.horizontalLineSegmentGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("horizontalLineSegmentGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))
                    
                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.horizontalLineSegmentGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.horizontalLineSegmentGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "horizontalLineSegmentGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # HorizontalLineSegmentGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.horizontalLineSegmentGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.horizontalLineSegmentGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.horizontalLineSegmentGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.horizontalLineSegmentGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "horizontalLineSegmentGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['OctaveFanTool']:
            
            self.log.debug("Current toolMode is: OctaveFanTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    self.log.debug("clickOnePointF is now set to ({}, {}).".\
                                   format(self.clickOnePointF.x(),
                                          self.clickOnePointF.y()))

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X and Y.")
                        
                        originPointF = self.mapToScene(qmouseevent.pos())
                        
                        # Find if there is a point closer to this
                        # originPointF related to a PriceBarGraphicsItem.
                        barPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(originPointF)

                        # If a point was found, then use it as the origin point.
                        if barPoint != None:
                            self.log.debug("Non-null barPoint returned.")
                            originPointF = barPoint
                            
                            # Set this also as the first click point,
                            # as if the user clicked perfectly.
                            self.clickOnePointF = originPointF

                            self.log.debug("clickOnePointF is now set to " +
                                           "({}, {}).".\
                                           format(self.clickOnePointF.x(),
                                                  self.clickOnePointF.y()))
                    
                    # Create the OctaveFanGraphicsItem and
                    # initialize it to the mouse location.
                    self.octaveFanGraphicsItem = \
                        OctaveFanGraphicsItem()
                    self.octaveFanGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the conversion object as the scene so that it
                    # can do scaling calculations.
                    self.octaveFanGraphicsItem.\
                        setConvertObj(self.scene())

                    self.log.debug("Done setting convert obj.  " +
                                   "Now setting points...")

                    self.log.debug("Setting pos...")
                    
                    self.octaveFanGraphicsItem.\
                        setPos(self.clickOnePointF)

                    self.log.debug("Setting origin point...")

                    self.octaveFanGraphicsItem.\
                        setOriginPointF(self.clickOnePointF)

                    self.log.debug("Setting leg1 point...")
                    
                    self.octaveFanGraphicsItem.\
                        setLeg1PointF(self.clickOnePointF)

                    self.log.debug("Setting leg2 point...")
                    
                    self.octaveFanGraphicsItem.\
                        setLeg2PointF(self.clickOnePointF)

                    self.log.debug("Position of item to add is: ({}, {})".\
                                   format(self.octaveFanGraphicsItem.pos().x(),
                                          self.octaveFanGraphicsItem.pos().y()))

                    boundingRect = self.octaveFanGraphicsItem.boundingRect()
                    shape = self.octaveFanGraphicsItem.shape()
                    
                    self.log.debug("Bounding rect of item to add is: " +
                                   "x={}, y={}, w={}, h={}".\
                       format(boundingRect.x(),
                              boundingRect.y(),
                              boundingRect.width(),
                              boundingRect.height()))
                    
                    self.log.debug("Bounding rect of shape is: " +
                                   "x={}, y={}, w={}, h={}".\
                       format(shape.boundingRect().x(),
                              shape.boundingRect().y(),
                              shape.boundingRect().width(),
                              shape.boundingRect().height()))
                    
                    self.log.debug("Adding to scene...")
                    
                    self.scene().addItem(self.octaveFanGraphicsItem)

                    self.log.debug("Making sure correct flags are set...")
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.octaveFanGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.clickThreePointF == None and \
                    self.octaveFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "clickThreePointF == None and " +
                                   "octaveFanGraphicsItem != None.")
                    
                    # Set the click two point of the OctaveFanGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        leg1PointF = self.mapToScene(qmouseevent.pos())
                        
                        # Find if there is a point closer to this
                        # leg1PointF related to a PriceBarGraphicsItem.
                        barPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(leg1PointF)

                        # If a point was found, then use it as the leg1 point.
                        if barPoint != None:
                            leg1PointF = barPoint
                            
                            # Set this also as the second click point,
                            # as if the user clicked perfectly.
                            self.clickTwoPointF = leg1PointF
                    
                    self.octaveFanGraphicsItem.\
                        setLeg1PointF(self.clickTwoPointF)
                    self.octaveFanGraphicsItem.\
                        setLeg2PointF(self.clickTwoPointF)
                    
                elif self.clickOnePointF != None and \
                    self.clickTwoPointF != None and \
                    self.clickThreePointF == None and \
                    self.octaveFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF != None and " +
                                   "clickThreePointF == None and " +
                                   "octaveFanGraphicsItem != None.")
                    
                    # Set the click three point of the OctaveFanGraphicsItem.
                    self.clickThreePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        leg2PointF = self.mapToScene(qmouseevent.pos())
                        
                        # Find if there is a point closer to this
                        # leg2PointF related to a PriceBarGraphicsItem.
                        barPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(leg2PointF)

                        # If a point was found, then use it as the leg2 point.
                        if barPoint != None:
                            leg2PointF = barPoint
                            
                            # Set this also as the third click point,
                            # as if the user clicked perfectly.
                            self.clickThreePointF = leg2PointF
                    
                    self.octaveFanGraphicsItem.\
                        setLeg2PointF(self.clickThreePointF)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.octaveFanGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.octaveFanGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.octaveFanGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("octaveFanGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.clickThreePointF = None
                    self.octaveFanGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickThreePointF == None and \
                   self.octaveFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickThreePointF == None and " +
                                   "octaveFanGraphicsItem != None.")
                    
                    # Right-click during setting the OctaveFanGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.octaveFanGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.octaveFanGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.clickThreePointF = None
                    self.octaveFanGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.clickThreePointF == None and \
                     self.octaveFanGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "clickThreePointF == None and " +
                                   "octaveFanGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['FibFanTool']:
            
            self.log.debug("Current toolMode is: FibFanTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    self.log.debug("clickOnePointF is now set to ({}, {}).".\
                                   format(self.clickOnePointF.x(),
                                          self.clickOnePointF.y()))

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X and Y.")
                        
                        originPointF = self.mapToScene(qmouseevent.pos())
                        
                        # Find if there is a point closer to this
                        # originPointF related to a PriceBarGraphicsItem.
                        barPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(originPointF)

                        # If a point was found, then use it as the origin point.
                        if barPoint != None:
                            self.log.debug("Non-null barPoint returned.")
                            originPointF = barPoint
                            
                            # Set this also as the first click point,
                            # as if the user clicked perfectly.
                            self.clickOnePointF = originPointF

                            self.log.debug("clickOnePointF is now set to " +
                                           "({}, {}).".\
                                           format(self.clickOnePointF.x(),
                                                  self.clickOnePointF.y()))
                    
                    # Create the FibFanGraphicsItem and
                    # initialize it to the mouse location.
                    self.fibFanGraphicsItem = \
                        FibFanGraphicsItem()
                    self.fibFanGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the conversion object as the scene so that it
                    # can do scaling calculations.
                    self.fibFanGraphicsItem.\
                        setConvertObj(self.scene())

                    self.log.debug("Done setting convert obj.  " +
                                   "Now setting points...")

                    self.log.debug("Setting pos...")
                    
                    self.fibFanGraphicsItem.\
                        setPos(self.clickOnePointF)

                    self.log.debug("Setting origin point...")

                    self.fibFanGraphicsItem.\
                        setOriginPointF(self.clickOnePointF)

                    self.log.debug("Setting leg1 point...")
                    
                    self.fibFanGraphicsItem.\
                        setLeg1PointF(self.clickOnePointF)

                    self.log.debug("Setting leg2 point...")
                    
                    self.fibFanGraphicsItem.\
                        setLeg2PointF(self.clickOnePointF)

                    self.log.debug("Position of item to add is: ({}, {})".\
                                   format(self.fibFanGraphicsItem.pos().x(),
                                          self.fibFanGraphicsItem.pos().y()))

                    boundingRect = self.fibFanGraphicsItem.boundingRect()
                    shape = self.fibFanGraphicsItem.shape()
                    
                    self.log.debug("Bounding rect of item to add is: " +
                                   "x={}, y={}, w={}, h={}".\
                       format(boundingRect.x(),
                              boundingRect.y(),
                              boundingRect.width(),
                              boundingRect.height()))
                    
                    self.log.debug("Bounding rect of shape is: " +
                                   "x={}, y={}, w={}, h={}".\
                       format(shape.boundingRect().x(),
                              shape.boundingRect().y(),
                              shape.boundingRect().width(),
                              shape.boundingRect().height()))
                    
                    self.log.debug("Adding to scene...")
                    
                    self.scene().addItem(self.fibFanGraphicsItem)

                    self.log.debug("Making sure correct flags are set...")
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.fibFanGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.clickThreePointF == None and \
                    self.fibFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "clickThreePointF == None and " +
                                   "fibFanGraphicsItem != None.")
                    
                    # Set the click two point of the FibFanGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        leg1PointF = self.mapToScene(qmouseevent.pos())
                        
                        # Find if there is a point closer to this
                        # leg1PointF related to a PriceBarGraphicsItem.
                        barPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(leg1PointF)

                        # If a point was found, then use it as the leg1 point.
                        if barPoint != None:
                            leg1PointF = barPoint
                            
                            # Set this also as the second click point,
                            # as if the user clicked perfectly.
                            self.clickTwoPointF = leg1PointF
                    
                    self.fibFanGraphicsItem.\
                        setLeg1PointF(self.clickTwoPointF)
                    self.fibFanGraphicsItem.\
                        setLeg2PointF(self.clickTwoPointF)
                    
                elif self.clickOnePointF != None and \
                    self.clickTwoPointF != None and \
                    self.clickThreePointF == None and \
                    self.fibFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF != None and " +
                                   "clickThreePointF == None and " +
                                   "fibFanGraphicsItem != None.")
                    
                    # Set the click three point of the FibFanGraphicsItem.
                    self.clickThreePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        leg2PointF = self.mapToScene(qmouseevent.pos())
                        
                        # Find if there is a point closer to this
                        # leg2PointF related to a PriceBarGraphicsItem.
                        barPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(leg2PointF)

                        # If a point was found, then use it as the leg2 point.
                        if barPoint != None:
                            leg2PointF = barPoint
                            
                            # Set this also as the third click point,
                            # as if the user clicked perfectly.
                            self.clickThreePointF = leg2PointF
                    
                    self.fibFanGraphicsItem.\
                        setLeg2PointF(self.clickThreePointF)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.fibFanGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.fibFanGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.fibFanGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("fibFanGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.clickThreePointF = None
                    self.fibFanGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickThreePointF == None and \
                   self.fibFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickThreePointF == None and " +
                                   "fibFanGraphicsItem != None.")
                    
                    # Right-click during setting the FibFanGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.fibFanGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.fibFanGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.clickThreePointF = None
                    self.fibFanGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.clickThreePointF == None and \
                     self.fibFanGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "clickThreePointF == None and " +
                                   "fibFanGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['GannFanTool']:
            
            self.log.debug("Current toolMode is: GannFanTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    self.log.debug("clickOnePointF is now set to ({}, {}).".\
                                   format(self.clickOnePointF.x(),
                                          self.clickOnePointF.y()))

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X and Y.")
                        
                        originPointF = self.mapToScene(qmouseevent.pos())
                        
                        # Find if there is a point closer to this
                        # originPointF related to a PriceBarGraphicsItem.
                        barPoint = \
                            self.scene().\
                            getClosestPriceBarOHLCViewPoint(originPointF)

                        # If a point was found, then use it as the origin point.
                        if barPoint != None:
                            self.log.debug("Non-null barPoint returned.")
                            originPointF = barPoint
                            
                            # Set this also as the first click point,
                            # as if the user clicked perfectly.
                            self.clickOnePointF = originPointF

                            self.log.debug("clickOnePointF is now set to " +
                                           "({}, {}).".\
                                           format(self.clickOnePointF.x(),
                                                  self.clickOnePointF.y()))
                    
                    # Create the GannFanGraphicsItem and
                    # initialize it to the mouse location.
                    self.gannFanGraphicsItem = \
                        GannFanGraphicsItem()
                    self.gannFanGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the conversion object as the scene so that it
                    # can do scaling calculations.
                    self.gannFanGraphicsItem.\
                        setConvertObj(self.scene())

                    self.log.debug("Done setting convert obj.  " +
                                   "Now setting points...")

                    self.log.debug("Setting pos...")
                    
                    self.gannFanGraphicsItem.\
                        setPos(self.clickOnePointF)

                    self.log.debug("Setting origin point...")

                    self.gannFanGraphicsItem.\
                        setOriginPointF(self.clickOnePointF)

                    self.log.debug("Setting leg1 point...")
                    
                    self.gannFanGraphicsItem.\
                        setLeg1PointF(self.clickOnePointF)

                    self.log.debug("Setting leg2 point...")
                    
                    self.gannFanGraphicsItem.\
                        setLeg2PointF(self.clickOnePointF)

                    self.log.debug("Position of item to add is: ({}, {})".\
                                   format(self.gannFanGraphicsItem.pos().x(),
                                          self.gannFanGraphicsItem.pos().y()))

                    boundingRect = self.gannFanGraphicsItem.boundingRect()
                    shape = self.gannFanGraphicsItem.shape()
                    
                    self.log.debug("Bounding rect of item to add is: " +
                                   "x={}, y={}, w={}, h={}".\
                       format(boundingRect.x(),
                              boundingRect.y(),
                              boundingRect.width(),
                              boundingRect.height()))
                    
                    self.log.debug("Bounding rect of shape is: " +
                                   "x={}, y={}, w={}, h={}".\
                       format(shape.boundingRect().x(),
                              shape.boundingRect().y(),
                              shape.boundingRect().width(),
                              shape.boundingRect().height()))
                    
                    self.log.debug("Adding to scene...")
                    
                    self.scene().addItem(self.gannFanGraphicsItem)

                    self.log.debug("Making sure correct flags are set...")
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.gannFanGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.clickThreePointF == None and \
                    self.gannFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "clickThreePointF == None and " +
                                   "gannFanGraphicsItem != None.")
                    
                    # Set the click two point of the GannFanGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # Here we utilize scaling to see if
                    # self.clickTwoPointF is closer to the X axis or
                    # the Y axis of self.clickOnePointF, in view
                    # coordinates.  From this information we will set
                    # the click point.

                    scaling = self.scene().getScaling()
                    
                    viewScaledClickOnePointF = \
                        QPointF(self.clickOnePointF.x() * \
                                scaling.getViewScalingX(),
                                self.clickOnePointF.y() * \
                                scaling.getViewScalingY())
                    viewScaledClickTwoPointF = \
                        QPointF(self.clickTwoPointF.x() * \
                                scaling.getViewScalingX(),
                                self.clickTwoPointF.y() * \
                                scaling.getViewScalingY())

                    xDiff = viewScaledClickTwoPointF.x() - \
                            viewScaledClickOnePointF.x()
                    yDiff = viewScaledClickTwoPointF.y() - \
                            viewScaledClickOnePointF.y()

                    if abs(xDiff) < abs(yDiff):
                        # Closer to X axis.  Have self.clickTwoPoint
                        # point as having X values the same as
                        # self.clickOnePointF.
                        self.clickTwoPointF.setX(self.clickOnePointF.x())
                    else:
                        # Closer to Y axis.  Have self.clickTwoPoint
                        # point as having Y values the same as
                        # self.clickOnePointF.
                        self.clickTwoPointF.setY(self.clickOnePointF.y())

                    self.gannFanGraphicsItem.\
                        setLeg1PointF(self.clickTwoPointF)
                    self.gannFanGraphicsItem.\
                        setLeg2PointF(self.clickTwoPointF)
                    
                elif self.clickOnePointF != None and \
                    self.clickTwoPointF != None and \
                    self.clickThreePointF == None and \
                    self.gannFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF != None and " +
                                   "clickThreePointF == None and " +
                                   "gannFanGraphicsItem != None.")
                    
                    # Set the click three point of the GannFanGraphicsItem.
                    self.clickThreePointF = self.mapToScene(qmouseevent.pos())

                    # For the GannFan, one of the coordinates between the
                    # origin point and leg1 point is expected to be the
                    # same, always.  Same with origin point and leg2
                    # point, but it is the opposite coordinate.
                    if self.clickOnePointF.x() == self.clickTwoPointF.x():
                        self.clickThreePointF.setY(self.clickOnePointF.y())
                    else:
                        self.clickThreePointF.setX(self.clickOnePointF.x())

                    self.gannFanGraphicsItem.\
                        setLeg2PointF(self.clickThreePointF)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.gannFanGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.gannFanGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.gannFanGraphicsItem.sceneBoundingRect()
                    
                    self.log.debug("gannFanGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.clickThreePointF = None
                    self.gannFanGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickThreePointF == None and \
                   self.gannFanGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickThreePointF == None and " +
                                   "gannFanGraphicsItem != None.")
                    
                    # Right-click during setting the GannFanGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.gannFanGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.gannFanGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.clickThreePointF = None
                    self.gannFanGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.clickThreePointF == None and \
                     self.gannFanGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "clickThreePointF == None and " +
                                   "gannFanGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VimsottariDasaTool']:
            
            self.log.debug("Current toolMode is: VimsottariDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the VimsottariDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.vimsottariDasaGraphicsItem = \
                        VimsottariDasaGraphicsItem()
                    self.vimsottariDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.vimsottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.vimsottariDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.vimsottariDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.vimsottariDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.vimsottariDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.vimsottariDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.vimsottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "vimsottariDasaGraphicsItem != None.")
                    
                    # Set the end point of the VimsottariDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.vimsottariDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.vimsottariDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.vimsottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.vimsottariDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.vimsottariDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.vimsottariDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("vimsottariDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.vimsottariDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.vimsottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "vimsottariDasaGraphicsItem != None.")
                    
                    # Right-click during setting the VimsottariDasaGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.vimsottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.vimsottariDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.vimsottariDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.vimsottariDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "vimsottariDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['AshtottariDasaTool']:
            
            self.log.debug("Current toolMode is: AshtottariDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the AshtottariDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.ashtottariDasaGraphicsItem = \
                        AshtottariDasaGraphicsItem()
                    self.ashtottariDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.ashtottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.ashtottariDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.ashtottariDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.ashtottariDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.ashtottariDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.ashtottariDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.ashtottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "ashtottariDasaGraphicsItem != None.")
                    
                    # Set the end point of the AshtottariDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.ashtottariDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.ashtottariDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.ashtottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.ashtottariDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.ashtottariDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.ashtottariDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("ashtottariDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.ashtottariDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.ashtottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "ashtottariDasaGraphicsItem != None.")
                    
                    # Right-click during setting the AshtottariDasaGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.ashtottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.ashtottariDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.ashtottariDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.ashtottariDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "ashtottariDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['YoginiDasaTool']:
            
            self.log.debug("Current toolMode is: YoginiDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the YoginiDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.yoginiDasaGraphicsItem = \
                        YoginiDasaGraphicsItem()
                    self.yoginiDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.yoginiDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.yoginiDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.yoginiDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.yoginiDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.yoginiDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.yoginiDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.yoginiDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "yoginiDasaGraphicsItem != None.")
                    
                    # Set the end point of the YoginiDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.yoginiDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.yoginiDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.yoginiDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.yoginiDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.yoginiDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.yoginiDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("yoginiDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.yoginiDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.yoginiDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "yoginiDasaGraphicsItem != None.")
                    
                    # Right-click during setting the YoginiDasaGraphicsItem
                    # causes the currently edited item to be
                    # removed and cleared out.  Temporary variables used
                    # are cleared out too.
                    if self.yoginiDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.yoginiDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.yoginiDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.yoginiDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "yoginiDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwisaptatiSamaDasaTool']:
            
            self.log.debug("Current toolMode is: DwisaptatiSamaDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the DwisaptatiSamaDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.dwisaptatiSamaDasaGraphicsItem = \
                        DwisaptatiSamaDasaGraphicsItem()
                    self.dwisaptatiSamaDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.dwisaptatiSamaDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.dwisaptatiSamaDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.dwisaptatiSamaDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.dwisaptatiSamaDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.dwisaptatiSamaDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.dwisaptatiSamaDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.dwisaptatiSamaDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "dwisaptatiSamaDasaGraphicsItem != None.")
                    
                    # Set the end point of the DwisaptatiSamaDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.dwisaptatiSamaDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.dwisaptatiSamaDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.dwisaptatiSamaDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.dwisaptatiSamaDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.dwisaptatiSamaDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.dwisaptatiSamaDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("dwisaptatiSamaDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.dwisaptatiSamaDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.dwisaptatiSamaDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "dwisaptatiSamaDasaGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # DwisaptatiSamaDasaGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.dwisaptatiSamaDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.dwisaptatiSamaDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.dwisaptatiSamaDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.dwisaptatiSamaDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "dwisaptatiSamaDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShattrimsaSamaDasaTool']:
            
            self.log.debug("Current toolMode is: ShattrimsaSamaDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the ShattrimsaSamaDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.shattrimsaSamaDasaGraphicsItem = \
                        ShattrimsaSamaDasaGraphicsItem()
                    self.shattrimsaSamaDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.shattrimsaSamaDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.shattrimsaSamaDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.shattrimsaSamaDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.shattrimsaSamaDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.shattrimsaSamaDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.shattrimsaSamaDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.shattrimsaSamaDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "shattrimsaSamaDasaGraphicsItem != None.")
                    
                    # Set the end point of the ShattrimsaSamaDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.shattrimsaSamaDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.shattrimsaSamaDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.shattrimsaSamaDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.shattrimsaSamaDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.shattrimsaSamaDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.shattrimsaSamaDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("shattrimsaSamaDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.shattrimsaSamaDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.shattrimsaSamaDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "shattrimsaSamaDasaGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # ShattrimsaSamaDasaGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.shattrimsaSamaDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.shattrimsaSamaDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.shattrimsaSamaDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.shattrimsaSamaDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "shattrimsaSamaDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwadasottariDasaTool']:
            
            self.log.debug("Current toolMode is: DwadasottariDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the DwadasottariDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.dwadasottariDasaGraphicsItem = \
                        DwadasottariDasaGraphicsItem()
                    self.dwadasottariDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.dwadasottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.dwadasottariDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.dwadasottariDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.dwadasottariDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.dwadasottariDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.dwadasottariDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.dwadasottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "dwadasottariDasaGraphicsItem != None.")
                    
                    # Set the end point of the DwadasottariDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.dwadasottariDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.dwadasottariDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.dwadasottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.dwadasottariDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.dwadasottariDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.dwadasottariDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("dwadasottariDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.dwadasottariDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.dwadasottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "dwadasottariDasaGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # DwadasottariDasaGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.dwadasottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.dwadasottariDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.dwadasottariDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.dwadasottariDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "dwadasottariDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ChaturaseetiSamaDasaTool']:
            
            self.log.debug("Current toolMode is: ChaturaseetiSamaDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the ChaturaseetiSamaDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.chaturaseetiSamaDasaGraphicsItem = \
                        ChaturaseetiSamaDasaGraphicsItem()
                    self.chaturaseetiSamaDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.chaturaseetiSamaDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.chaturaseetiSamaDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.chaturaseetiSamaDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.chaturaseetiSamaDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.chaturaseetiSamaDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.chaturaseetiSamaDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.chaturaseetiSamaDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "chaturaseetiSamaDasaGraphicsItem != None.")
                    
                    # Set the end point of the ChaturaseetiSamaDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.chaturaseetiSamaDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.chaturaseetiSamaDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.chaturaseetiSamaDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.chaturaseetiSamaDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.chaturaseetiSamaDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.chaturaseetiSamaDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("chaturaseetiSamaDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.chaturaseetiSamaDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.chaturaseetiSamaDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "chaturaseetiSamaDasaGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # ChaturaseetiSamaDasaGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.chaturaseetiSamaDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.chaturaseetiSamaDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.chaturaseetiSamaDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.chaturaseetiSamaDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "chaturaseetiSamaDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['SataabdikaDasaTool']:
            
            self.log.debug("Current toolMode is: SataabdikaDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the SataabdikaDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.sataabdikaDasaGraphicsItem = \
                        SataabdikaDasaGraphicsItem()
                    self.sataabdikaDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.sataabdikaDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.sataabdikaDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.sataabdikaDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.sataabdikaDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.sataabdikaDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.sataabdikaDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.sataabdikaDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "sataabdikaDasaGraphicsItem != None.")
                    
                    # Set the end point of the SataabdikaDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.sataabdikaDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.sataabdikaDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.sataabdikaDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.sataabdikaDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.sataabdikaDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.sataabdikaDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("sataabdikaDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.sataabdikaDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.sataabdikaDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "sataabdikaDasaGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # SataabdikaDasaGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.sataabdikaDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.sataabdikaDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.sataabdikaDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.sataabdikaDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "sataabdikaDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShodasottariDasaTool']:
            
            self.log.debug("Current toolMode is: ShodasottariDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the ShodasottariDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.shodasottariDasaGraphicsItem = \
                        ShodasottariDasaGraphicsItem()
                    self.shodasottariDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.shodasottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.shodasottariDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.shodasottariDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.shodasottariDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.shodasottariDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.shodasottariDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.shodasottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "shodasottariDasaGraphicsItem != None.")
                    
                    # Set the end point of the ShodasottariDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.shodasottariDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.shodasottariDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.shodasottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.shodasottariDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.shodasottariDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.shodasottariDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("shodasottariDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.shodasottariDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.shodasottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "shodasottariDasaGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # ShodasottariDasaGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.shodasottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.shodasottariDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.shodasottariDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.shodasottariDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "shodasottariDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PanchottariDasaTool']:
            
            self.log.debug("Current toolMode is: PanchottariDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the PanchottariDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.panchottariDasaGraphicsItem = \
                        PanchottariDasaGraphicsItem()
                    self.panchottariDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.panchottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.panchottariDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.panchottariDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.panchottariDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.panchottariDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.panchottariDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.panchottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "panchottariDasaGraphicsItem != None.")
                    
                    # Set the end point of the PanchottariDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.panchottariDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.panchottariDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.panchottariDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.panchottariDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.panchottariDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.panchottariDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("panchottariDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.panchottariDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.panchottariDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "panchottariDasaGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # PanchottariDasaGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.panchottariDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.panchottariDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.panchottariDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.panchottariDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "panchottariDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShashtihayaniDasaTool']:
            
            self.log.debug("Current toolMode is: ShashtihayaniDasaTool")

            if qmouseevent.button() & Qt.LeftButton:
                self.log.debug("Qt.LeftButton")
                
                if self.clickOnePointF == None:
                    self.log.debug("clickOnePointF is None.")
                    
                    self.clickOnePointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickOnePointF.setX(x)
                    
                    # Create the ShashtihayaniDasaGraphicsItem and
                    # initialize it to the mouse location.
                    self.shashtihayaniDasaGraphicsItem = \
                        ShashtihayaniDasaGraphicsItem()
                    self.shashtihayaniDasaGraphicsItem.\
                        loadSettingsFromPriceBarChartSettings(\
                            self.priceBarChartSettings)

                    # Set the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.  We
                    # will turn these off after the user fully
                    # finishes adding the item.
                    self.shashtihayaniDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(True)
                    
                    self.shashtihayaniDasaGraphicsItem.\
                        setPos(self.clickOnePointF)
                    self.shashtihayaniDasaGraphicsItem.\
                        setStartPointF(self.clickOnePointF)
                    self.shashtihayaniDasaGraphicsItem.\
                        setEndPointF(self.clickOnePointF)
                    self.scene().addItem(self.shashtihayaniDasaGraphicsItem)
                    
                    # Make sure the proper flags are set for the mode we're in.
                    self.setGraphicsItemFlagsPerCurrToolMode(\
                        self.shashtihayaniDasaGraphicsItem)

                elif self.clickOnePointF != None and \
                    self.clickTwoPointF == None and \
                    self.shashtihayaniDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "shashtihayaniDasaGraphicsItem != None.")
                    
                    # Set the end point of the ShashtihayaniDasaGraphicsItem.
                    self.clickTwoPointF = self.mapToScene(qmouseevent.pos())

                    # If snap is enabled, then find the closest
                    # pricebar time to the place clicked.
                    if self.snapEnabledFlag == True:
                        self.log.debug("Snap is enabled, so snapping to " +
                                       "closest pricebar X.")
                        
                        infoPointF = self.mapToScene(qmouseevent.pos())
                        x = self.scene().getClosestPriceBarX(infoPointF)

                        # Use this X value.
                        self.clickTwoPointF.setX(x)
                    
                    newEndPointF = QPointF(self.clickTwoPointF.x(),
                                           self.clickOnePointF.y())
                    self.shashtihayaniDasaGraphicsItem.\
                        setEndPointF(newEndPointF)
                    self.shashtihayaniDasaGraphicsItem.normalizeStartAndEnd()

                    # Unset the flag that indicates we should draw
                    # dotted vertical lines at the tick areas.
                    self.shashtihayaniDasaGraphicsItem.\
                        setDrawVerticalDottedLinesFlag(False)
                    
                    # Call getArtifact() so that the item's artifact
                    # object gets updated and set.
                    self.shashtihayaniDasaGraphicsItem.getArtifact()
                    
                    # Emit that the PriceBarChart has changed.
                    self.scene().priceBarChartArtifactGraphicsItemAdded.\
                        emit(self.shashtihayaniDasaGraphicsItem)
                    
                    sceneBoundingRect = \
                        self.shashtihayaniDasaGraphicsItem.sceneBoundingRect()
                    self.log.debug("shashtihayaniDasaGraphicsItem " +
                                   "officially added.  " +
                                   "Its sceneBoundingRect is: {}.  ".\
                                   format(sceneBoundingRect) +
                                   "Its x range is: {} to {}.  ".\
                                   format(sceneBoundingRect.left(),
                                          sceneBoundingRect.right()) +
                                   "Its y range is: {} to {}.  ".\
                                   format(sceneBoundingRect.top(),
                                          sceneBoundingRect.bottom()))

                    # Clear out working variables.
                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.shashtihayaniDasaGraphicsItem = None
                    
                else:
                    self.log.warn("Unexpected state reached.")
                    
            elif qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                if self.clickOnePointF != None and \
                   self.clickTwoPointF == None and \
                   self.shashtihayaniDasaGraphicsItem != None:

                    self.log.debug("clickOnePointF != None, and " +
                                   "clickTwoPointF == None and " +
                                   "shashtihayaniDasaGraphicsItem != None.")
                    
                    # Right-click during setting the
                    # ShashtihayaniDasaGraphicsItem causes the
                    # currently edited item to be removed
                    # and cleared out.  Temporary variables used are
                    # cleared out too.
                    if self.shashtihayaniDasaGraphicsItem.scene() != None:
                        self.scene().\
                            removeItem(self.shashtihayaniDasaGraphicsItem)

                    self.clickOnePointF = None
                    self.clickTwoPointF = None
                    self.shashtihayaniDasaGraphicsItem = None
                    
                elif self.clickOnePointF == None and \
                     self.clickTwoPointF == None and \
                     self.shashtihayaniDasaGraphicsItem == None:
                    
                    self.log.debug("clickOnePointF == None, and " +
                                   "clickTwoPointF == None and " +
                                   "shashtihayaniDasaGraphicsItem == None.")
                    
                    # Open a context menu at this location, in readonly mode.
                    clickPosF = self.mapToScene(qmouseevent.pos())
                    menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                    menu.exec_(qmouseevent.globalPos())
                    
                else:
                    self.log.warn("Unexpected state reached.")

        else:
            self.log.warn("Current toolMode is: UNKNOWN.")

            # For any other mode we don't have specific functionality
            # for, do a context menu if it is a right-click, otherwise
            # just pass the event to the parent to handle.
            if qmouseevent.button() & Qt.RightButton:
                self.log.debug("Qt.RightButton")
                
                # Open a context menu at this location, in readonly mode.
                clickPosF = self.mapToScene(qmouseevent.pos())
                menu = self.createContextMenu(clickPosF, readOnlyFlag=True)
                menu.exec_(qmouseevent.globalPos())
            else:
                self.log.debug("Passing mouse press event to super().")
                super().mousePressEvent(qmouseevent)

        self.log.debug("Exiting mousePressEvent()")

    def mouseReleaseEvent(self, qmouseevent):
        """Triggered when the mouse is pressed in this widget."""

        self.log.debug("Entered mouseReleaseEvent()")

        if self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']:

            self.log.debug("Current toolMode is: ReadOnlyPointerTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PointerTool']:

            self.log.debug("Current toolMode is: PointerTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HandTool']:

            self.log.debug("Current toolMode is: HandTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomInTool']:

            self.log.debug("Current toolMode is: ZoomInTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomOutTool']:

            self.log.debug("Current toolMode is: ZoomOutTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['BarCountTool']:

            self.log.debug("Current toolMode is: BarCountTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeMeasurementTool']:

            self.log.debug("Current toolMode is: TimeMeasurementTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeModalScaleTool']:

            self.log.debug("Current toolMode is: TimeModalScaleTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceModalScaleTool']:

            self.log.debug("Current toolMode is: PriceModalScaleTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PlanetLongitudeMovementMeasurementTool']:

            self.log.debug("Current toolMode is: PlanetLongitudeMovementMeasurementTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TextTool']:

            self.log.debug("Current toolMode is: TextTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeInfoTool']:

            self.log.debug("Current toolMode is: PriceTimeInfoTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceMeasurementTool']:

            self.log.debug("Current toolMode is: PriceMeasurementTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeRetracementTool']:

            self.log.debug("Current toolMode is: TimeRetracementTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceRetracementTool']:

            self.log.debug("Current toolMode is: PriceRetracementTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeVectorTool']:

            self.log.debug("Current toolMode is: PriceTimeVectorTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment1Tool']:

            self.log.debug("Current toolMode is: LineSegment1Tool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment2Tool']:

            self.log.debug("Current toolMode is: LineSegment2Tool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VerticalLineSegmentTool']:

            self.log.debug("Current toolMode is: VerticalLineSegmentTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HorizontalLineSegmentTool']:

            self.log.debug("Current toolMode is: HorizontalLineSegmentTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['OctaveFanTool']:

            self.log.debug("Current toolMode is: OctaveFanTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['FibFanTool']:

            self.log.debug("Current toolMode is: FibFanTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['GannFanTool']:

            self.log.debug("Current toolMode is: GannFanTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VimsottariDasaTool']:

            self.log.debug("Current toolMode is: VimsottariDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['AshtottariDasaTool']:

            self.log.debug("Current toolMode is: AshtottariDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['YoginiDasaTool']:

            self.log.debug("Current toolMode is: YoginiDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwisaptatiSamaDasaTool']:

            self.log.debug("Current toolMode is: DwisaptatiSamaDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShattrimsaSamaDasaTool']:

            self.log.debug("Current toolMode is: ShattrimsaSamaDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwadasottariDasaTool']:

            self.log.debug("Current toolMode is: DwadasottariDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ChaturaseetiSamaDasaTool']:

            self.log.debug("Current toolMode is: ChaturaseetiSamaDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['SataabdikaDasaTool']:

            self.log.debug("Current toolMode is: SataabdikaDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShodasottariDasaTool']:

            self.log.debug("Current toolMode is: ShodasottariDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PanchottariDasaTool']:

            self.log.debug("Current toolMode is: PanchottariDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShashtihayaniDasaTool']:

            self.log.debug("Current toolMode is: ShashtihayaniDasaTool")
            super().mouseReleaseEvent(qmouseevent)

        else:
            # For any other mode we don't have specific functionality for,
            # just pass the event to the parent to handle.
            self.log.warn("Current toolMode is: UNKNOWN.")
            super().mouseReleaseEvent(qmouseevent)

        self.log.debug("Exiting mouseReleaseEvent()")

    def mouseMoveEvent(self, qmouseevent):
        """Triggered when the mouse is moving in this widget."""

        # Emit the current mouse location in scene coordinates.
        posScene = self.mapToScene(qmouseevent.pos())
        self.lastMousePosScene = posScene
        self.mouseLocationUpdate.emit(posScene.x(), posScene.y())

        # Handle key functionality relevant to all tool modes.
        if self.toolMode in PriceBarChartGraphicsView.ToolMode.values():
            
            if self.verticalDashedLineEnabled == True and \
                    self.verticalDashedLineGraphicsItem != None:

                # Gather information for setting the line's location 
                # and start/end points.
                
                # Get the lowest and highest prices among both PriceBars and 
                # LookbackMultiplePriceBars.
                lowestPrice = self.scene().getLowestPriceBar().low
                highestPrice = self.scene().getHighestPriceBar().high

                lowestLookbackMultiplePriceBar = \
                    self.scene().getLowestLookbackMultiplePriceBar()
                if lowestLookbackMultiplePriceBar != None:
                    lmpbLowestPrice = lowestLookbackMultiplePriceBar.low
                    if lmpbLowestPrice < lowestPrice:
                        lowestPrice = lmpbLowestPrice

                highestLookbackMultiplePriceBar = \
                    self.scene().getHighestLookbackMultiplePriceBar()
                if highestLookbackMultiplePriceBar != None:
                    lmpbHighestPrice = highestLookbackMultiplePriceBar.high
                    if lmpbHighestPrice > highestPrice:
                        highestPrice = lmpbHighestPrice

                lowY = self.scene().priceToSceneYPos(lowestPrice)
                highY = self.scene().priceToSceneYPos(highestPrice)

                posX = None
                if self.lastMousePosScene != None:
                    posX = self.lastMousePosScene.x()
                else:
                    # No last mouse position, so just use the X position 
                    # of an arbitrary PriceBar in the scene.
                    dt = self.scene().getHighestPriceBar().timestamp
                    posX = self.scene().datetimeToSceneXPos(dt)

                lowPointF = QPointF(posX, lowY)
                highPointF = QPointF(posX, highY)
    
                # Set the position and start/end points.
                self.verticalDashedLineGraphicsItem.setPos(lowPointF)
                self.verticalDashedLineGraphicsItem.setStartPointF(lowPointF)
                self.verticalDashedLineGraphicsItem.setEndPointF(highPointF)

            if self.horizontalDashedLineEnabled == True and \
                    self.horizontalDashedLineGraphicsItem != None:

                # Gather information for setting the line's location 
                # and start/end points.
                
                # Get the earliest and latest timestamps among both PriceBars 
                # and LookbackMultiplePriceBars.
                earliestDt = self.scene().getEarliestPriceBar().timestamp
                latestDt = self.scene().getLatestPriceBar().timestamp

                earliestLookbackMultiplePriceBar = \
                    self.scene().getEarliestLookbackMultiplePriceBar()
                if earliestLookbackMultiplePriceBar != None:
                    lmpbEarliestDt = \
                        earliestLookbackMultiplePriceBar.timestamp
                    if lmpbEarliestDt < earliestDt:
                        earliestDt = lmpbEarliestDt

                latestLookbackMultiplePriceBar = \
                    self.scene().getLatestLookbackMultiplePriceBar()
                if latestLookbackMultiplePriceBar != None:
                    lmpbLatestDt = \
                        latestLookbackMultiplePriceBar.timestamp
                    if lmpbLatestDt > latestDt:
                        latestDt = lmpbLatestDt

                earliestX = self.scene().datetimeToSceneXPos(earliestDt)
                latestX = self.scene().datetimeToSceneXPos(latestDt)

                posY = None
                if self.lastMousePosScene != None:
                    posY = self.lastMousePosScene.y()
                else:
                    # No last mouse position, so just use the Y position 
                    # of an arbitrary PriceBar in the scene.
                    highPrice = self.scene().getLatestPriceBar().high
                    posY = self.scene().priceToSceneYPos(highPrice)

                earliestPointF = QPointF(earliestX, posY)
                latestPointF = QPointF(latestX, posY)

                # Set the position and start/end points.
                self.horizontalDashedLineGraphicsItem.setPos(earliestPointF)
                self.horizontalDashedLineGraphicsItem.setStartPointF(earliestPointF)
                self.horizontalDashedLineGraphicsItem.setEndPointF(latestPointF)

        if self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']:

            super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PointerTool']:

            super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HandTool']:

            super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomInTool']:

            super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomOutTool']:

            super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['BarCountTool']:

            if self.clickOnePointF != None and \
                self.barCountGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # BarCountGraphicsItem.
                self.barCountGraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeMeasurementTool']:

            if self.clickOnePointF != None and \
                self.timeMeasurementGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # TimeMeasurementGraphicsItem.
                self.timeMeasurementGraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeModalScaleTool']:

            if self.clickOnePointF != None and \
                self.timeModalScaleGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # TimeModalScaleGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.timeModalScaleGraphicsItem.endPointF.y())
                self.timeModalScaleGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceModalScaleTool']:

            if self.clickOnePointF != None and \
                self.priceModalScaleGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # PriceModalScaleGraphicsItem.
                newEndPointF = \
                    QPointF(self.priceModalScaleGraphicsItem.endPointF.x(),
                            pos.y())
                self.priceModalScaleGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PlanetLongitudeMovementMeasurementTool']:

            if self.clickOnePointF != None and \
                self.planetLongitudeMovementMeasurementGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # PlanetLongitudeMovementMeasurementGraphicsItem.
                self.planetLongitudeMovementMeasurementGraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TextTool']:

            super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeInfoTool']:

            if self.clickOnePointF != None and \
                self.priceTimeInfoGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Set the position of the item by calling the set
                # function for the Y location of the edge of the
                # text.
                posY = pos.y()
                self.priceTimeInfoGraphicsItem.setTextLabelEdgeYLocation(posY)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceMeasurementTool']:

            if self.clickOnePointF != None and \
                self.priceMeasurementGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # PriceMeasurementGraphicsItem.
                self.priceMeasurementGraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeRetracementTool']:

            if self.clickOnePointF != None and \
                self.timeRetracementGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # TimeRetracementGraphicsItem.
                self.timeRetracementGraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceRetracementTool']:

            if self.clickOnePointF != None and \
                self.priceRetracementGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # PriceRetracementGraphicsItem.
                self.priceRetracementGraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeVectorTool']:

            if self.clickOnePointF != None and \
                self.priceTimeVectorGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # PriceTimeVectorGraphicsItem.
                self.priceTimeVectorGraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment1Tool']:

            if self.clickOnePointF != None and \
                self.lineSegment1GraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # LineSegment1GraphicsItem.
                self.lineSegment1GraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment2Tool']:

            if self.clickOnePointF != None and \
                self.lineSegment2GraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # LineSegment2GraphicsItem.
                self.lineSegment2GraphicsItem.setEndPointF(pos)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VerticalLineSegmentTool']:

            if self.clickOnePointF != None and \
                self.verticalLineSegmentGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())

                # Use the first click's x value to ensure that the endpoint is 
                # a vertical line segment per VerticalLineSegmentGraphicsItem.
                endPointF = QPointF(self.clickOnePointF.x(), pos.y())

                # Update the end point of the current
                # VerticalLineSegmentGraphicsItem.
                self.verticalLineSegmentGraphicsItem.setEndPointF(endPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HorizontalLineSegmentTool']:

            if self.clickOnePointF != None and \
                self.horizontalLineSegmentGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())

                # Use the first click's y value to ensure that the endpoint is 
                # a horizontal line segment per HorizontalLineSegmentGraphicsItem.
                endPointF = QPointF(pos.x(), self.clickOnePointF.y())

                # Update the end point of the current
                # HorizontalLineSegmentGraphicsItem.
                self.horizontalLineSegmentGraphicsItem.setEndPointF(endPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['OctaveFanTool']:

            if self.clickOnePointF != None and \
                self.clickTwoPointF == None and \
                self.clickThreePointF == None and \
                self.octaveFanGraphicsItem != None:

                self.log.debug("OctaveFanTool: " +
                               "Moving when clickOnePointF has " +
                               "been set already.")
                
                pos = self.mapToScene(qmouseevent.pos())

                self.log.debug("pos is: ({}, {})".format(pos.x(), pos.y()))
                
                # Update the leg1 and leg2 points of the current
                # OctaveFanGraphicsItem.
                self.octaveFanGraphicsItem.setLeg1PointF(pos)
                self.octaveFanGraphicsItem.setLeg2PointF(pos)
                
            elif self.clickOnePointF != None and \
                 self.clickTwoPointF != None and \
                 self.clickThreePointF == None and \
                 self.octaveFanGraphicsItem != None:

                self.log.debug("OctaveFanTool: " +
                               "Moving when clickTwoPointF has " +
                               "been set already.")
                
                pos = self.mapToScene(qmouseevent.pos())
                
                self.log.debug("pos is: ({}, {})".format(pos.x(), pos.y()))
                
                # Update the leg2 point of the current
                # OctaveFanGraphicsItem.
                self.octaveFanGraphicsItem.setLeg2PointF(pos)
                
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['FibFanTool']:

            if self.clickOnePointF != None and \
                self.clickTwoPointF == None and \
                self.clickThreePointF == None and \
                self.fibFanGraphicsItem != None:

                self.log.debug("FibFanTool: " +
                               "Moving when clickOnePointF has " +
                               "been set already.")
                
                pos = self.mapToScene(qmouseevent.pos())

                self.log.debug("pos is: ({}, {})".format(pos.x(), pos.y()))
                
                # Update the leg1 and leg2 points of the current
                # FibFanGraphicsItem.
                self.fibFanGraphicsItem.setLeg1PointF(pos)
                self.fibFanGraphicsItem.setLeg2PointF(pos)
                
            elif self.clickOnePointF != None and \
                 self.clickTwoPointF != None and \
                 self.clickThreePointF == None and \
                 self.fibFanGraphicsItem != None:

                self.log.debug("FibFanTool: " +
                               "Moving when clickTwoPointF has " +
                               "been set already.")
                
                pos = self.mapToScene(qmouseevent.pos())
                
                self.log.debug("pos is: ({}, {})".format(pos.x(), pos.y()))
                
                # Update the leg2 point of the current
                # FibFanGraphicsItem.
                self.fibFanGraphicsItem.setLeg2PointF(pos)
                
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['GannFanTool']:

            if self.clickOnePointF != None and \
                self.clickTwoPointF == None and \
                self.clickThreePointF == None and \
                self.gannFanGraphicsItem != None:

                self.log.debug("GannFanTool: " +
                               "Moving when clickOnePointF has " +
                               "been set already.")
                
                pos = self.mapToScene(qmouseevent.pos())
                
                self.log.debug("pos is: ({}, {})".format(pos.x(), pos.y()))

                # Here we utilize scaling to see if 'pos' is closer to
                # the X axis or the Y axis of self.clickOnePointF, in
                # view coordinates.  From this information we will set
                # the next click point.

                scaling = self.scene().getScaling()
                
                viewScaledClickOnePointF = \
                    QPointF(self.clickOnePointF.x() * scaling.getViewScalingX(),
                            self.clickOnePointF.y() * scaling.getViewScalingY())
                viewScaledPointF = \
                    QPointF(pos.x() * scaling.getViewScalingX(),
                            pos.y() * scaling.getViewScalingY())

                xDiff = viewScaledPointF.x() - viewScaledClickOnePointF.x()
                yDiff = viewScaledPointF.y() - viewScaledClickOnePointF.y()
                
                if abs(xDiff) < abs(yDiff):
                    # Closer to X axis.  Have this point as having X
                    # values the same as self.clickOnePointF.
                    pos.setX(self.clickOnePointF.x())
                else:
                    # Closer to the Y axis.  Have this point as having
                    # Y values the same as self.clickOnePointF.
                    pos.setY(self.clickOnePointF.y())
                
                self.log.debug("pos after adj. is: ({}, {})".\
                               format(pos.x(), pos.y()))
                
                # Update the leg1 and leg2 points of the current
                # GannFanGraphicsItem.
                self.gannFanGraphicsItem.setLeg1PointF(pos)
                self.gannFanGraphicsItem.setLeg2PointF(pos)
                
            elif self.clickOnePointF != None and \
                 self.clickTwoPointF != None and \
                 self.clickThreePointF == None and \
                 self.gannFanGraphicsItem != None:

                self.log.debug("GannFanTool: " +
                               "Moving when clickTwoPointF has " +
                               "been set already.")
                
                pos = self.mapToScene(qmouseevent.pos())
                
                self.log.debug("pos is: ({}, {})".format(pos.x(), pos.y()))

                # For the GannFan, one of the coordinates between the
                # origin point and leg1 point is expected to be the
                # same, always.  Same with origin point and leg2
                # point, but it is the opposite coordinate.
                if self.clickOnePointF.x() == self.clickTwoPointF.x():
                    pos.setY(self.clickOnePointF.y())
                else:
                    pos.setX(self.clickOnePointF.x())
                
                self.log.debug("pos after adj. is: ({}, {})".\
                               format(pos.x(), pos.y()))
                
                # Update the leg2 point of the current
                # GannFanGraphicsItem.
                self.gannFanGraphicsItem.setLeg2PointF(pos)
                
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VimsottariDasaTool']:

            if self.clickOnePointF != None and \
                self.vimsottariDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # VimsottariDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.vimsottariDasaGraphicsItem.endPointF.y())
                self.vimsottariDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['AshtottariDasaTool']:

            if self.clickOnePointF != None and \
                self.ashtottariDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # AshtottariDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.ashtottariDasaGraphicsItem.endPointF.y())
                self.ashtottariDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['YoginiDasaTool']:

            if self.clickOnePointF != None and \
                self.yoginiDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # YoginiDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.yoginiDasaGraphicsItem.endPointF.y())
                self.yoginiDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwisaptatiSamaDasaTool']:

            if self.clickOnePointF != None and \
                self.dwisaptatiSamaDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # DwisaptatiSamaDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.dwisaptatiSamaDasaGraphicsItem.endPointF.y())
                self.dwisaptatiSamaDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShattrimsaSamaDasaTool']:

            if self.clickOnePointF != None and \
                self.shattrimsaSamaDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # ShattrimsaSamaDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.shattrimsaSamaDasaGraphicsItem.endPointF.y())
                self.shattrimsaSamaDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwadasottariDasaTool']:

            if self.clickOnePointF != None and \
                self.dwadasottariDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # DwadasottariDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.dwadasottariDasaGraphicsItem.endPointF.y())
                self.dwadasottariDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ChaturaseetiSamaDasaTool']:

            if self.clickOnePointF != None and \
                self.chaturaseetiSamaDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # ChaturaseetiSamaDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.chaturaseetiSamaDasaGraphicsItem.endPointF.y())
                self.chaturaseetiSamaDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['SataabdikaDasaTool']:

            if self.clickOnePointF != None and \
                self.sataabdikaDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # SataabdikaDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.sataabdikaDasaGraphicsItem.endPointF.y())
                self.sataabdikaDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShodasottariDasaTool']:

            if self.clickOnePointF != None and \
                self.shodasottariDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # ShodasottariDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.shodasottariDasaGraphicsItem.endPointF.y())
                self.shodasottariDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PanchottariDasaTool']:

            if self.clickOnePointF != None and \
                self.panchottariDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # PanchottariDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.panchottariDasaGraphicsItem.endPointF.y())
                self.panchottariDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShashtihayaniDasaTool']:

            if self.clickOnePointF != None and \
                self.shashtihayaniDasaGraphicsItem != None:

                pos = self.mapToScene(qmouseevent.pos())
                
                # Update the end point of the current
                # ShashtihayaniDasaGraphicsItem.
                newEndPointF = \
                    QPointF(pos.x(),
                            self.shashtihayaniDasaGraphicsItem.endPointF.y())
                self.shashtihayaniDasaGraphicsItem.setEndPointF(newEndPointF)
            else:
                super().mouseMoveEvent(qmouseevent)

        else:
            # For any other mode we don't have specific functionality for,
            # just pass the event to the parent to handle.
            super().mouseMoveEvent(qmouseevent)



    def enterEvent(self, qevent):
        """Overwrites the QWidget.enterEvent() function.  

        Whenever the mouse enters the area of this widget, this function
        is called.  I've overwritten this function to change the mouse
        cursor according to what tool mode is currently active.

        Arguments:

        qevent - QEvent object that triggered this function call.
        """

        self.log.debug("Entered enterEvent()")

        # Set the cursor shape/image according to what tool mode the
        # pricebarchart is in.

        if self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ReadOnlyPointerTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PointerTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HandTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomInTool']:
            pixmap = QPixmap(":/images/rluu/zoomIn.png")
            self.setCursor(QCursor(pixmap))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ZoomOutTool']:
            pixmap = QPixmap(":/images/rluu/zoomOut.png")
            self.setCursor(QCursor(pixmap))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['BarCountTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeMeasurementTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeModalScaleTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceModalScaleTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PlanetLongitudeMovementMeasurementTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TextTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeInfoTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceMeasurementTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['TimeRetracementTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceRetracementTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PriceTimeVectorTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment1Tool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['LineSegment2Tool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VerticalLineSegmentTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['HorizontalLineSegmentTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['OctaveFanTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['FibFanTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['GannFanTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['VimsottariDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['AshtottariDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['YoginiDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwisaptatiSamaDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShattrimsaSamaDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['DwadasottariDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ChaturaseetiSamaDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['SataabdikaDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShodasottariDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['PanchottariDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        elif self.toolMode == \
                PriceBarChartGraphicsView.ToolMode['ShashtihayaniDasaTool']:
            self.setCursor(QCursor(Qt.ArrowCursor))
        else:
            self.log.warn("Unknown toolMode while in enterEvent().")

        # Allow any other super classes to process the event as well.
        super().enterEvent(qevent)

        self.log.debug("Exiting enterEvent()")

    def leaveEvent(self, qevent):
        """Overwrites the QWidget.leaveEvent() function.  

        Whenever the mouse leaves the area of this widget, this function
        is called.  I've overwritten this function to change the mouse
        cursor from whatever it is currently set to, back to the original
        pointer cursor.

        Arguments:

        qevent - QEvent object that triggered this function call.
        """

        self.log.debug("Entered leaveEvent()")

        # Set the cursor shape/image to the ArrowCursor.
        self.setCursor(QCursor(Qt.ArrowCursor))

        # Allow any other super classes to process the event as well.
        super().leaveEvent(qevent)

        self.log.debug("Exiting leaveEvent()")

